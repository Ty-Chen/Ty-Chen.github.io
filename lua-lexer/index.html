<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/kulamati128.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/kulamati32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/kulamati16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Lua,脚本语言,语法解析,词法解析," />










<meta name="description" content="一. 简介&amp;emsp;&amp;emsp;前文中，我们先后介绍了Lua总体设计的思路，栈结构体及执行逻辑，基本数据结构极其实现，虚拟机的执行逻辑等，但是尚未涉及到脚本如何加载并转化为一个一个的字节码从而执行的过程。本文就此进行分析讨论。脚本语言的编译可以分为词法分析、语法分析阶段。词法分析阶段顾名思义就是将脚本加载并进行解析，分解为一个一个的基础的词并保存起来，由于后面的语法分析使用。而语法分析就是分析解">
<meta property="og:type" content="article">
<meta property="og:title" content="Lua源码剖析（六）词法分析">
<meta property="og:url" content="https://ty-chen.github.io/lua-lexer/index.html">
<meta property="og:site_name" content="Ty-Chen&#39;s Home">
<meta property="og:description" content="一. 简介&amp;emsp;&amp;emsp;前文中，我们先后介绍了Lua总体设计的思路，栈结构体及执行逻辑，基本数据结构极其实现，虚拟机的执行逻辑等，但是尚未涉及到脚本如何加载并转化为一个一个的字节码从而执行的过程。本文就此进行分析讨论。脚本语言的编译可以分为词法分析、语法分析阶段。词法分析阶段顾名思义就是将脚本加载并进行解析，分解为一个一个的基础的词并保存起来，由于后面的语法分析使用。而语法分析就是分析解">
<meta property="article:published_time" content="2023-02-13T17:03:04.000Z">
<meta property="article:modified_time" content="2024-03-18T03:31:54.766Z">
<meta property="article:author" content="Ty Chen">
<meta property="article:tag" content="Lua">
<meta property="article:tag" content="脚本语言">
<meta property="article:tag" content="语法解析">
<meta property="article:tag" content="词法解析">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://ty-chen.github.io/lua-lexer/"/>





  <title>Lua源码剖析（六）词法分析 | Ty-Chen's Home</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ty-Chen's Home</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Collecting, sharing and creating knowledge</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ty-chen.github.io/lua-lexer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ty Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty-Chen's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Lua源码剖析（六）词法分析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-02-14T01:03:04+08:00">
                2023-02-14
              </time>
            

            

            
          </span>
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2024-03-18T11:31:54+08:00" content="2024-03-18">
                2024-03-18
              </time>
            </span>
          
          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Lua%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index">
                    <span itemprop="name">Lua学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/lua-lexer/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/lua-lexer/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv">访问次数：
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  15
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一. 简介"></a>一. 简介</h2><p>&emsp;&emsp;前文中，我们先后介绍了Lua总体设计的思路，栈结构体及执行逻辑，基本数据结构极其实现，虚拟机的执行逻辑等，但是尚未涉及到脚本如何加载并转化为一个一个的字节码从而执行的过程。本文就此进行分析讨论。脚本语言的编译可以分为词法分析、语法分析阶段。词法分析阶段顾名思义就是将脚本加载并进行解析，分解为一个一个的基础的词并保存起来，由于后面的语法分析使用。而语法分析就是分析解释这些词的合理性及逻辑，并生成对应的字节码。这些字节码则将交给虚拟机去挨个执行，从而实现脚本的逻辑功能。</p>
<a id="more"></a>

<h2 id="二-基础结构体"><a href="#二-基础结构体" class="headerlink" title="二. 基础结构体"></a>二. 基础结构体</h2><p>&emsp;&emsp;词法分析的大致功能包括了加载、解析，因此其总的状态管理类至少需要包括：</p>
<ul>
<li>文件名、当前读取的字符、行号</li>
<li>一个用于保存当前已读取的内容的缓存Buffer，读取完毕之后才转化为一个词，即<code>token</code>。这里缓存区可以预先申请一块大小，然后记录当前用了多少以及总大小，如果全部用尽还没有完成一个<code>token</code>的读取，则重新分配缓冲区。</li>
<li>当前的token</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span>* buff;</span><br><span class="line">    <span class="keyword">int</span>   nUsedSize;</span><br><span class="line">    <span class="keyword">int</span>   nBuffSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LexState</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TString* FileName;</span><br><span class="line">    <span class="keyword">int</span> nCurrent;</span><br><span class="line">    <span class="keyword">int</span> nCurrentLine;</span><br><span class="line">    Buffer *buf;</span><br><span class="line">    Token t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;除此之外，读取的文件如果一次性全读完或者按字节来读和操作，效率均会有所影响，比较合适的是建立一块缓冲区域，每次从缓冲区域读取，缓冲区用尽则从文件继续读。除了缓冲区的数据块<code>pData</code>以外，尚需要一个指针指向当前读的字符，以及一个变量来存储还剩多少字节可读。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FileIO</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nUnreadSize;</span><br><span class="line">    <span class="keyword">char</span>* pCurr;</span><br><span class="line">    <span class="keyword">void</span>* pData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LexState</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TString* FileName;</span><br><span class="line">    <span class="keyword">int</span>      nCurrent;</span><br><span class="line">    <span class="keyword">int</span>      nCurrentLine;</span><br><span class="line">    Buffer*  buf;</span><br><span class="line">    <span class="built_in">FileIO</span>*  pIO;</span><br><span class="line">    Token    t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在我们有了文件缓冲区，当前token的状态及读取缓冲区，但是我们还需要一个很重要的东西：当前函数的信息记录。lua脚本设计为多级函数的关系，而整个文件初始就是一个函数。前文中我们已经详细叙述了闭包<code>Closure</code>和函数原型<code>Proto</code>，而文件解析编译的任务中自然也包括了<code>Proto</code>的新建和填充，供以最终生成<code>Closure</code>以及执行<code>Proto</code>中的众多指令。</p>
<p>&emsp;&emsp;这里当然可以直接再<code>LexState</code>中加入<code>Proto</code>链表，后续语法解析完，实际调用函数的时候生成<code>Closure</code>并装载对应的<code>Proto</code>从而执行。但是在词法、语法解析的过程中，我们需要存储诸多的中间变量以及当前的状态信息，这些东西用一个结构体来统一保存，并在<code>Proto</code>成功解析完成后清除。我们取名为<code>FuncState</code>。</p>
<p>&emsp;&emsp;所以这里我们主要关心的是，在词法解析过程中需要哪些中间变量来存储状态呢？</p>
<p>&emsp;&emsp; 首先肯定需要一个Proto，作为最终存储的函数内容，然后就是Proto对应的一些记录</p>
<ul>
<li>函数中的常量（如数字、字符串和其他不可变值），需要集中存储，当然也就是一个Table</li>
<li>常数、内部嵌套Proto以及局部变量的数量当然也要记录</li>
<li>上值的记录：关于Proto的上值我们需要记录其属于常量还是属于变量，以及对应的索引，所以单独建立一个数据结构<code>upvaldesc</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FuncState</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Proto* p;</span><br><span class="line">    Table* h;</span><br><span class="line">    <span class="keyword">int</span> nk;</span><br><span class="line">    <span class="keyword">int</span> np;</span><br><span class="line">    <span class="keyword">int</span> nlocvars;</span><br><span class="line">    upvaldesc upvalues[LUAI_MAXUPVALUES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">upvaldesc</span> &#123;</span></span><br><span class="line">  lu_byte k;         <span class="comment">//类型判断</span></span><br><span class="line">  lu_byte info;      <span class="comment">//索引</span></span><br><span class="line">&#125; upvaldesc;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp; 然后需要考虑翻译为字节码的过程中，需要记录的东西</p>
<ul>
<li>首先当然要记录当前所在的解析位置<code>pc</code>以及上一步解析的位置<code>lasttarget</code></li>
<li>目前空闲的寄存器<code>freereg</code>也要记录，便于生成字节码的时候使用</li>
<li>解析的过程中有着众多的代码块，需要详细记录，因此单独新建结构体Block<ul>
<li>Block以链表<code>bl</code>形式记录保存的多个代码块</li>
<li>Block内部至少需要保存跳转点信息、以及局部变量/上值相关的标记</li>
<li><code>Funcstate</code>记录当前所处代码块使用的局部变量数<code>nactvars</code></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FuncState</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Proto* p;</span><br><span class="line">    Table* h;</span><br><span class="line">    <span class="keyword">int</span> nk;</span><br><span class="line">    <span class="keyword">int</span> np;</span><br><span class="line">    <span class="keyword">int</span> nlocvars;</span><br><span class="line">    upvaldesc upvalues[LUAI_MAXUPVALUES];    </span><br><span class="line">    <span class="keyword">int</span> pc;</span><br><span class="line">    <span class="keyword">int</span> lasttarget;</span><br><span class="line">    <span class="keyword">int</span> freereg;</span><br><span class="line">    Block* bl;</span><br><span class="line">    short nactvars;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block</span> *<span class="title">previous</span>;</span>  <span class="comment">/* chain */</span></span><br><span class="line">    <span class="keyword">int</span> breaklist;  <span class="comment">/* list of jumps out of this loop */</span></span><br><span class="line">    lu_byte nactvar;  <span class="comment">/* # active locals outside the breakable structure */</span></span><br><span class="line">    lu_byte upval;  <span class="comment">/* true if some variable in the block is an upvalue */</span></span><br><span class="line">    lu_byte isbreakable;  <span class="comment">/* true if `block' is a loop */</span>   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;回头再来看Token。所有的词，都可以解释为一个类型及其对应的数据，即如下形式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Token</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nType;</span><br><span class="line">    <span class="keyword">void</span>* data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;根据前文中已经封装的数据类型，这里的data我们可以替换为一个联合，即要么是数字，要么是字符串。这样简单的结构体就足够表达所有可能读到的词了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> SematicInfo</span><br><span class="line">&#123;</span><br><span class="line">    lua_Number r;</span><br><span class="line">    TString *ts;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Toke</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nType;</span><br><span class="line">    SematicInfo data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;至此，我们基本上有了词法解析需要的一些数据结构，下面需要做的事是确定词法解析的逻辑流程。</p>
<h2 id="三-解析逻辑"><a href="#三-解析逻辑" class="headerlink" title="三. 解析逻辑"></a>三. 解析逻辑</h2><p>&emsp;&emsp;词法解析最重要的就是将整个脚本解析成一个一个的token，所以最重要的函数就是解析分割token的函数，我们称之为<code>next()</code>。加载并解析一个脚本文件的整体流程应该包括：</p>
<ul>
<li>初始化解析结构体<code>LexState</code></li>
<li>初始化函数结构体<code>FuncState</code></li>
<li>调用next()解析第一个token</li>
<li>重复分析token-&gt;取下一个token，直至文件结束</li>
<li>返回Proto并新建Closure存储</li>
</ul>
<p>初始化操作较为简单，挨个赋值即可，核心在于<code>next()</code>如何解析。毫无疑问，这里需要读取字符串，以一定的规则（空格、换号、特定符号）作为分割，然后对字符串通过switch来进行不同的处理，大致可以包括如下几类</p>
<ul>
<li>预定的符号</li>
<li>数字</li>
<li>字符串</li>
</ul>
<p>预定的符号需要包括</p>
<ul>
<li>文本格式相关，如空格、换行、文件结束符等</li>
<li>标记符，如注释、字符串、下划线等</li>
<li>操作符，如表的操作符<code>. [ ]:</code>、数字的加减乘除、字符串连接等</li>
</ul>
<p>除了符号之外的，数字直接读取多位直至操作符结束，字符串同理。当读取完成且没有问题，则返回此次读取的token类型，并保存<code>seminfo</code>。完成了token的读取后，就需要进入下一阶段：对token的解析分析。</p>
<p>这里涉及到一个概念：代码块。一个函数当然是一个代码块，函数中多级调用可以视为多级代码块，而一个脚本本身，也可以是做一个代码块，所以脚本本身定义的函数、变量，相当于是在一个大的隐藏函数内部进行的定义。因此对各种代码块，均可以用统一封装函数解析，我们取名<code>chunk()</code>。</p>
<p><code>chunk()</code>的主要逻辑应该是在一个代码块中，不停的读取token，并且解析当前token，根据token类型选择不同的处理方式，该处理逻辑取名为<code>statement()</code>，大致逻辑如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">chunk</span> <span class="params">(LexState *ls)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* chunk -&gt; &#123; stat [`;'] &#125; */</span></span><br><span class="line">  <span class="keyword">int</span> islast = <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">while</span> (!islast &amp;&amp; !block_follow(ls-&gt;t.token)) &#123;</span><br><span class="line">    islast = statement(ls);</span><br><span class="line">    testnext(ls, <span class="string">';'</span>);</span><br><span class="line">...</span><br><span class="line">    ls-&gt;fs-&gt;freereg = ls-&gt;fs-&gt;nactvar;  <span class="comment">/* free registers */</span></span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面需要考虑的就是如何去根据token的类型进行相应的处理。</p>
<p>首先我们要对token进行一个分类：</p>
<ul>
<li>逻辑控制，如条件、循环等</li>
<li>声明，如函数、局部变量等</li>
<li>跳转，如返回、打断等</li>
<li>default，包括如<code>TK_NAME</code>等的表达式、上值等的判断处理。</li>
</ul>
<p>说到这里，不得不说一下<code>lua</code>采用的语法规则范式：EBNF范式（扩展巴科斯范式）。其中<code>::=</code>表示定义，左边的符号可以被右边的符号所替换。<code>|</code>符号表示或的意思，也就是说左边的符号，可以通过<code>|</code>符号左边或者右边的符号来代替。被“<code>”</code>包起来的字符，就是我们实际会显示的字符。被<code>{}</code>包起来的，表示它可以重复0次或者多次。包含在[]内的内容，表示可以被省略或者只出现一次。</p>
<p>下面所列的就是<code>lua</code>的全部规则内范式，在<code>token</code>的解读时，就需要依据这些范式来检查是否符合要求。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">chunk ::= &#123;stat [`;´]&#125; [laststat[`;´]]</span><br><span class="line"></span><br><span class="line">block ::= chunk</span><br><span class="line"></span><br><span class="line">stat ::=  varlist1 `=´ explist1  |</span><br><span class="line">         functioncall  |</span><br><span class="line">         <span class="keyword">do</span> block <span class="built_in">end</span>  |</span><br><span class="line">         <span class="keyword">while</span> <span class="built_in">exp</span> <span class="keyword">do</span> block <span class="built_in">end</span>  |</span><br><span class="line">         repeat block until <span class="built_in">exp</span>  |</span><br><span class="line">         <span class="keyword">if</span> <span class="built_in">exp</span> then block &#123;elseif <span class="built_in">exp</span> then block&#125; [<span class="keyword">else</span> block] <span class="built_in">end</span>  |</span><br><span class="line">         <span class="keyword">for</span> Name `=´ <span class="built_in">exp</span> `,´ <span class="built_in">exp</span> [`,´ <span class="built_in">exp</span>] <span class="keyword">do</span> block <span class="built_in">end</span>  |</span><br><span class="line">         <span class="keyword">for</span> namelist in explist1 <span class="keyword">do</span> block <span class="built_in">end</span>  |</span><br><span class="line">         function funcname funcbody  |</span><br><span class="line">         local function Name funcbody  |</span><br><span class="line">         local namelist [`=´ explist1]</span><br><span class="line"></span><br><span class="line">laststat ::= <span class="keyword">return</span> [explist1]  |  <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">funcname ::= Name &#123;`.´ Name&#125; [`:´ Name]</span><br><span class="line"></span><br><span class="line">varlist1 ::= var &#123;`,´ var&#125;</span><br><span class="line"></span><br><span class="line">var ::=  Name  |  prefixexp `[´ <span class="built_in">exp</span> `]´  |  prefixexp `.´ Name</span><br><span class="line"></span><br><span class="line">namelist ::= Name &#123;`,´ Name&#125;</span><br><span class="line"></span><br><span class="line">explist1 ::= &#123;<span class="built_in">exp</span> `,´&#125; <span class="built_in">exp</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exp</span> ::=  nil  |  <span class="literal">false</span>  |  <span class="literal">true</span>  |  Number  |  <span class="keyword">String</span>  |  `...´  |</span><br><span class="line">         function  |  prefixexp  |  tableconstructor  |  <span class="built_in">exp</span> binop <span class="built_in">exp</span>  |  unop <span class="built_in">exp</span></span><br><span class="line"></span><br><span class="line">prefixexp ::= var  |  functioncall  |  `(´ <span class="built_in">exp</span> `)´</span><br><span class="line"></span><br><span class="line">functioncall ::=  prefixexp args  |  prefixexp `:´ Name args</span><br><span class="line"></span><br><span class="line">args ::=  `(´ [explist1] `)´  |  tableconstructor  |  <span class="keyword">String</span></span><br><span class="line"></span><br><span class="line">function ::= function funcbody</span><br><span class="line"></span><br><span class="line">funcbody ::= `(´ [parlist1] `)´ block <span class="built_in">end</span></span><br><span class="line"></span><br><span class="line">parlist1 ::= namelist [`,´ `...´]  |  `...´</span><br><span class="line"></span><br><span class="line">tableconstructor ::= `&#123;´ [fieldlist] `&#125;´</span><br><span class="line"></span><br><span class="line">fieldlist ::= field &#123;fieldsep field&#125; [fieldsep]</span><br><span class="line"></span><br><span class="line">field ::= `[´ <span class="built_in">exp</span> `]´ `=´ <span class="built_in">exp</span>  |  Name `=´ <span class="built_in">exp</span>  |  <span class="built_in">exp</span></span><br><span class="line"></span><br><span class="line">fieldsep ::= `,´  |  `;´</span><br><span class="line"></span><br><span class="line">binop ::= `+´  |  `-´  |  `*´  |  `/´  |  `^´  |  `%´  |  `..´  |</span><br><span class="line">         `&lt;´  |  `&lt;=´  |  `&gt;´  |  `&gt;=´  |  `==´  |  `~=´  |</span><br><span class="line">         <span class="keyword">and</span>  |  <span class="keyword">or</span></span><br><span class="line"></span><br><span class="line">unop ::= `-´  |  <span class="keyword">not</span>  |  `#´</span><br></pre></td></tr></table></figure>

<p>以<code>if</code>语句为例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">exp</span> then block &#123;elseif <span class="built_in">exp</span> then block&#125; [<span class="keyword">else</span> block] <span class="built_in">end</span></span><br></pre></td></tr></table></figure>

<p>这里表明<code>if</code>后接表达式，然后<code>then</code>关键词，后续接一个<code>block</code>，至于是否有<code>elseif/else</code>都可以，最后以<code>end</code>收尾。</p>
<p><code>statement()</code>中，对应<code>token</code>为<code>if</code>时，处理函数<code>ifstat()</code>逻辑主要也就根据这个范式解析来判断，大致的伪代码如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ifstat</span><span class="params">(LexState *ls, <span class="keyword">int</span> <span class="built_in">line</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    check_if();</span><br><span class="line">    check_elseif();</span><br><span class="line">    check_else();</span><br><span class="line">    check_end_match();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们分别讨论每部分的逻辑实现。</p>
<p>首先是第一个<code>if then</code>分支的检测。<code>if</code>和<code>then</code>均为关键词，相对简单，这里我们先看看表达式<code>exp</code>该如何处理。常见的表达式一般是<code>a==b</code>或者<code>!a</code>之类的一个判断，也可能是更为复杂的比如函数，所以需要做比较精细的处理。</p>
<p>首先，我们需要一个结构体<code>expdesc</code>来存储表达式的信息以及枚举类型<code>expkind</code>来表示表达式的各种不同类型。</p>
<p><code>expdesc</code>定义如下，主要包括</p>
<ul>
<li>类型<code>expkind</code></li>
<li>表达式的值：因为表达式有很多种，因此值其实也有很多种不同的存储<ul>
<li>简单的数值直接用<code>lua_Number(double)</code>即可</li>
<li>属于上值、寄存器里、栈上的值，则需要存其索引。使用一个info可以满足部分需要，但是仍然需要多一个aux来存储如table的中的值。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">expdesc</span> &#123;</span></span><br><span class="line">  expkind k;</span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">int</span> info, aux; &#125; s;</span><br><span class="line">    lua_Number nval;</span><br><span class="line">  &#125; u;</span><br><span class="line">  <span class="keyword">int</span> t;  <span class="comment">/* patch list of `exit when true' */</span></span><br><span class="line">  <span class="keyword">int</span> f;  <span class="comment">/* patch list of `exit when false' */</span></span><br><span class="line">&#125; expdesc;</span><br></pre></td></tr></table></figure>

<p><code>expkind</code>类型定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  VVOID,	<span class="comment">/* no value */</span> <span class="comment">// 表达式是空的，也就是void</span></span><br><span class="line">  VNIL,     <span class="comment">//表达式是nil类型</span></span><br><span class="line">  VTRUE,    <span class="comment">//表达式是TRUE</span></span><br><span class="line">  VFALSE,   <span class="comment">//表达式是FALSE</span></span><br><span class="line">  VK,		<span class="comment">/* info = index of constant in `k' */</span> <span class="comment">// 表达式是常量类型，expdesc的info字段表示这个常量是常量表k中的哪个值</span></span><br><span class="line">  VKNUM,	<span class="comment">/* nval = numerical value */</span> <span class="comment">//表达式为数字</span></span><br><span class="line">  VLOCAL,	<span class="comment">/* info = local register */</span>  <span class="comment">//表达式为local变量，expdesc的info字段表示该local变量在栈中的位置</span></span><br><span class="line">  VUPVAL,       <span class="comment">/* info = index of upvalue in `upvalues' */</span> <span class="comment">//表达式是Upvalue，expdesc的info字段表示Upvalue数组的索引</span></span><br><span class="line">  VGLOBAL,	<span class="comment">/* info = index of table; aux = index of global name in `k' */</span> <span class="comment">//表达式的值为全局变量</span></span><br><span class="line">  VINDEXED,	<span class="comment">/* info = table register; aux = index register (or `k') */</span> <span class="comment">//索引类型，当exp是这种类型时，expdesc的ind域被使用</span></span><br><span class="line">  VJMP,		<span class="comment">/* info = instruction pc */</span>  <span class="comment">//表达式为跳转指令</span></span><br><span class="line">  VRELOCABLE,	<span class="comment">/* info = instruction pc */</span> <span class="comment">//表达式可以把结果放到任意的寄存器上，expdesc的info表示的是instruction pc</span></span><br><span class="line">  VNONRELOC,	<span class="comment">/* info = result register */</span> <span class="comment">//表达式已经在某个寄存器上了，expdesc的info字段，表示该寄存器的位置</span></span><br><span class="line">  VCALL,	<span class="comment">/* info = instruction pc */</span> <span class="comment">// 表达式是函数调用，expdesc中的info字段，表示的是instruction pc, 也就是它指向Proto code列表的哪个指令</span></span><br><span class="line">  VVARARG	<span class="comment">/* info = instruction pc */</span></span><br><span class="line">&#125; expkind;</span><br></pre></td></tr></table></figure>

<p>然后我们来梳理一下一个简单的逻辑应该如何去分析确定。</p>
<p>假设一个简单的脚本里有如下语句</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a &lt; b <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"b large"</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"a large"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>对应的解析则是<code>luaX_next()</code>读取首个<code>token</code>，然后<code>chunk()</code>中循环执行<code>statement()</code>逻辑，根据读到的<code>token</code>调用对应的函数</p>
<ul>
<li>首先<code>luaX_next()</code>读到“a”，对应<code>TK_NAME</code>，走<code>statement()</code>的<code>default</code>分支，调用<code>exprstat()</code>，该函数专门处理各种非关键字的表达式解析<ul>
<li>调用<code>primaryexp()</code>进行<code>default</code>分支表达式的检测<ul>
<li>调用<code>prefixexp()</code>，该函数针对当前<code>token</code>类型为<code>NAME</code>或者括号进行检测，对于<code>NAME</code>，进一步调用<code>singlevar()</code><ul>
<li>调用<code>singlevar()</code>检查<code>Name</code>的类型<ul>
<li>调用<code>str_checkname()</code>，确认是<code>TK_NAME</code>后，调用<code>luaX_next()</code>读取下个<code>token</code></li>
<li>调用<code>singlevaraux()</code>判断<code>NAME</code>的类型属于哪一类，包括<code>GLOBAL/UPVAL/LOCAL</code><ul>
<li>如果当前函数层级为NULL，则说明是最外层了，即脚本本身，那么该<code>NAME</code>一定是<code>VGLOBAL</code>，调用<code>init_exp()</code>初始化<code>VGLOBAL</code>并返回</li>
<li>函数层级不为NULL，则调用<code>searchvar()</code>查看当前层级是否已有该<code>NAME</code>，有的话则返回对应位置，找不到返回-1<ul>
<li>找到了则调用<code>Init_exp()</code>初始化该表达式为<code>VLOCAL</code>类型，对于<code>local</code>还需要调用<code>markupval()</code>进行<code>gc object</code>的记录，然后返回<code>VLOCAL</code></li>
<li>找不到，则递归调用<code>singlevaraux()</code>，查看上级，即<code>fs-&gt;prev</code>的情况。<ul>
<li>递归多级后如果返回的是<code>VGLOBAL</code>，则照葫芦画瓢返回<code>VGLOBAL</code>即可</li>
<li>如果是某一级别的<code>VLOCAL</code>，那么该级别则为<code>VUPVAL</code>，这里就需要做一些操作了。<ul>
<li>首先调用<code>indexupvalue()</code>取出信息赋值给表达式的info字段</li>
<li>k字段赋值<code>VUPVAL</code></li>
<li>返回<code>VUPVALL</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>对于<code>VGLOBAL</code>，则调用<code>luaK_stringK()</code>将其添加到对应的proto的变量列表中</li>
</ul>
</li>
</ul>
</li>
<li>完成<code>prefixexp()</code>的调用后，进入后面是否有<code>.[:(</code>等衔接符的检测，此处没有则直接跳过</li>
</ul>
</li>
<li>如果<code>primaryexp()</code>的结果表示表达式类型是<code>VCALL</code>，则调用<code>getcode()</code>，否则调用<code>assignment()</code><ul>
<li><code>assignment()</code>主要处理<code>NAME</code>后的<code>token</code>，按照语法规定，这里<strong>只允许是<code>&quot;,&quot;</code>或者<code>&quot;=&quot;</code></strong>，别的则抛出异常<ul>
<li>对于”,”，则嵌套调用<code>primaryexp() + assignment()</code>进行递归处理</li>
<li>对于”=“，说明<code>NAME</code>走到了赋值了<ul>
<li>首先当然是调用<code>checknext()</code>检查是不是”=“，不是则报错</li>
<li>然后调用<code>explist1()</code>检测表达式另一边有几个赋值的值，因为Lua允许多赋值<ul>
<li>首先调用<code>expr()</code>，实际调用<code>subexpr()</code>函数，对操作符进行判断及处理<ul>
<li>调用<code>getunopr()</code>获取当前操作符的类型</li>
<li>如果不是<code>NOUNOPR</code>，则需要继续读取后续的进行判断，否则调用<code>syimpleexp()</code><ul>
<li><code>simpleexp()</code>会检查<code>token</code>类型并进行相应的<code>expdesc</code>赋值，对<code>TK_NUMBER</code>则调用<code>init_exp()</code>初始化为<code>VKNUM</code>，然后调用<code>luaX_next()</code>读取后续<code>token</code></li>
</ul>
</li>
<li>调用<code>getbinnopr()</code>获取二元操作符并判断后续操作，对于等号这里直接跳转走</li>
</ul>
</li>
<li>然后循环调用<code>testnext()</code>检测”,“，检测到了则调用<code>luaK_exp2nextreg()</code>和<code>expr()</code><ul>
<li><code>luaK_exp2netreg()</code></li>
<li><code>expr()</code></li>
</ul>
</li>
</ul>
</li>
<li>检查完赋值语句后，判断是否有多出来的值，有的话则需要进行调整，否则调用<code>luaK_setoneret()</code>和<code>luaK_storevar</code>设置表达式的返回并结束该语句<ul>
<li>首先调用<code>luaK_setoneret()</code>，对表达式为VCALL或者VVARARG进行赋值，此处我们是VNUM所以并无操作</li>
<li>然后调用<code>luaK_storevar()</code>，对于VGLOBAL，处理如下<ul>
<li>调用<code>luaK_exp2anyreg()</code><ul>
<li>调用<code>luaK_dischargevars()</code>，区分<code>expkind</code>，调用<code>luaK_codeABx()</code>或者<code>luaK_codeABC()</code>赋值<code>OpCode</code>。<ul>
<li><code>luaK_codeABx</code>和<code>luaK_codeABC</code>区别在于机器码对应的寄存器数量不同，实际最后均调用<code>luaK_code</code></li>
</ul>
</li>
<li>调用<code>luaK_exp2nextreg()</code></li>
</ul>
</li>
<li>调用<code>luaK_codeABx()</code>赋值<code>OP_SETGLOBAL</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>SETARG_C(getcode())</code>针对<code>=</code>号后为函数，赋值对应的函数地址值。</li>
<li>最后调用<code>Init_exp()</code></li>
</ul>
</li>
</ul>
</li>
<li></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>
      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创，坚持分享，谢谢鼓励和支持</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="Ty Chen 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="Ty Chen 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Ty Chen
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://ty-chen.github.io/lua-lexer/" title="Lua源码剖析（六）词法分析">https://ty-chen.github.io/lua-lexer/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Lua/" rel="tag"># Lua</a>
          
            <a href="/tags/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/" rel="tag"># 脚本语言</a>
          
            <a href="/tags/%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90/" rel="tag"># 语法解析</a>
          
            <a href="/tags/%E8%AF%8D%E6%B3%95%E8%A7%A3%E6%9E%90/" rel="tag"># 词法解析</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/lua-vm-md/" rel="next" title="Lua源码剖析（五）虚拟机">
                <i class="fa fa-chevron-left"></i> Lua源码剖析（五）虚拟机
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/ptp/" rel="prev" title="ptp协议分析">
                ptp协议分析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        
  <div class="bdsharebuttonbox">
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
    <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
    <a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a>
    <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
    <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a class="bds_count" data-cmd="count"></a>
  </div>
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "2",
        "bdMiniList": false,
        "bdPic": ""
      },
      "share": {
        "bdSize": "16",
        "bdStyle": "0"
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/me.JPG"
                alt="Ty Chen" />
            
              <p class="site-author-name" itemprop="name">Ty Chen</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">53</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">86</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Ty-Chen" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:tianyuch@hotmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Friends
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://lishouxian.cn/" title="Stanleylsx" target="_blank">Stanleylsx</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一-简介"><span class="nav-text">一. 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二-基础结构体"><span class="nav-text">二. 基础结构体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三-解析逻辑"><span class="nav-text">三. 解析逻辑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文献"><span class="nav-text">参考文献</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2020 &mdash; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ty Chen</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">210.1k</span>
  
  <a href="http://www.beian.miit.gov.cn/" target="_blank" rel="noopener">粤ICP备20071543号</a> 
</div>









        
<div class="busuanzi-count">
	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>

  
    <span class="site-uv">
      你是来访的第
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      位同学
    </span>
  

  
    <span class="site-pv">
      访问次数：
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'aTqo2eFkO2Bn0AGX008uKDV7-gzGzoHsz',
        appKey: 'uJ6nxqW7RHWpAILCtttkJfJu',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
