<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/kulamati128.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/kulamati32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/kulamati16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Linux,操作系统,中断," />










<meta name="description" content="一. 前言&amp;emsp;&amp;emsp;在前面的文章里，我们多次见到了中断的作用，如任务调度，系统调用从用户态陷入内核，文件系统的读写操作等。本文就Linux的中断机制进行较为全面的剖析。">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux操作系统学习笔记（十五）中断">
<meta property="og:url" content="https://ty-chen.github.io/linux-kernel-interrupt/index.html">
<meta property="og:site_name" content="Ty-Chen&#39;s Home">
<meta property="og:description" content="一. 前言&amp;emsp;&amp;emsp;在前面的文章里，我们多次见到了中断的作用，如任务调度，系统调用从用户态陷入内核，文件系统的读写操作等。本文就Linux的中断机制进行较为全面的剖析。">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/dd/13/dd492efdcf956cb22ce3d51592cdc113.png">
<meta property="article:published_time" content="2020-07-05T11:28:06.000Z">
<meta property="article:modified_time" content="2020-12-16T14:58:24.336Z">
<meta property="article:author" content="Ty Chen">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="中断">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://static001.geekbang.org/resource/image/dd/13/dd492efdcf956cb22ce3d51592cdc113.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://ty-chen.github.io/linux-kernel-interrupt/"/>





  <title>Linux操作系统学习笔记（十五）中断 | Ty-Chen's Home</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ty-Chen's Home</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Collecting, sharing and creating knowledge</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ty-chen.github.io/linux-kernel-interrupt/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ty Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty-Chen's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Linux操作系统学习笔记（十五）中断</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-05T19:28:06+08:00">
                2020-07-05
              </time>
            

            

            
          </span>
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2020-12-16T22:58:24+08:00" content="2020-12-16">
                2020-12-16
              </time>
            </span>
          
          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index">
                    <span itemprop="name">Linux操作系统内核学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/linux-kernel-interrupt/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/linux-kernel-interrupt/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv">访问次数：
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  16
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h2><p>&emsp;&emsp;在前面的文章里，我们多次见到了中断的作用，如任务调度，系统调用从用户态陷入内核，文件系统的读写操作等。本文就Linux的中断机制进行较为全面的剖析。</p>
<a id="more"></a>

<h2 id="二-什么是中断"><a href="#二-什么是中断" class="headerlink" title="二. 什么是中断"></a>二. 什么是中断</h2><p>&emsp;&emsp;中断通常被定义为改变处理器执行指令的顺序的一个事件，该事件与CPU芯片内外部硬件电路产生的电信号相对应。中断通常分为同步中断和异步中断：</p>
<ul>
<li>同步中断(synchronous)：又称异常（exception），在指令执行时由CPU控制单元产生，之所以称之为同步，是因为只有在一条指令终止执行后CPU才会发出中断。异常通常又可以分为错误（Faults）、陷阱（Traps）和中止（Aborts）。</li>
<li>异步中断(asynchronous)：即通常所说的中断（interrupt)，由其他硬件设备依照CPU时钟信号随机产生。</li>
</ul>
<p>&emsp;&emsp;从另一个角度来说，我们可以把中断分为外部或者硬件引起的中断以及软件引起的中断两种。外部中断，由 <code>Local APIC</code> 或者与 <code>Local APIC</code> 连接的处理器针脚接收。第二种类型 - 软件引起的中断，由处理器自身的特殊情况引起(有时使用特殊架构的指令)。一个常见的关于特殊情况的例子就是 除零，另一个例子就是使用 系统调用（<code>syscall</code>）。假设每一个物理硬件都有一根中断线，设备可以通过它对 CPU 发起中断信号，中断信号先通过一个控制器，然后发到CPU上执行。比较原始的设备中，中断信号发送给 <a href="http://en.wikipedia.org/wiki/Programmable_Interrupt_Controller" target="_blank" rel="noopener">PIC</a> ，它是一个顺序处理各种设备的各种中断请求的芯片。而现在通用的则是<a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller" target="_blank" rel="noopener">高级程序中断控制器（Advanced Programmable Interrupt Controller）</a>做这件事情，即我们熟知的 <code>APIC</code>。一个 APIC 包括两个独立的设备：</p>
<ul>
<li><code>Local APIC</code></li>
<li><code>I/O APIC</code></li>
</ul>
<p>第一个设备 - <code>Local APIC</code>存在于每个CPU核心中，<code>Local APIC</code> 负责处理特定于 CPU 的中断配置，常被用于管理来自 APIC 时钟（APIC-timer）、热敏元件和其他与 I/O 设备连接的设备的中断。</p>
<p>第二个设备 - <code>I/O APIC</code> 提供了多核处理器的中断管理。它被用来在所有的 CPU 核心中分发外部中断。</p>
<p>一个中断的发生流程如下：</p>
<ul>
<li>外部设备给中断控制器发送物理中断信号</li>
<li>中断控制器将物理中断信号转换成为中断向量 <code>interrupt vector</code>，发给各个 CPU</li>
<li>每个 CPU 都会有一个中断向量表，根据 <code>interrupt vector</code> 调用一个 IRQ 处理函数</li>
<li>IRQ 处理函数中，将 <code>interrupt vector</code> 转化为抽象中断层的中断信号 <code>irq</code>，调用中断信号 <code>irq</code> 对应的中断描述结构（IDT）里面的 <code>irq_handler_t</code></li>
</ul>
<img src="https://static001.geekbang.org/resource/image/dd/13/dd492efdcf956cb22ce3d51592cdc113.png" alt="img" style="zoom:25%;" />

<h2 id="三-软中断的必要性"><a href="#三-软中断的必要性" class="headerlink" title="三. 软中断的必要性"></a>三. 软中断的必要性</h2><p>&emsp;&emsp;上面我们分析了硬中断、软中断的概念以及中断的流程，但是为什么我们需要设计软中断呢？中断其实是一种异步的事件处理机制，可以提高系统的并发处理能力。由于中断处理程序会打断其他进程的运行，所以，<strong>为了减少对正常进程运行调度的影响，中断处理程序就需要尽可能快地运行</strong>。如果中断本身要做的事情不多，那么处理起来也不会有太大问题；但如果中断要处理的事情很多，中断服务程序就有可能要运行很长时间。特别是，中断处理程序在响应中断时，还会临时关闭中断。这就会导致上一次中断处理完成之前，其他中断都不能响应，也就是说<strong>中断有可能会丢失</strong>。</p>
<p>&emsp;&emsp;为了解决中断处理程序执行过长和中断丢失的问题，Linux 将中断处理过程分成了两个阶段，也就是上半部和下半部：上半部用来快速处理中断，它在中断禁止模式下运行，主要处理跟硬件紧密相关的或时间敏感的工作。下半部用来延迟处理上半部未完成的工作，通常以内核线程的方式运行。这也就是我们熟悉的硬中断和软中断了。</p>
<p>&emsp;&emsp;以网卡收包为例，网卡接收到数据包后，会通过硬件中断的方式，通知内核有新的数据到了。这时，内核就应该调用中断处理程序来响应它。对上半部来说，既然是快速处理，其实就是要把网卡的数据读到内存中，然后更新一下硬件寄存器的状态（表示数据已经读好了），最后再发送一个软中断信号，通知下半部做进一步的处理。而下半部被软中断信号唤醒后，需要从内存中找到网络数据，再按照网络协议栈，对数据进行逐层解析和处理，直到把它送给应用程序。</p>
<p>&emsp;&emsp;实际上，上半部会打断 CPU 正在执行的任务，然后立即执行中断处理程序。而下半部以内核线程的方式执行，并且每个 CPU 都对应一个软中断内核线程，名字为 <code>“ksoftirqd/CPU 编号”</code>，比如说， 0 号 CPU 对应的软中断内核线程的名字就是 <code>ksoftirqd/0</code>。不过要注意的是，软中断不只包括了刚刚所讲的硬件设备中断处理程序的下半部，一些内核自定义的事件也属于软中断，比如内核调度和 RCU 锁（Read-Copy Update 的缩写，RCU 是 Linux 内核中最常用的锁之一）等。</p>
<h2 id="四-中断结构体"><a href="#四-中断结构体" class="headerlink" title="四. 中断结构体"></a>四. 中断结构体</h2><p>&emsp;&emsp;对于每一个中断，我们都有一个对应的描述结构体<code>irq_desc</code>，其中包括了众多描述该中断特点的成员变量，这里尤其需要强调描述该中断对应的全部动作的变量<code>struct irqaction *action</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irq_common_data</span>	<span class="title">irq_common_data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span>		<span class="title">irq_data</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> __percpu	*kstat_irqs;</span><br><span class="line">    <span class="keyword">irq_flow_handler_t</span>	handle_irq;</span><br><span class="line">......</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>	*<span class="title">action</span>;</span>	<span class="comment">/* IRQ action list */</span></span><br><span class="line">......</span><br><span class="line">    <span class="keyword">int</span>			parent_irq;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span>		*<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;每一个中断处理动作的结构 <code>struct irqaction</code>，都有以下成员：</p>
<ul>
<li>中断处理函数 <code>handler</code></li>
<li>设备 id<code>void *dev_id</code> </li>
<li>中断信号<code>irq</code></li>
<li>如果中断处理函数在单独的线程运行，则有 <code>thread_fn</code> 是线程的执行函数，<code>thread</code> 是线程的 <code>task_struct</code>。</li>
</ul>
<p>&emsp;&emsp;一连串的动作通过链表的形式组合起来构成了该中断的所有动作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct irqaction - per interrupt action descriptor</span></span><br><span class="line"><span class="comment"> * @handler:	interrupt handler function</span></span><br><span class="line"><span class="comment"> * @name:	name of the device</span></span><br><span class="line"><span class="comment"> * @dev_id:	cookie to identify the device</span></span><br><span class="line"><span class="comment"> * @percpu_dev_id:	cookie to identify the device</span></span><br><span class="line"><span class="comment"> * @next:	pointer to the next irqaction for shared interrupts</span></span><br><span class="line"><span class="comment"> * @irq:	interrupt number</span></span><br><span class="line"><span class="comment"> * @flags:	flags (see IRQF_* above)</span></span><br><span class="line"><span class="comment"> * @thread_fn:	interrupt handler function for threaded interrupts</span></span><br><span class="line"><span class="comment"> * @thread:	thread pointer for threaded interrupts</span></span><br><span class="line"><span class="comment"> * @secondary:	pointer to secondary irqaction (force threading)</span></span><br><span class="line"><span class="comment"> * @thread_flags:	flags related to @thread</span></span><br><span class="line"><span class="comment"> * @thread_mask:	bitmask for keeping track of @thread activity</span></span><br><span class="line"><span class="comment"> * @dir:	pointer to the proc/irq/NN/name entry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> &#123;</span></span><br><span class="line">    <span class="keyword">irq_handler_t</span>		handler;</span><br><span class="line">    <span class="keyword">void</span>			*dev_id;</span><br><span class="line">    <span class="keyword">void</span> __percpu		*percpu_dev_id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>	*<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">irq_handler_t</span>		thread_fn;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">thread</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>	*<span class="title">secondary</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>		irq;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>		flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>		thread_flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>		thread_mask;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span>	*<span class="title">dir</span>;</span></span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;众多的中断<code>irq_desc</code>则采取类似于内存管理中所用到的基数树radix tree的方式进行管理。这种结构对于从某个整型 key 找到 value 速度很快，中断信号 <code>irq</code> 是这个整数。通过它，我们很快就能定位到对应的 <code>irq_desc</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SPARSE_IRQ</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">RADIX_TREE</span><span class="params">(irq_desc_tree, GFP_KERNEL)</span></span>;</span><br><span class="line"><span class="function">struct irq_desc *<span class="title">irq_to_desc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> radix_tree_lookup(&amp;irq_desc_tree, irq);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* !CONFIG_SPARSE_IRQ */</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> <span class="title">irq_desc</span>[<span class="title">NR_IRQS</span>] __<span class="title">cacheline_aligned_in_smp</span> = &#123;</span></span><br><span class="line">    [<span class="number">0</span> ... NR_IRQS<span class="number">-1</span>] = &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct irq_desc *<span class="title">irq_to_desc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (irq &lt; NR_IRQS) ? irq_desc + irq : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !CONFIG_SPARSE_IRQ */</span></span></span><br></pre></td></tr></table></figure>

<h2 id="五-中断流程"><a href="#五-中断流程" class="headerlink" title="五. 中断流程"></a>五. 中断流程</h2><p>&emsp;&emsp;我们从 CPU 收到中断向量开始分析.CPU收到的中断向量定义于<a href="https://code.woboq.org/linux/linux/arch/x86/include/asm/irq_vectors.h.html" target="_blank" rel="noopener"><code>irq_vectors.h</code></a>。下面这一段是该头文件的注释，详细描述了IRQ向量的基本信息：</p>
<ul>
<li>单个CPU拥有256（8位）IDT，即能处理256个中断，定义为<code>NR_VECTORS</code></li>
<li>CPU处理的中断分为几类<ul>
<li>0到31位为系统陷入或者异常，这些属于无法屏蔽的中断，必须进行处理</li>
<li>32到127位为设备中断</li>
<li>128位即我们常说的int80系统调用中断</li>
<li>129至<code>INVALIDATE_TLB_VECTOR_START</code>也用来保存设备中断</li>
<li><code>INVALIDATE_TLB_VECTOR_START</code>至255作为特殊中断</li>
</ul>
</li>
<li>64位架构下每个CPU有独立的IDT表，而32位则共享一张表</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Linux IRQ vector layout.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * There are 256 IDT entries (per CPU - each entry is 8 bytes) which can</span></span><br><span class="line"><span class="comment"> * be defined by Linux. They are used as a jump table by the CPU when a</span></span><br><span class="line"><span class="comment"> * given vector is triggered - by a CPU-external, CPU-internal or</span></span><br><span class="line"><span class="comment"> * software-triggered event.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Linux sets the kernel code address each entry jumps to early during</span></span><br><span class="line"><span class="comment"> * bootup, and never changes them. This is the general layout of the</span></span><br><span class="line"><span class="comment"> * IDT entries:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Vectors   0 ...  31 : system traps and exceptions - hardcoded events</span></span><br><span class="line"><span class="comment"> *  Vectors  32 ... 127 : device interrupts</span></span><br><span class="line"><span class="comment"> *  Vector  128         : legacy int80 syscall interface</span></span><br><span class="line"><span class="comment"> *  Vectors 129 ... INVALIDATE_TLB_VECTOR_START-1 except 204 : device interrupts</span></span><br><span class="line"><span class="comment"> *  Vectors INVALIDATE_TLB_VECTOR_START ... 255 : special interrupts</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 64-bit x86 has per CPU IDT tables, 32-bit has one shared IDT table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This file enumerates the exact layout of them:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQ_MOVE_CLEANUP_VECTOR		FIRST_EXTERNAL_VECTOR</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IA32_SYSCALL_VECTOR		0x80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR_VECTORS 256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIRST_SYSTEM_VECTOR NR_VECTORS</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在<a href="https://ty-chen.github.io/linux-kernel-zero-process/#more">前文</a>中有分析内核的开始源于<code>start_kernel()</code>，而中断部分则开始于其中的<code>trap_init()</code>，这里会填写IDT描述符构成中断向量表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">trap_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Init cpu_entry_area before IST entries are set up */</span></span><br><span class="line">    setup_cpu_entry_areas();</span><br><span class="line">    idt_setup_traps();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Set the IDT descriptor to a fixed read-only location, so that the</span></span><br><span class="line"><span class="comment">     * "sidt" instruction will not leak the location of the kernel, and</span></span><br><span class="line"><span class="comment">     * to defend the IDT against arbitrary memory write vulnerabilities.</span></span><br><span class="line"><span class="comment">     * It will be reloaded in cpu_init() */</span></span><br><span class="line">    cea_set_pte(CPU_ENTRY_AREA_RO_IDT_VADDR, __pa_symbol(idt_table),</span><br><span class="line">            PAGE_KERNEL_RO);</span><br><span class="line">    idt_descr.address = CPU_ENTRY_AREA_RO_IDT;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Should be a barrier for any external CPU state:</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    cpu_init();</span><br><span class="line">    idt_setup_ist_traps();</span><br><span class="line">    x86_init.irqs.trap_init();</span><br><span class="line">    idt_setup_debugidt_traps();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在<code>idt_setup_traps()</code>中会初始化中断，其中前32个中断以枚举形式定义在<code>arch/x86/include/asm/traps.h</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Interrupts/Exceptions */</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    X86_TRAP_DE = <span class="number">0</span>,	<span class="comment">/*  0, Divide-by-zero */</span></span><br><span class="line">    X86_TRAP_DB,		<span class="comment">/*  1, Debug */</span></span><br><span class="line">    X86_TRAP_NMI,		<span class="comment">/*  2, Non-maskable Interrupt */</span></span><br><span class="line">    X86_TRAP_BP,		<span class="comment">/*  3, Breakpoint */</span></span><br><span class="line">    X86_TRAP_OF,		<span class="comment">/*  4, Overflow */</span></span><br><span class="line">    X86_TRAP_BR,		<span class="comment">/*  5, Bound Range Exceeded */</span></span><br><span class="line">    X86_TRAP_UD,		<span class="comment">/*  6, Invalid Opcode */</span></span><br><span class="line">    X86_TRAP_NM,		<span class="comment">/*  7, Device Not Available */</span></span><br><span class="line">    X86_TRAP_DF,		<span class="comment">/*  8, Double Fault */</span></span><br><span class="line">    X86_TRAP_OLD_MF,	<span class="comment">/*  9, Coprocessor Segment Overrun */</span></span><br><span class="line">    X86_TRAP_TS,		<span class="comment">/* 10, Invalid TSS */</span></span><br><span class="line">    X86_TRAP_NP,		<span class="comment">/* 11, Segment Not Present */</span></span><br><span class="line">    X86_TRAP_SS,		<span class="comment">/* 12, Stack Segment Fault */</span></span><br><span class="line">    X86_TRAP_GP,		<span class="comment">/* 13, General Protection Fault */</span></span><br><span class="line">    X86_TRAP_PF,		<span class="comment">/* 14, Page Fault */</span></span><br><span class="line">    X86_TRAP_SPURIOUS,	<span class="comment">/* 15, Spurious Interrupt */</span></span><br><span class="line">    X86_TRAP_MF,		<span class="comment">/* 16, x87 Floating-Point Exception */</span></span><br><span class="line">    X86_TRAP_AC,		<span class="comment">/* 17, Alignment Check */</span></span><br><span class="line">    X86_TRAP_MC,		<span class="comment">/* 18, Machine Check */</span></span><br><span class="line">    X86_TRAP_XF,		<span class="comment">/* 19, SIMD Floating-Point Exception */</span></span><br><span class="line">    X86_TRAP_IRET = <span class="number">32</span>,	<span class="comment">/* 32, IRET Exception */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>idt_setup_traps()</code>实际调用<code>idt_setup_from_table()</code>，其参数为两个默认中断向量表，值和上面枚举值相同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * idt_setup_traps - Initialize the idt table with default traps</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">idt_setup_traps</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    idt_setup_from_table(idt_table, def_idts, ARRAY_SIZE(def_idts), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The exceptions which use Interrupt stacks. They are setup after</span></span><br><span class="line"><span class="comment"> * cpu_init() when the TSS has been initialized.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> __initconst <span class="class"><span class="keyword">struct</span> <span class="title">idt_data</span> <span class="title">ist_idts</span>[] = &#123;</span></span><br><span class="line">    ISTG(X86_TRAP_DB,	debug,		DEBUG_STACK),</span><br><span class="line">    ISTG(X86_TRAP_NMI,	nmi,		NMI_STACK),</span><br><span class="line">    ISTG(X86_TRAP_DF,	double_fault,	DOUBLEFAULT_STACK),</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_MCE</span></span><br><span class="line">    ISTG(X86_TRAP_MC,	&amp;machine_check,	MCE_STACK),</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The default IDT entries which are set up in trap_init() before</span></span><br><span class="line"><span class="comment"> * cpu_init() is invoked. Interrupt stacks cannot be used at that point and</span></span><br><span class="line"><span class="comment"> * the traps which use them are reinitialized with IST after cpu_init() has</span></span><br><span class="line"><span class="comment"> * set up TSS.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> __initconst <span class="class"><span class="keyword">struct</span> <span class="title">idt_data</span> <span class="title">def_idts</span>[] = &#123;</span></span><br><span class="line">    INTG(X86_TRAP_DE,		divide_error),</span><br><span class="line">    INTG(X86_TRAP_NMI,		nmi),</span><br><span class="line">    INTG(X86_TRAP_BR,		bounds),</span><br><span class="line">    INTG(X86_TRAP_UD,		invalid_op),</span><br><span class="line">    INTG(X86_TRAP_NM,		device_not_available),</span><br><span class="line">    INTG(X86_TRAP_OLD_MF,		coprocessor_segment_overrun),</span><br><span class="line">    INTG(X86_TRAP_TS,		invalid_TSS),</span><br><span class="line">    INTG(X86_TRAP_NP,		segment_not_present),</span><br><span class="line">    INTG(X86_TRAP_SS,		stack_segment),</span><br><span class="line">    INTG(X86_TRAP_GP,		general_protection),</span><br><span class="line">    INTG(X86_TRAP_SPURIOUS,		spurious_interrupt_bug),</span><br><span class="line">    INTG(X86_TRAP_MF,		coprocessor_error),</span><br><span class="line">    INTG(X86_TRAP_AC,		alignment_check),</span><br><span class="line">    INTG(X86_TRAP_XF,		simd_coprocessor_error),</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">    TSKG(X86_TRAP_DF,		GDT_ENTRY_DOUBLEFAULT_TSS),</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    INTG(X86_TRAP_DF,		double_fault),</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    INTG(X86_TRAP_DB,		debug),</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_MCE</span></span><br><span class="line">    INTG(X86_TRAP_MC,		&amp;machine_check),</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    SYSG(X86_TRAP_OF,		<span class="built_in">overflow</span>),</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_IA32_EMULATION)</span></span><br><span class="line">    SYSG(IA32_SYSCALL_VECTOR,	entry_INT80_compat),</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(CONFIG_X86_32)</span></span><br><span class="line">    SYSG(IA32_SYSCALL_VECTOR,	entry_INT80_32),</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在 <code>start_kernel()</code> 调用完毕 <code>trap_init()</code> 之后，还会调用 <code>init_IRQ()</code> 来初始化其他的设备中断，最终会调用到 <code>native_init_IRQ()</code>。这里面从第 32 个中断开始，到最后 <code>NR_VECTORS</code> 为止，对于 <code>used_vectors</code> 中没有标记为 1 的位置，都会调用 <code>set_intr_gate()</code> 设置中断向量表。<code>used_vectors</code> 中没有标记为 1 的，都是设备中断的部分，也即所有的设备中断的中断处理函数在中断向量表里面都会设置为从 <code>irq_entries_start</code> 开始，偏移量为 <code>i - FIRST_EXTERNAL_VECTOR</code> 的一项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">init_IRQ</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * On cpu 0, Assign ISA_IRQ_VECTOR(irq) to IRQ 0..15.</span></span><br><span class="line"><span class="comment">     * If these IRQ's are handled by legacy interrupt-controllers like PIC,</span></span><br><span class="line"><span class="comment">     * then this configuration will likely be static after the boot. If</span></span><br><span class="line"><span class="comment">     * these IRQ's are handled by more mordern controllers like IO-APIC,</span></span><br><span class="line"><span class="comment">     * then this vector space can be freed and re-used dynamically as the</span></span><br><span class="line"><span class="comment">     * irq's migrate etc.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_legacy_irqs(); i++)</span><br><span class="line">        per_cpu(vector_irq, <span class="number">0</span>)[ISA_IRQ_VECTOR(i)] = irq_to_desc(i);</span><br><span class="line">    x86_init.irqs.intr_init();</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line">.irqs = &#123;</span><br><span class="line">    .pre_vector_init	= init_ISA_irqs,</span><br><span class="line">    .intr_init		= native_init_IRQ,</span><br><span class="line">    .trap_init		= x86_init_noop,</span><br><span class="line">    .intr_mode_init		= apic_intr_mode_init</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __init native_init_IRQ(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Execute any quirks before the call gates are initialised: */</span></span><br><span class="line">    x86_init.irqs.pre_vector_init();</span><br><span class="line">    idt_setup_apic_and_irq_gates();</span><br><span class="line">    lapic_assign_system_vectors();</span><br><span class="line">    <span class="keyword">if</span> (!acpi_ioapic &amp;&amp; !of_ioapic &amp;&amp; nr_legacy_irqs())</span><br><span class="line">        setup_irq(<span class="number">2</span>, &amp;irq2);</span><br><span class="line">    irq_ctx_init(smp_processor_id());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;中断处理函数定义在 <code>irq_entries_start</code> 表里，在 <code>arch\x86\entry\entry_32.S</code> 和 <code>arch\x86\entry\entry_64.S</code> 都能找到这个函数表的定义。这里面定义了 <code>FIRST_SYSTEM_VECTOR</code> 到 <code>FIRST_EXTERNAL_VECTOR</code> 项。每一项都是中断处理函数，会跳到 <code>common_interrupt()</code> 去执行，并最终调用 <code>do_IRQ()</code>，调用完毕后，就从中断返回。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ENTRY(irq_entries_start)</span><br><span class="line">    <span class="built_in">vector</span>=FIRST_EXTERNAL_VECTOR</span><br><span class="line">    .rept (FIRST_SYSTEM_VECTOR - FIRST_EXTERNAL_VECTOR)</span><br><span class="line">  pushl  $(~<span class="built_in">vector</span>+<span class="number">0x80</span>)      <span class="comment">/* Note: always in signed byte range */</span></span><br><span class="line">    <span class="built_in">vector</span>=<span class="built_in">vector</span>+<span class="number">1</span></span><br><span class="line">  jmp  common_interrupt <span class="comment">/* 会调用到do_IRQ */</span></span><br><span class="line">  .align  <span class="number">8</span></span><br><span class="line">    .endr</span><br><span class="line">END(irq_entries_start)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">common_interrupt:</span><br><span class="line">  ASM_CLAC</span><br><span class="line">  addq  $<span class="number">-0x80</span>, (%rsp)      <span class="comment">/* Adjust vector to [-256, -1] range */</span></span><br><span class="line">  interrupt do_IRQ</span><br><span class="line">  <span class="comment">/* 0(%rsp): old RSP */</span></span><br><span class="line">ret_from_intr:</span><br><span class="line">......</span><br><span class="line">  <span class="comment">/* Interrupt came from user space */</span></span><br><span class="line">GLOBAL(retint_user)</span><br><span class="line">......</span><br><span class="line"><span class="comment">/* Returning to kernel space */</span></span><br><span class="line">retint_kernel:</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>do_IRQ()</code>从 AX 寄存器里面拿到了中断向量 vector，但是别忘了中断控制器发送给每个 CPU 的中断向量都是每个 CPU 局部的，而抽象中断处理层的虚拟中断信号 <code>irq</code> 以及它对应的中断描述结构 <code>irq_desc</code> 是全局的，也即这个 CPU 的 200 号的中断向量和另一个 CPU 的 200 号中断向量对应的虚拟中断信号 <code>irq</code> 和中断描述结构 <code>irq_desc</code> 可能不一样，这就需要一个映射关系。这个映射关系放在 <code>Per CPU</code> 变量 <code>vector_irq</code> 里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * do_IRQ handles all normal device IRQ's (the special</span></span><br><span class="line"><span class="comment"> * SMP cross-CPU interrupts have their own specific</span></span><br><span class="line"><span class="comment"> * handlers).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">__visible <span class="keyword">unsigned</span> <span class="keyword">int</span> __irq_entry <span class="title">do_IRQ</span><span class="params">(struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> *<span class="title">old_regs</span> = <span class="title">set_irq_regs</span>(<span class="title">regs</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> * <span class="title">desc</span>;</span></span><br><span class="line">    <span class="comment">/* high bit used in ret_from_ code  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="built_in">vector</span> = ~regs-&gt;orig_ax;</span><br><span class="line">......</span><br><span class="line">    desc = __this_cpu_read(vector_irq[<span class="built_in">vector</span>]);</span><br><span class="line">    <span class="keyword">if</span> (!handle_irq(desc, regs)) &#123;</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">......</span><br><span class="line">    set_irq_regs(old_regs);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DECLARE_PER_CPU(<span class="keyword">vector_irq_t</span>, vector_irq);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在系统初始化的时候，我们会调用 <code>__assign_irq_vector()</code>，将虚拟中断信号 <code>irq</code> 分配到某个 CPU 上的中断向量。一旦找到某个向量，就调用<code>irq_to_desc(irq)</code>将 CPU 此向量对应的向量描述结构 <code>irq_desc</code>设置为虚拟中断信号 <code>irq</code> 对应的向量描述结构 。 <code>do_IRQ()</code> 会根据中断向量 vector 得到对应的 中断<code>irq</code>，然后调用 <code>handle_irq()</code>。<code>handle_irq()</code> 会调用 <code>generic_handle_irq_desc()</code>，最终调用 该中断<code>irq</code>绑定的处理函数 <code>handle_irq()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">handle_irq</span><span class="params">(struct irq_desc *desc, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">    generic_handle_irq_desc(desc);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Architectures call this to let the generic IRQ layer</span></span><br><span class="line"><span class="comment"> * handle an interrupt.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">generic_handle_irq_desc</span><span class="params">(struct irq_desc *desc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    desc-&gt;handle_irq(desc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>handle_irq()</code>函数最终会调用<code>__handle_irq_event_percpu()</code>，<code>__handle_irq_event_percpu()</code> 里面调用了 <code>irq_desc ()</code>里每个 <code>handler</code>，这些 <code>handler</code> 是我们在所有 <code>action</code> 列表中注册的，这才是我们设置的那个中断处理函数。如果返回值是 <code>IRQ_HANDLED</code>，就说明处理完毕；如果返回值是 <code>IRQ_WAKE_THREAD</code> 就唤醒线程。至此，中断的整个过程就结束了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">irqreturn_t</span> __handle_irq_event_percpu(struct irq_desc *desc, <span class="keyword">unsigned</span> <span class="keyword">int</span> *flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">irqreturn_t</span> retval = IRQ_NONE;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> irq = desc-&gt;irq_data.irq;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span></span><br><span class="line"></span><br><span class="line">    record_irq_time(desc);</span><br><span class="line"></span><br><span class="line">    for_each_action_of_desc(desc, action) &#123;</span><br><span class="line">        <span class="keyword">irqreturn_t</span> res;</span><br><span class="line">        res = action-&gt;handler(irq, action-&gt;dev_id);</span><br><span class="line">        <span class="keyword">switch</span> (res) &#123;</span><br><span class="line">        <span class="keyword">case</span> IRQ_WAKE_THREAD:</span><br><span class="line">            __irq_wake_thread(desc, action);</span><br><span class="line">        <span class="keyword">case</span> IRQ_HANDLED:</span><br><span class="line">            *flags |= action-&gt;flags;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        retval |= res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;本文大致分析了中断的整个流程，由此我们可以了解到中断结构体，注册机制以及如何生效并触发对应的中断处理函数。</p>
<h2 id="源码资料"><a href="#源码资料" class="headerlink" title="源码资料"></a>源码资料</h2><p>[1] <a href="https://code.woboq.org/linux/linux/include/linux/irqdesc.h.html#irq_desc" target="_blank" rel="noopener">irq_desc</a></p>
<p>[2] <a href="https://code.woboq.org/linux/linux/arch/x86/kernel/traps.c.html#trap_init" target="_blank" rel="noopener">trap_init()</a></p>
<p>[3] <a href="https://code.woboq.org/linux/linux/arch/x86/kernel/irqinit.c.html#init_IRQ" target="_blank" rel="noopener">init_IRQ()</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] wiki</p>
<p>[2] <a href="https://elixir.bootlin.com/linux/v5.7-rc1/source" target="_blank" rel="noopener">elixir.bootlin.com/linux</a></p>
<p>[3] <a href="https://code.woboq.org/" target="_blank" rel="noopener">woboq</a></p>
<p>[4] Linux-insides</p>
<p>[5] 深入理解Linux内核</p>
<p>[6] Linux内核设计的艺术</p>
<p>[7] 极客时间 趣谈Linux操作系统</p>
<p>[8] Linux设备驱动程序</p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创，坚持分享，谢谢鼓励和支持</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="Ty Chen 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="Ty Chen 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Ty Chen
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://ty-chen.github.io/linux-kernel-interrupt/" title="Linux操作系统学习笔记（十五）中断">https://ty-chen.github.io/linux-kernel-interrupt/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
            <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a>
          
            <a href="/tags/%E4%B8%AD%E6%96%AD/" rel="tag"># 中断</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/linux-kernel-block-device/" rel="next" title="Linux操作系统学习笔记（十四）块设备">
                <i class="fa fa-chevron-left"></i> Linux操作系统学习笔记（十四）块设备
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/linux-kernel-signal/" rel="prev" title="Linux操作系统学习笔记（十六）进程间通信之信号">
                Linux操作系统学习笔记（十六）进程间通信之信号 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        
  <div class="bdsharebuttonbox">
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
    <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
    <a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a>
    <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
    <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a class="bds_count" data-cmd="count"></a>
  </div>
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "2",
        "bdMiniList": false,
        "bdPic": ""
      },
      "share": {
        "bdSize": "16",
        "bdStyle": "0"
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/me.JPG"
                alt="Ty Chen" />
            
              <p class="site-author-name" itemprop="name">Ty Chen</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">47</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">76</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Ty-Chen" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:tianyuch@hotmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Friends
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://lishouxian.cn/" title="Stanleylsx" target="_blank">Stanleylsx</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一-前言"><span class="nav-text">一. 前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二-什么是中断"><span class="nav-text">二. 什么是中断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三-软中断的必要性"><span class="nav-text">三. 软中断的必要性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四-中断结构体"><span class="nav-text">四. 中断结构体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五-中断流程"><span class="nav-text">五. 中断流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#源码资料"><span class="nav-text">源码资料</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2020 &mdash; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ty Chen</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">186.7k</span>
  
  <a href="http://www.beian.miit.gov.cn/" target="_blank" rel="noopener">粤ICP备20071543号</a> 
</div>









        
<div class="busuanzi-count">
	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>

  
    <span class="site-uv">
      你是来访的第
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      位同学
    </span>
  

  
    <span class="site-pv">
      访问次数：
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'aTqo2eFkO2Bn0AGX008uKDV7-gzGzoHsz',
        appKey: 'uJ6nxqW7RHWpAILCtttkJfJu',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
