<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/kulamati128.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/kulamati32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/kulamati16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Linux,操作系统,进程间通信,网络通信,TCP,三次握手," />










<meta name="description" content="一. 前言&amp;emsp;&amp;emsp;三次握手的基本知识在前文中已说明，本文从源码入手来详细分析其实现原理。">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux操作系统学习笔记（二十一）网络通信之三次握手">
<meta property="og:url" content="https://ty-chen.github.io/linux-kernel-handshake/index.html">
<meta property="og:site_name" content="Ty-Chen&#39;s Home">
<meta property="og:description" content="一. 前言&amp;emsp;&amp;emsp;三次握手的基本知识在前文中已说明，本文从源码入手来详细分析其实现原理。">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/99/da/997e39e5574252ada22220e4b3646dda.png">
<meta property="article:published_time" content="2020-08-01T03:41:21.000Z">
<meta property="article:modified_time" content="2020-08-18T13:45:04.667Z">
<meta property="article:author" content="Ty Chen">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="进程间通信">
<meta property="article:tag" content="网络通信">
<meta property="article:tag" content="TCP">
<meta property="article:tag" content="三次握手">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://static001.geekbang.org/resource/image/99/da/997e39e5574252ada22220e4b3646dda.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://ty-chen.github.io/linux-kernel-handshake/"/>





  <title>Linux操作系统学习笔记（二十一）网络通信之三次握手 | Ty-Chen's Home</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ty-Chen's Home</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Collecting, sharing and creating knowledge</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ty-chen.github.io/linux-kernel-handshake/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ty Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty-Chen's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Linux操作系统学习笔记（二十一）网络通信之三次握手</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-01T11:41:21+08:00">
                2020-08-01
              </time>
            

            

            
          </span>
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2020-08-18T21:45:04+08:00" content="2020-08-18">
                2020-08-18
              </time>
            </span>
          
          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index">
                    <span itemprop="name">Linux操作系统内核学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/linux-kernel-handshake/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/linux-kernel-handshake/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv">访问次数：
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  18
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h2><p>&emsp;&emsp;三次握手的基本知识在前文中已说明，本文从源码入手来详细分析其实现原理。</p>
<a id="more"></a>

<h2 id="二-基本过程和API"><a href="#二-基本过程和API" class="headerlink" title="二. 基本过程和API"></a>二. 基本过程和API</h2><p>&emsp;&emsp;一个简单的TCP客户端/服务端模型如下所示，其中<code>Socket()</code>会创建套接字并返回描述符，在前文已经详细分析过。之后<code>bind()</code>会绑定本地的IP/Port二元组用以定位，而<code>connect(), listen(), accept()</code>则是本篇的重点所在，即通过三次握手完成连接的建立。</p>
<img src="https://static001.geekbang.org/resource/image/99/da/997e39e5574252ada22220e4b3646dda.png" alt="img" style="zoom: 33%;" />

<h2 id="三-源码分析"><a href="#三-源码分析" class="headerlink" title="三. 源码分析"></a>三. 源码分析</h2><h3 id="3-1-bind"><a href="#3-1-bind" class="headerlink" title="3.1 bind"></a>3.1 <code>bind</code></h3><p>&emsp;&emsp;首先来看看<code>bind()</code>函数。其API如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">__kernel_sa_family_t</span>  sin_family;  <span class="comment">/* Address family    */</span></span><br><span class="line">    __be16    sin_port;  <span class="comment">/* Port number      */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>  <span class="title">sin_addr</span>;</span>  <span class="comment">/* Internet address    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pad to size of `struct sockaddr'. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>    __pad[__SOCK_SIZE__ - <span class="keyword">sizeof</span>(short <span class="keyword">int</span>) -</span><br><span class="line">      <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> short <span class="keyword">int</span>) - <span class="keyword">sizeof</span>(struct in_addr)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    __be32  s_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;该函数比较简单，主要是为套接字分配指定的IP地址及端口。在 <code>bind()</code> 中主要逻辑如下</p>
<ul>
<li>调用<code>sockfd_lookup_light()</code> 根据 <code>fd</code> 文件描述符，找到 struct socket 结构</li>
<li>调用<code>move_addr_to_kernel()</code>将 <code>sockaddr</code> 从用户态拷贝到内核态</li>
<li>调用 <code>struct socket</code> 结构里面 <code>ops</code> 的 <code>bind()</code> 函数。根据前面创建 <code>socket</code> 的时候的设定，调用的是 <code>inet_stream_ops</code> 的 <code>bind()</code> 函数，也即调用 <code>inet_bind()</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(bind, <span class="keyword">int</span>, fd, struct sockaddr __user *, umyaddr, <span class="keyword">int</span>, addrlen)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __sys_bind(fd, umyaddr, addrlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __sys_bind(<span class="keyword">int</span> fd, struct sockaddr __user *umyaddr, <span class="keyword">int</span> addrlen)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="keyword">int</span> err, fput_needed;</span><br><span class="line">    sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line">    <span class="keyword">if</span> (sock) &#123;</span><br><span class="line">        err = move_addr_to_kernel(umyaddr, addrlen, &amp;address);</span><br><span class="line">        <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">            err = security_socket_bind(sock,</span><br><span class="line">                           (struct sockaddr *)&amp;address,</span><br><span class="line">                           addrlen);</span><br><span class="line">            <span class="keyword">if</span> (!err)</span><br><span class="line">                err = sock-&gt;ops-&gt;bind(sock,</span><br><span class="line">                              (struct sockaddr *)</span><br><span class="line">                              &amp;address, addrlen);</span><br><span class="line">        &#125;</span><br><span class="line">        fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>sockfd_lookup_light()</code>主要逻辑如下：</p>
<ul>
<li>调用<code>fdget()-&gt;__fdget()-&gt;__fget_light()-&gt;__fcheck_files()</code>获取文件<code>file</code>和<code>flag</code>组合成的结构体<code>fd</code></li>
<li>调用<code>sock_from_file()</code>获取<code>file</code>对应的套接字<code>sock</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct socket *<span class="title">sockfd_lookup_light</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> *err, <span class="keyword">int</span> *fput_needed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span> = <span class="title">fdget</span>(<span class="title">fd</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">    *err = -EBADF;</span><br><span class="line">    <span class="keyword">if</span> (f.file) &#123;</span><br><span class="line">        sock = sock_from_file(f.file, err);</span><br><span class="line">        <span class="keyword">if</span> (likely(sock)) &#123;</span><br><span class="line">            *fput_needed = f.flags;</span><br><span class="line">            <span class="keyword">return</span> sock;</span><br><span class="line">        &#125;</span><br><span class="line">        fdput(f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>inet_bind()</code>作用于网络层，因为传输层实际并无IP地址信息。主要逻辑为</p>
<ul>
<li>调用 <code>sk_prot</code> 的 <code>get_port()</code> 函数，也即 <code>inet_csk_get_port()</code> 来检查端口是否冲突，是否可以绑定。</li>
<li>如果允许，则会设置 <code>struct inet_sock</code> 的本地地址 <code>inet_saddr</code> 和本地端口 <code>inet_sport</code>，对方的地址 <code>inet_daddr</code> 和对方的端口 <code>inet_dport</code> 都初始化为 0。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_bind</span><span class="params">(struct socket *sock, struct sockaddr *uaddr, <span class="keyword">int</span> addr_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line">......</span><br><span class="line">    <span class="keyword">return</span> __inet_bind(sk, uaddr, addr_len, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __inet_bind(struct sock *sk, struct sockaddr *uaddr, <span class="keyword">int</span> addr_len,</span><br><span class="line">        <span class="keyword">bool</span> force_bind_address_no_port, <span class="keyword">bool</span> with_lock)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">addr</span> = (<span class="title">struct</span> <span class="title">sockaddr_in</span> *)<span class="title">uaddr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span> = <span class="title">inet_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> = <span class="title">sock_net</span>(<span class="title">sk</span>);</span></span><br><span class="line">    <span class="keyword">unsigned</span> short snum;</span><br><span class="line">......</span><br><span class="line">    snum = ntohs(addr-&gt;sin_port);</span><br><span class="line">......</span><br><span class="line">    inet-&gt;inet_rcv_saddr = inet-&gt;inet_saddr = addr-&gt;sin_addr.s_addr;</span><br><span class="line">    <span class="keyword">if</span> (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)</span><br><span class="line">        inet-&gt;inet_saddr = <span class="number">0</span>;  <span class="comment">/* Use device */</span></span><br><span class="line">    <span class="comment">/* Make sure we are allowed to bind here. */</span></span><br><span class="line">    <span class="keyword">if</span> (snum || !(inet-&gt;bind_address_no_port ||</span><br><span class="line">              force_bind_address_no_port)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sk-&gt;sk_prot-&gt;get_port(sk, snum)) &#123;</span><br><span class="line">            inet-&gt;inet_saddr = inet-&gt;inet_rcv_saddr = <span class="number">0</span>;</span><br><span class="line">            err = -EADDRINUSE;</span><br><span class="line">            <span class="keyword">goto</span> out_release_sock;</span><br><span class="line">        &#125;</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    inet-&gt;inet_sport = htons(inet-&gt;inet_num);</span><br><span class="line">    inet-&gt;inet_daddr = <span class="number">0</span>;</span><br><span class="line">    inet-&gt;inet_dport = <span class="number">0</span>;</span><br><span class="line">    sk_dst_reset(sk);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-listen"><a href="#3-2-listen" class="headerlink" title="3.2 listen"></a>3.2 <code>listen</code></h3><p>&emsp;&emsp;<code>listen()</code>的API如下，其中<code>backlog</code>需要注意，其定义为套接字监听队列的最大长度，实际上会有个小坑，具体可见<a href="https://segmentfault.com/a/1190000019252960" target="_blank" rel="noopener">这篇博文</a>分析。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其函数调用如下，主要逻辑为</p>
<ul>
<li>调用<code>sockfd_lookup_light()</code>查找套接字</li>
<li>根据<code>sysctl_somaxconn</code>和<code>backlog</code>取较小值作为监听的队列上限</li>
<li>调用 <code>ops</code> 的 <code>listen()</code> 函数，实际调用<code>inet_stream_ops</code>中的<code>inet_listen()</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE2(<span class="built_in">listen</span>, <span class="keyword">int</span>, fd, <span class="keyword">int</span>, backlog)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __sys_listen(fd, backlog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __sys_listen(<span class="keyword">int</span> fd, <span class="keyword">int</span> backlog)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">    <span class="keyword">int</span> err, fput_needed;</span><br><span class="line">    <span class="keyword">int</span> somaxconn;</span><br><span class="line">    sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line">    <span class="keyword">if</span> (sock) &#123;</span><br><span class="line">        somaxconn = sock_net(sock-&gt;sk)-&gt;core.sysctl_somaxconn;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)backlog &gt; somaxconn)</span><br><span class="line">            backlog = somaxconn;</span><br><span class="line">        err = security_socket_listen(sock, backlog);</span><br><span class="line">        <span class="keyword">if</span> (!err)</span><br><span class="line">            err = sock-&gt;ops-&gt;<span class="built_in">listen</span>(sock, backlog);</span><br><span class="line">        fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>inet_listen()</code>主要逻辑为判断套接字<code>sock</code>是否处于监听状态<code>TCP_LISTEN</code>，如果不是则调用<code>inet_csk_listen_start()</code>进入监听状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_listen</span><span class="params">(struct socket *sock, <span class="keyword">int</span> backlog)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> old_state;</span><br><span class="line">    <span class="keyword">int</span> err, tcp_fastopen;</span><br><span class="line">......</span><br><span class="line">    sk-&gt;sk_max_ack_backlog = backlog;</span><br><span class="line">    <span class="comment">/* Really, if the socket is already in listen state</span></span><br><span class="line"><span class="comment">     * we can only allow the backlog to be adjusted.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (old_state != TCP_LISTEN) &#123;</span><br><span class="line">......</span><br><span class="line">        err = inet_csk_listen_start(sk, backlog);</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">    err = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">    release_sock(sk);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>inet_csk_listen_start()</code>主要逻辑如下：</p>
<ul>
<li>建立了一个新的结构 <code>inet_connection_sock</code>，这个结构一开始是 <code>struct inet_sock</code>，<code>inet_csk</code> 其实做了一次强制类型转换扩大了结构。<code>struct inet_connection_sock</code> 结构比较复杂。如果打开它，你能看到处于各种状态的队列，各种超时时间、拥塞控制等字眼。我们说 TCP 是面向连接的，就是客户端和服务端都是有一个结构维护连接的状态，就是指这个结构。</li>
<li>初始化<code>icsk_accept_queue</code>队列。我们知道三次握手中有两个队列：半连接队列和全连接队列。其中半连接队列指三次握手还没完成，处于 <code>syn_rcvd</code> 的状态的连接，全连接指三次握手已经完毕，处于 <code>established</code> 状态的连接。<code>icsk_accept_queue</code>队列就是半连接队列，调用<code>accept()</code>函数时会从该队列取出连接进行判断，如果三次握手顺利完成则放入全连接队列。</li>
<li>将TCP状态设置为<code>TCP_LISTEN</code>，调用<code>get_port()</code>确保端口可用。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_csk_listen_start</span><span class="params">(struct sock *sk, <span class="keyword">int</span> backlog)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> = <span class="title">inet_csk</span>(<span class="title">sk</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span> = <span class="title">inet_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line">    <span class="keyword">int</span> err = -EADDRINUSE;</span><br><span class="line">    </span><br><span class="line">    reqsk_queue_alloc(&amp;icsk-&gt;icsk_accept_queue);</span><br><span class="line">    sk-&gt;sk_ack_backlog = <span class="number">0</span>;</span><br><span class="line">    inet_csk_delack_init(sk);</span><br><span class="line">    <span class="comment">/* There is race window here: we announce ourselves listening,</span></span><br><span class="line"><span class="comment">     * but this transition is still not validated by get_port().</span></span><br><span class="line"><span class="comment">     * It is OK, because this socket enters to hash table only</span></span><br><span class="line"><span class="comment">     * after validation is complete.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    inet_sk_state_store(sk, TCP_LISTEN);</span><br><span class="line">    <span class="keyword">if</span> (!sk-&gt;sk_prot-&gt;get_port(sk, inet-&gt;inet_num)) &#123;</span><br><span class="line">        inet-&gt;inet_sport = htons(inet-&gt;inet_num);</span><br><span class="line">        sk_dst_reset(sk);</span><br><span class="line">        err = sk-&gt;sk_prot-&gt;hash(sk);</span><br><span class="line">        <span class="keyword">if</span> (likely(!err))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    inet_sk_set_state(sk, TCP_CLOSE);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3accept"><a href="#3-3accept" class="headerlink" title="3.3accept"></a>3.3<code>accept</code></h3><p>&emsp;&emsp;<code>accept()</code>的API如下，服务端调用<code>accept()</code>会在监听套接字的基础上创建新的套接字来作为连接套接字，并返回连接套接字的描述符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;对应的系统调用如下，从这里可以很清楚的看到新套接字的创立，主要逻辑为：</p>
<ul>
<li>调用<code>sockfd_lookup_light()</code>查找描述符<code>fd</code>对应的监听套接字<code>sock</code></li>
<li>创建新套接字<code>newsock</code>，类型和操作和监听套接字保持一致，并创建新的文件<code>newfile</code>和套接字绑定</li>
<li>调用套接字对应的<code>accept()</code>函数，即<code>inet_accept()</code>完成实际服务端握手过程</li>
<li>调用<code>fd_install()</code>关联套接字文件和套接字描述符，并返回连接的套接字描述符</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(accept, <span class="keyword">int</span>, fd, struct sockaddr __user *, upeer_sockaddr,</span><br><span class="line">        <span class="keyword">int</span> __user *, upeer_addrlen)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __sys_accept4(fd, upeer_sockaddr, upeer_addrlen, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __sys_accept4(<span class="keyword">int</span> fd, struct sockaddr __user *upeer_sockaddr,</span><br><span class="line">          <span class="keyword">int</span> __user *upeer_addrlen, <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>, *<span class="title">newsock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">newfile</span>;</span></span><br><span class="line">    <span class="keyword">int</span> err, len, newfd, fput_needed;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">address</span>;</span></span><br><span class="line">......</span><br><span class="line">    sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line">......</span><br><span class="line">    newsock = sock_alloc();</span><br><span class="line">......</span><br><span class="line">    newsock-&gt;type = sock-&gt;type;</span><br><span class="line">    newsock-&gt;ops = sock-&gt;ops;</span><br><span class="line">......</span><br><span class="line">    __module_get(newsock-&gt;ops-&gt;owner);</span><br><span class="line">    newfd = get_unused_fd_flags(flags);</span><br><span class="line">......</span><br><span class="line">    newfile = sock_alloc_file(newsock, flags, sock-&gt;sk-&gt;sk_prot_creator-&gt;name);</span><br><span class="line">......</span><br><span class="line">    err = sock-&gt;ops-&gt;accept(sock, newsock, sock-&gt;file-&gt;f_flags, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out_fd;</span><br><span class="line">    <span class="keyword">if</span> (upeer_sockaddr) &#123;</span><br><span class="line">        len = newsock-&gt;ops-&gt;getname(newsock,</span><br><span class="line">                    (struct sockaddr *)&amp;address, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            err = -ECONNABORTED;</span><br><span class="line">            <span class="keyword">goto</span> out_fd;</span><br><span class="line">        &#125;</span><br><span class="line">        err = move_addr_to_user(&amp;address,</span><br><span class="line">                    len, upeer_sockaddr, upeer_addrlen);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> out_fd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* File flags are not inherited via accept() unlike another OSes. */</span></span><br><span class="line">    fd_install(newfd, newfile);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>inet_accept()</code>会提取监听套接字的网络层结构体<code>sk1</code>和新建套接字的<code>sk2</code>，调用<code>sk1</code>协议对应的<code>accept()</code>完成握手并保存连接状态于<code>sk2</code>中，这里实际调用的是<code>inet_csk_accept()</code>函数。接着将<code>sk2</code>和新建套接字进行关联。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_accept</span><span class="params">(struct socket *sock, struct socket *newsock, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">bool</span> kern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk1</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line">    <span class="keyword">int</span> err = -EINVAL;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk2</span> = <span class="title">sk1</span>-&gt;<span class="title">sk_prot</span>-&gt;<span class="title">accept</span>(<span class="title">sk1</span>, <span class="title">flags</span>, &amp;<span class="title">err</span>, <span class="title">kern</span>);</span></span><br><span class="line">    <span class="keyword">if</span> (!sk2)</span><br><span class="line">        <span class="keyword">goto</span> do_err;</span><br><span class="line">    lock_sock(sk2);</span><br><span class="line">    sock_rps_record_flow(sk2);</span><br><span class="line">    WARN_ON(!((<span class="number">1</span> &lt;&lt; sk2-&gt;sk_state) &amp;</span><br><span class="line">          (TCPF_ESTABLISHED | TCPF_SYN_RECV |</span><br><span class="line">          TCPF_CLOSE_WAIT | TCPF_CLOSE)));</span><br><span class="line">    sock_graft(sk2, newsock);</span><br><span class="line">    newsock-&gt;state = SS_CONNECTED;</span><br><span class="line">    err = <span class="number">0</span>;</span><br><span class="line">    release_sock(sk2);</span><br><span class="line">do_err:</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>inet_csk_accept()</code>函数会判断当前的半连接队列<code>rskq_accept_queue</code>是否为空，如果空则调用<code>inet_csk_wait_for_connect()</code>及逆行等待。如果不为空则从队列中取出一个连接，赋值给<code>newsk</code>并返回。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct sock *<span class="title">inet_csk_accept</span><span class="params">(struct sock *sk, <span class="keyword">int</span> flags, <span class="keyword">int</span> *err, <span class="keyword">bool</span> kern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> = <span class="title">inet_csk</span>(<span class="title">sk</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request_sock_queue</span> *<span class="title">queue</span> = &amp;<span class="title">icsk</span>-&gt;<span class="title">icsk_accept_queue</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request_sock</span> *<span class="title">req</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">newsk</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* Find already established connection */</span></span><br><span class="line">    <span class="keyword">if</span> (reqsk_queue_empty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">......</span><br><span class="line">        error = inet_csk_wait_for_connect(sk, timeo);</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">    req = reqsk_queue_remove(<span class="built_in">queue</span>, sk);</span><br><span class="line">    newsk = req-&gt;sk;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>inet_csk_wait_for_connect()</code>调用 <code>schedule_timeout()</code>让出 CPU，并且将进程状态设置为 <code>TASK_INTERRUPTIBLE</code>。如果再次 CPU 醒来，我们会接着判断 <code>icsk_accept_queue</code> 是否为空，同时也会调用 <code>signal_pending</code> 看有没有信号可以处理。一旦 <code>icsk_accept_queue</code> 不为空，就从 <code>inet_csk_wait_for_connect()</code> 中返回，在队列中取出一个 <code>struct sock</code> 对象赋值给 <code>newsk</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">inet_csk_wait_for_connect</span><span class="params">(struct sock *sk, <span class="keyword">long</span> timeo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> = <span class="title">inet_csk</span>(<span class="title">sk</span>);</span></span><br><span class="line">    DEFINE_WAIT(wait);</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        prepare_to_wait_exclusive(sk_sleep(sk), &amp;wait, TASK_INTERRUPTIBLE);</span><br><span class="line">        release_sock(sk);</span><br><span class="line">        <span class="keyword">if</span> (reqsk_queue_empty(&amp;icsk-&gt;icsk_accept_queue))</span><br><span class="line">            timeo = schedule_timeout(timeo);</span><br><span class="line">        sched_annotate_sleep();</span><br><span class="line">        lock_sock(sk);</span><br><span class="line">        err = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!reqsk_queue_empty(&amp;icsk-&gt;icsk_accept_queue))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        err = -EINVAL;</span><br><span class="line">        <span class="keyword">if</span> (sk-&gt;sk_state != TCP_LISTEN)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        err = sock_intr_errno(timeo);</span><br><span class="line">        <span class="keyword">if</span> (signal_pending(current))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        err = -EAGAIN;</span><br><span class="line">        <span class="keyword">if</span> (!timeo)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    finish_wait(sk_sleep(sk), &amp;wait);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-connect"><a href="#3-4-connect" class="headerlink" title="3.4 connect"></a>3.4 <code>connect</code></h3><p>&emsp;&emsp;<code>connect()</code>函数通常由客户端发起，是三次握手的开始，服务端收到了<code>SYN</code>之后回复<code>ACK + SYN</code>并将该连接加入半连接队列，进入<code>SYN_RCVD</code>状态，第三次握手收到<code>ACK</code>后从半连接队列取出，加入全连接队列，此时的 socket 处于 <code>ESTABLISHED</code> 状态。<code>accept()</code>函数唤醒后检索队列，发现有连接则继续工作下去，从队列中取出该套接字并返回，供以后续读写使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>connect()</code>对应的系统调用如下所示，其主要逻辑为：</p>
<ul>
<li>调用<code>sockfd_lookup_light()</code>查找套接字描述符<code>fd</code>对应的套接字<code>sock</code></li>
<li>调用<code>move_addr_to_kernel()</code>将目的地址发到内核中供使用</li>
<li>调用初始化<code>connect()</code>函数或者设置的特定<code>connect()</code>函数，这里会调用<code>inet_stream_connect()</code>发起连接</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(<span class="built_in">connect</span>, <span class="keyword">int</span>, fd, struct sockaddr __user *, uservaddr,</span><br><span class="line">        <span class="keyword">int</span>, addrlen)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __sys_connect(fd, uservaddr, addrlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __sys_connect(<span class="keyword">int</span> fd, struct sockaddr __user *uservaddr, <span class="keyword">int</span> addrlen)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="keyword">int</span> err, fput_needed;</span><br><span class="line">    sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line">    <span class="keyword">if</span> (!sock)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    err = move_addr_to_kernel(uservaddr, addrlen, &amp;address);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out_put;</span><br><span class="line">    err = security_socket_connect(sock, (struct sockaddr *)&amp;address, addrlen);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> out_put;</span><br><span class="line">    err = sock-&gt;ops-&gt;<span class="built_in">connect</span>(sock, (struct sockaddr *)&amp;address, addrlen,</span><br><span class="line">                 sock-&gt;file-&gt;f_flags);</span><br><span class="line">out_put:</span><br><span class="line">    fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>inet_stream_connect()</code>主要逻辑为</p>
<ul>
<li>判断当前套接字状态，如果尚未连接则调用 <code>struct sock</code> 的 <code>sk-&gt;sk_prot-&gt;connect()</code>，也即 <code>tcp_prot</code> 的 <code>connect()</code> 函数<code>tcp_v4_connect()</code> 函数发起握手。</li>
<li>调用<code>inet_wait_for_connect()</code>，等待来自于服务端的<code>ACK</code>信号</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_stream_connect</span><span class="params">(struct socket *sock, struct sockaddr *uaddr,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> addr_len, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">    err = __inet_stream_connect(sock, uaddr, addr_len, flags, <span class="number">0</span>);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __inet_stream_connect(struct socket *sock, struct sockaddr *uaddr,</span><br><span class="line">              <span class="keyword">int</span> addr_len, <span class="keyword">int</span> flags, <span class="keyword">int</span> is_sendmsg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">long</span> timeo;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">switch</span> (sock-&gt;state) &#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">case</span> SS_UNCONNECTED:</span><br><span class="line">......</span><br><span class="line">        <span class="keyword">if</span> (BPF_CGROUP_PRE_CONNECT_ENABLED(sk)) &#123;</span><br><span class="line">            err = sk-&gt;sk_prot-&gt;pre_connect(sk, uaddr, addr_len);</span><br><span class="line">            <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        err = sk-&gt;sk_prot-&gt;<span class="built_in">connect</span>(sk, uaddr, addr_len);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        sock-&gt;state = SS_CONNECTING;</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">    timeo = sock_sndtimeo(sk, flags &amp; O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; sk-&gt;sk_state) &amp; (TCPF_SYN_SENT | TCPF_SYN_RECV)) &#123;</span><br><span class="line">......</span><br><span class="line">        <span class="comment">/* Error code is set above */</span></span><br><span class="line">        <span class="keyword">if</span> (!timeo || !inet_wait_for_connect(sk, timeo, writebias))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        err = sock_intr_errno(timeo);</span><br><span class="line">        <span class="keyword">if</span> (signal_pending(current))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* sk-&gt;sk_err may be not zero now, if RECVERR was ordered by user</span></span><br><span class="line"><span class="comment">     * and error was received after socket entered established state.</span></span><br><span class="line"><span class="comment">     * Hence, it is handled normally after connect() return successfully.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    sock-&gt;state = SS_CONNECTED;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcp_v4_connect()</code>主要逻辑为</p>
<ul>
<li>调用<code>ip_route_connect()</code>选择一条路由，根据选定的网卡填写该网卡的 IP 地址作为源IP地址</li>
<li>将客户端状态设置为<code>TCP_SYN_SENT</code>，初始化序列号<code>write_seq</code></li>
<li>调用<code>tcp_connect()</code>发送<code>SYN</code>包</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_v4_connect</span><span class="params">(struct sock *sk, struct sockaddr *uaddr, <span class="keyword">int</span> addr_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">usin</span> = (<span class="title">struct</span> <span class="title">sockaddr_in</span> *)<span class="title">uaddr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span> = <span class="title">inet_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> = <span class="title">tcp_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line">    __be16 orig_sport, orig_dport;</span><br><span class="line">    __be32 daddr, nexthop;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flowi4</span> *<span class="title">fl4</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtable</span> *<span class="title">rt</span>;</span></span><br><span class="line">......</span><br><span class="line">    orig_sport = inet-&gt;inet_sport;</span><br><span class="line">    orig_dport = usin-&gt;sin_port;</span><br><span class="line">    fl4 = &amp;inet-&gt;cork.fl.u.ip4;</span><br><span class="line">    rt = ip_route_connect(fl4, nexthop, inet-&gt;inet_saddr,</span><br><span class="line">                  RT_CONN_FLAGS(sk), sk-&gt;sk_bound_dev_if,</span><br><span class="line">                  IPPROTO_TCP,</span><br><span class="line">                  orig_sport, orig_dport, sk);</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* Socket identity is still unknown (sport may be zero).</span></span><br><span class="line"><span class="comment">     * However we set state to SYN-SENT and not releasing socket</span></span><br><span class="line"><span class="comment">     * lock select source port, enter ourselves into the hash tables and</span></span><br><span class="line"><span class="comment">     * complete initialization after this.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    tcp_set_state(sk, TCP_SYN_SENT);</span><br><span class="line">    err = inet_hash_connect(tcp_death_row, sk);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> failure;</span><br><span class="line">    sk_set_txhash(sk);</span><br><span class="line">    rt = ip_route_newports(fl4, rt, orig_sport, orig_dport,</span><br><span class="line">                   inet-&gt;inet_sport, inet-&gt;inet_dport, sk);</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* OK, now commit destination to socket.  */</span></span><br><span class="line">    sk-&gt;sk_gso_type = SKB_GSO_TCPV4;</span><br><span class="line">    sk_setup_caps(sk, &amp;rt-&gt;dst);</span><br><span class="line">    rt = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (likely(!tp-&gt;repair)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tp-&gt;write_seq)</span><br><span class="line">            tp-&gt;write_seq = secure_tcp_seq(inet-&gt;inet_saddr,</span><br><span class="line">                               inet-&gt;inet_daddr,</span><br><span class="line">                               inet-&gt;inet_sport,</span><br><span class="line">                               usin-&gt;sin_port);</span><br><span class="line">        tp-&gt;tsoffset = secure_tcp_ts_off(sock_net(sk),</span><br><span class="line">                         inet-&gt;inet_saddr,</span><br><span class="line">                         inet-&gt;inet_daddr);</span><br><span class="line">    &#125;</span><br><span class="line">    inet-&gt;inet_id = tp-&gt;write_seq ^ jiffies;</span><br><span class="line">......</span><br><span class="line">    err = tcp_connect(sk);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcp_connect()</code>主要逻辑为</p>
<ul>
<li>创建新的结构体 <code>struct tcp_sock</code>该结构体是 <code>struct inet_connection_sock</code> 的一个扩展，维护了更多的 TCP 的状态</li>
<li>调用<code>tcp_init_nondata_skb()</code> 初始化一个 <code>SYN</code> 包</li>
<li>调用<code>tcp_transmit_skb()</code> 将 <code>SYN</code> 包发送出去</li>
<li>调用<code>inet_csk_reset_xmit_timer()</code> 设置了一个 <code>timer</code>，如果 <code>SYN</code> 发送不成功，则再次发送。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_connect</span><span class="params">(struct sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> = <span class="title">tcp_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">buff</span>;</span></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">......</span><br><span class="line">    tcp_connect_init(sk);</span><br><span class="line">......</span><br><span class="line">    buff = sk_stream_alloc_skb(sk, <span class="number">0</span>, sk-&gt;sk_allocation, <span class="literal">true</span>);</span><br><span class="line">......</span><br><span class="line">    tcp_init_nondata_skb(buff, tp-&gt;write_seq++, TCPHDR_SYN);</span><br><span class="line">    tcp_mstamp_refresh(tp);</span><br><span class="line">    tp-&gt;retrans_stamp = tcp_time_stamp(tp);</span><br><span class="line">    tcp_connect_queue_skb(sk, buff);</span><br><span class="line">    tcp_ecn_send_syn(sk, buff);</span><br><span class="line">    tcp_rbtree_insert(&amp;sk-&gt;tcp_rtx_queue, buff);</span><br><span class="line">    <span class="comment">/* Send off SYN; include data in Fast Open. */</span></span><br><span class="line">    err = tp-&gt;fastopen_req ? tcp_send_syn_data(sk, buff) :</span><br><span class="line">          tcp_transmit_skb(sk, buff, <span class="number">1</span>, sk-&gt;sk_allocation);</span><br><span class="line">......</span><br><span class="line">    tp-&gt;snd_nxt = tp-&gt;write_seq;</span><br><span class="line">    tp-&gt;pushed_seq = tp-&gt;write_seq;</span><br><span class="line">    buff = tcp_send_head(sk);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(buff)) &#123;</span><br><span class="line">        tp-&gt;snd_nxt	= TCP_SKB_CB(buff)-&gt;seq;</span><br><span class="line">        tp-&gt;pushed_seq	= TCP_SKB_CB(buff)-&gt;seq;</span><br><span class="line">    &#125;</span><br><span class="line">    TCP_INC_STATS(sock_net(sk), TCP_MIB_ACTIVEOPENS);</span><br><span class="line">    <span class="comment">/* Timer for repeating the SYN until an answer. */</span></span><br><span class="line">    inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS,</span><br><span class="line">                  inet_csk(sk)-&gt;icsk_rto, TCP_RTO_MAX);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;关于底层发包收包留到后面单独解析，这里先重点看三次握手的过程。当发包完成后，我们会等待接收ACK，接收数据包的调用链为<code>tcp_v4_rcv()-&gt;tcp_v4_do_rcv()-&gt;tcp_rcv_state_process()</code>。<code>tcp_rcv_state_process()</code>是一个服务端客户端通用函数，根据状态位来判断如何执行。</p>
<ul>
<li>当服务端处于<code>TCP_LISTEN</code>状态时，收到第一次握手即客户端的<code>SYN</code>，调用<code>conn_request()</code>进行处理，其实调用的是 <code>tcp_v4_conn_request()</code>，更新自身状态、队列，然后调用<code>tcp_v4_send_synack()</code>发送第二次握手消息，进入状态<code>TCP_SYN_RECV</code></li>
<li>当客户端处于<code>TCP_SYN_SENT</code>状态时，收到服务端返回的第二次握手消息<code>ACK + SYN</code>，调用<code>tcp_rcv_synsent_state_process()</code>进行处理，调用<code>tcp_send_ack()</code>发送<code>ACK</code>回复给服务端，进入<code>TCP_ESTABLISHED</code>状态</li>
<li>服务端处于<code>TCP_SYN_RECV</code>状态时，收到客户端返回的第三次握手消息<code>ACK</code>，进入<code>TCP_ESTABLISHED</code>状态</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_rcv_state_process</span><span class="params">(struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> = <span class="title">tcp_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> = <span class="title">inet_csk</span>(<span class="title">sk</span>);</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">th</span> = <span class="title">tcp_hdr</span>(<span class="title">skb</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request_sock</span> *<span class="title">req</span>;</span></span><br><span class="line">    <span class="keyword">int</span> queued = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> acceptable;</span><br><span class="line">    <span class="keyword">switch</span> (sk-&gt;sk_state) &#123;</span><br><span class="line">    <span class="keyword">case</span> TCP_CLOSE:</span><br><span class="line">        <span class="keyword">goto</span> discard;</span><br><span class="line">    <span class="keyword">case</span> TCP_LISTEN:</span><br><span class="line">......</span><br><span class="line">        <span class="keyword">if</span> (th-&gt;syn) &#123;</span><br><span class="line">......</span><br><span class="line">            acceptable = icsk-&gt;icsk_af_ops-&gt;conn_request(sk, skb) &gt;= <span class="number">0</span>;</span><br><span class="line">......</span><br><span class="line">            consume_skb(skb);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> discard;</span><br><span class="line">    <span class="keyword">case</span> TCP_SYN_SENT:</span><br><span class="line">        tp-&gt;rx_opt.saw_tstamp = <span class="number">0</span>;</span><br><span class="line">        tcp_mstamp_refresh(tp);</span><br><span class="line">        queued = tcp_rcv_synsent_state_process(sk, skb, th);</span><br><span class="line">        <span class="keyword">if</span> (queued &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> queued;</span><br><span class="line">        <span class="comment">/* Do step6 onward by hand. */</span></span><br><span class="line">        tcp_urg(sk, skb, th);</span><br><span class="line">        __kfree_skb(skb);</span><br><span class="line">        tcp_data_snd_check(sk);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">switch</span> (sk-&gt;sk_state) &#123;</span><br><span class="line">    <span class="keyword">case</span> TCP_SYN_RECV:</span><br><span class="line">        tp-&gt;delivered++; <span class="comment">/* SYN-ACK delivery isn't tracked in tcp_ack */</span></span><br><span class="line">        <span class="keyword">if</span> (!tp-&gt;srtt_us)</span><br><span class="line">            tcp_synack_rtt_meas(sk, req);</span><br><span class="line">......</span><br><span class="line">        smp_mb();</span><br><span class="line">        tcp_set_state(sk, TCP_ESTABLISHED);</span><br><span class="line">        sk-&gt;sk_state_change(sk);</span><br><span class="line">        <span class="comment">/* Note, that this wakeup is only for marginal crossed SYN case.</span></span><br><span class="line"><span class="comment">         * Passively open sockets are not waked up, because</span></span><br><span class="line"><span class="comment">         * sk-&gt;sk_sleep == NULL and sk-&gt;sk_socket == NULL.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (sk-&gt;sk_socket)</span><br><span class="line">            sk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT);</span><br><span class="line">        tp-&gt;snd_una = TCP_SKB_CB(skb)-&gt;ack_seq;</span><br><span class="line">        tp-&gt;snd_wnd = ntohs(th-&gt;window) &lt;&lt; tp-&gt;rx_opt.snd_wscale;</span><br><span class="line">        tcp_init_wl(tp, TCP_SKB_CB(skb)-&gt;seq);</span><br><span class="line">        <span class="keyword">if</span> (tp-&gt;rx_opt.tstamp_ok)</span><br><span class="line">            tp-&gt;advmss -= TCPOLEN_TSTAMP_ALIGNED;</span><br><span class="line">        <span class="keyword">if</span> (!inet_csk(sk)-&gt;icsk_ca_ops-&gt;cong_control)</span><br><span class="line">            tcp_update_pacing_rate(sk);</span><br><span class="line">        <span class="comment">/* Prevent spurious tcp_cwnd_restart() on first data packet */</span></span><br><span class="line">        tp-&gt;lsndtime = tcp_jiffies32;</span><br><span class="line">        tcp_initialize_rcv_mss(sk);</span><br><span class="line">        tcp_fast_path_on(tp);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;本文较为详细的叙述了三次握手的整个过程，四次挥手有着类似的过程因此不做赘述，其中的区别在于多了一个<code>TIME_WAIT</code>以及对应的定时器。下篇文章开始我们将详细分析发包和收包的整个网络协议栈流程。</p>
<h2 id="源码资料"><a href="#源码资料" class="headerlink" title="源码资料"></a>源码资料</h2><p>[1] <a href="https://code.woboq.org/linux/linux/net/socket.c.html#__sys_bind" target="_blank" rel="noopener">bind()</a></p>
<p>[2] <a href="https://code.woboq.org/linux/linux/net/ipv4/af_inet.c.html#inet_bind" target="_blank" rel="noopener">inet_bind()</a></p>
<p>[3] <a href="https://code.woboq.org/linux/linux/net/socket.c.html#__sys_listen" target="_blank" rel="noopener">listen()</a></p>
<p>[4] <a href="https://code.woboq.org/linux/linux/net/ipv4/af_inet.c.html#inet_listen" target="_blank" rel="noopener">inet_listen()</a></p>
<p>[5] <a href="https://code.woboq.org/linux/linux/net/socket.c.html#__sys_accept4" target="_blank" rel="noopener">accept()</a></p>
<p>[6] <a href="https://code.woboq.org/linux/linux/net/ipv4/af_inet.c.html#inet_accept" target="_blank" rel="noopener">inet_accept()</a></p>
<p>[7] <a href="https://code.woboq.org/linux/linux/net/ipv4/inet_connection_sock.c.html#inet_csk_accept" target="_blank" rel="noopener">inet_csk_accept()</a></p>
<p>[7] <a href="https://code.woboq.org/linux/linux/net/socket.c.html#__sys_connect" target="_blank" rel="noopener">connect()</a></p>
<p>[8] <a href="https://code.woboq.org/linux/linux/net/ipv4/af_inet.c.html#inet_stream_connect" target="_blank" rel="noopener">__inet_stream_connect()</a></p>
<p>[9] <a href="https://code.woboq.org/linux/linux/net/ipv4/tcp_ipv4.c.html#tcp_v4_connect" target="_blank" rel="noopener">tcp_v4_connect()</a></p>
<p>[10] <a href="https://code.woboq.org/linux/linux/net/ipv4/tcp_input.c.html#tcp_conn_request" target="_blank" rel="noopener">tcp_conn_request()</a></p>
<p>[11] <a href="https://code.woboq.org/linux/linux/net/ipv4/tcp_input.c.html#tcp_rcv_state_process" target="_blank" rel="noopener">tcp_rcv_state_process()</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] wiki</p>
<p>[2] <a href="https://elixir.bootlin.com/linux/v5.7-rc1/source" target="_blank" rel="noopener">elixir.bootlin.com/linux</a></p>
<p>[3] <a href="https://code.woboq.org/" target="_blank" rel="noopener">woboq</a></p>
<p>[4] Linux-insides</p>
<p>[5] 深入理解Linux内核</p>
<p>[6] Linux内核设计的艺术</p>
<p>[7] 极客时间 趣谈Linux操作系统</p>
<p>[8] 深入理解Linux网络技术内幕</p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创，坚持分享，谢谢鼓励和支持</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="Ty Chen 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="Ty Chen 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Ty Chen
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://ty-chen.github.io/linux-kernel-handshake/" title="Linux操作系统学习笔记（二十一）网络通信之三次握手">https://ty-chen.github.io/linux-kernel-handshake/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
            <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a>
          
            <a href="/tags/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" rel="tag"># 进程间通信</a>
          
            <a href="/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/" rel="tag"># 网络通信</a>
          
            <a href="/tags/TCP/" rel="tag"># TCP</a>
          
            <a href="/tags/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/" rel="tag"># 三次握手</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/linux-kernel-tcp/" rel="next" title="Linux操作系统学习笔记（二十）网络通信之TCP协议">
                <i class="fa fa-chevron-left"></i> Linux操作系统学习笔记（二十）网络通信之TCP协议
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/linux-kernel-tcp-send/" rel="prev" title="Linux操作系统学习笔记（二十二）网络通信之发包">
                Linux操作系统学习笔记（二十二）网络通信之发包 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        
  <div class="bdsharebuttonbox">
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
    <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
    <a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a>
    <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
    <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a class="bds_count" data-cmd="count"></a>
  </div>
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "2",
        "bdMiniList": false,
        "bdPic": ""
      },
      "share": {
        "bdSize": "16",
        "bdStyle": "0"
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/me.JPG"
                alt="Ty Chen" />
            
              <p class="site-author-name" itemprop="name">Ty Chen</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">51</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">82</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Ty-Chen" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:tianyuch@hotmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Friends
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://lishouxian.cn/" title="Stanleylsx" target="_blank">Stanleylsx</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一-前言"><span class="nav-text">一. 前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二-基本过程和API"><span class="nav-text">二. 基本过程和API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三-源码分析"><span class="nav-text">三. 源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-bind"><span class="nav-text">3.1 bind</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-listen"><span class="nav-text">3.2 listen</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3accept"><span class="nav-text">3.3accept</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-connect"><span class="nav-text">3.4 connect</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#源码资料"><span class="nav-text">源码资料</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2020 &mdash; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ty Chen</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">198.8k</span>
  
  <a href="http://www.beian.miit.gov.cn/" target="_blank" rel="noopener">粤ICP备20071543号</a> 
</div>









        
<div class="busuanzi-count">
	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>

  
    <span class="site-uv">
      你是来访的第
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      位同学
    </span>
  

  
    <span class="site-pv">
      访问次数：
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'aTqo2eFkO2Bn0AGX008uKDV7-gzGzoHsz',
        appKey: 'uJ6nxqW7RHWpAILCtttkJfJu',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
