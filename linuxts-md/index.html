<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/kulamati128.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/kulamati32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/kulamati16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="linux,timestamp," />










<meta name="description" content="一. 简介linux的时间戳是一个复杂的系统，本文翻译linux系统内核的说明，并加以解释、附上实际实践的经验代码实例。">
<meta property="og:type" content="article">
<meta property="og:title" content="linux网络编程时间戳详解">
<meta property="og:url" content="https://ty-chen.github.io/linuxts-md/index.html">
<meta property="og:site_name" content="Ty-Chen&#39;s Home">
<meta property="og:description" content="一. 简介linux的时间戳是一个复杂的系统，本文翻译linux系统内核的说明，并加以解释、附上实际实践的经验代码实例。">
<meta property="article:published_time" content="2024-04-18T12:15:19.000Z">
<meta property="article:modified_time" content="2024-07-16T14:34:55.930Z">
<meta property="article:author" content="Ty Chen">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="timestamp">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://ty-chen.github.io/linuxts-md/"/>





  <title>linux网络编程时间戳详解 | Ty-Chen's Home</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ty-Chen's Home</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Collecting, sharing and creating knowledge</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ty-chen.github.io/linuxts-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ty Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty-Chen's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">linux网络编程时间戳详解</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-04-18T20:15:19+08:00">
                2024-04-18
              </time>
            

            

            
          </span>
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2024-07-16T22:34:55+08:00" content="2024-07-16">
                2024-07-16
              </time>
            </span>
          
          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index">
                    <span itemprop="name">编程随笔</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/linuxts-md/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/linuxts-md/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv">访问次数：
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.3k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  25
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一. 简介"></a>一. 简介</h2><p>linux的时间戳是一个复杂的系统，本文翻译linux系统内核的说明，并加以解释、附上实际实践的经验代码实例。</p>
 <a id="more"></a>

<h2 id="二-控制接口"><a href="#二-控制接口" class="headerlink" title="二. 控制接口"></a>二. 控制接口</h2><p>控制接受网络包时间戳的标记有以下三个</p>
<table>
<thead>
<tr>
<th>标记名</th>
<th>用处</th>
<th>精度</th>
</tr>
</thead>
<tbody><tr>
<td>SO_TIMESTAMP</td>
<td>为每个收到的数据包产生系统时间，通过recvmsg()的控制消息发送，仅支持AUDP</td>
<td>微秒</td>
</tr>
<tr>
<td>SO_TIMESTAMPNS</td>
<td>机制与上相同，精度更高</td>
<td>纳秒</td>
</tr>
<tr>
<td>SO_TIMESTAMPING</td>
<td>为每个发出及收到的数据包产生系统时间，支持硬件记录，支持流式套接字</td>
<td>纳秒</td>
</tr>
</tbody></table>
<p>其中最常用的SO_TIMESTAMPING支持多种类型的时间戳请求，因此其套接字选项采取位图标记进行设置，如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err = setsockopt(fd, SOL_SOCKET, SO_TIMESTAMPING, &amp;val, <span class="keyword">sizeof</span>(val));</span><br></pre></td></tr></table></figure>

<p>其中val支持的类型包括以下几种标记</p>
<ul>
<li>时间戳生成标记</li>
<li>时间戳报告标记</li>
<li>其他操作标记</li>
<li>单条消息的设置标记</li>
</ul>
<h3 id="2-1-时间戳生成标记"><a href="#2-1-时间戳生成标记" class="headerlink" title="2.1 时间戳生成标记"></a>2.1 时间戳生成标记</h3><table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SOF_TIMESTAMPING_RX_HARDWARE</td>
<td>获取RX硬件时间戳</td>
</tr>
<tr>
<td>SOF_TIMESTAMPING_RX_SOFTWARE</td>
<td>获取RX软件时间戳，这里的软件时间戳指的是数据刚进入内核接受栈时的时间。</td>
</tr>
<tr>
<td>SOF_TIMESTAMPING_TX_HARDWARE</td>
<td>获取TX硬件时间戳</td>
</tr>
<tr>
<td>SOF_TIMESTAMPING_TX_SOFTWARE</td>
<td>获取TX软件时间戳，这里指的是数据即将离开内核时的时间。</td>
</tr>
<tr>
<td>SOF_TIMESTAMPING_TX_SCHED</td>
<td>获取TX数据包在进入调度队列之前的时间。内核的传输时延，大多数情况下都由于发送的队列延迟（queue delay）导致。因此，结合此标记位和上一个标记位，可以计算出内核处理数据包的耗时情况。而协议处理的耗时，则可以通过用户态时间戳和该时间戳的差值来得到。</td>
</tr>
<tr>
<td>SOF_TIMESTAMPING_TX_ACK</td>
<td>该标记仅对TCP有效，返回的TX时间戳是发送缓冲区所有包都得到ACK的时间。</td>
</tr>
</tbody></table>
<h3 id="2-2-时间戳报告标记"><a href="#2-2-时间戳报告标记" class="headerlink" title="2.2 时间戳报告标记"></a>2.2 时间戳报告标记</h3><p>时间戳的报告标记，指的是被标记上的类型将通过控制消息生成并返回，注意必须要先有生成标记才会产生时间戳，之后有报告标记才会有报告返回。</p>
<ul>
<li><p>SOF_TIMESTAMPING_SOFTWARE:</p>
<p>报告软件时间戳</p>
</li>
<li><p>SOF_TIMESTAMPING_SYS_HARDWARE:</p>
<p>已废弃</p>
</li>
<li><p>SOF_TIMESTAMPING_RAW_HARDWARE:</p>
<p>报告硬件时间戳</p>
</li>
</ul>
<h3 id="2-3-其他操作标记"><a href="#2-3-其他操作标记" class="headerlink" title="2.3 其他操作标记"></a>2.3 其他操作标记</h3><table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SOF_TIMESTAMPING_OPT_ID</td>
<td>对每一个数据包生成唯一ID。由于进程可以并行的发送多个时间戳请求、并且数据包在传输过程中可能存在乱序，所以错误队列中读到的数据包的顺序可能和send()调用时不一致。该选项可以将每个包和时间戳一一对应起来。该ID采用  u32 回环计数。该计数位于sock_extended_err 结构体中的 ee_data。</td>
</tr>
<tr>
<td>SOF_TIMESTAMPING_OPT_ID_TCP</td>
<td>该标记仅对TCP生效，对UDP无影响。</td>
</tr>
<tr>
<td>SOF_TIMESTAMPING_OPT_CMSG</td>
<td>和IP_PKTINFO同时使用，关联数据包和网卡设备，并使得recv()支持接受/发送函数的时间戳功能。</td>
</tr>
<tr>
<td>SOF_TIMESTAMPING_OPT_TSONLY</td>
<td>Applies to transmit timestamps only. Makes the kernel return the timestamp as a cmsg alongside an empty packet, as opposed to alongside the original packet. This reduces the amount of memory charged to the socket’s receive budget (SO_RCVBUF) and delivers the timestamp even if sysctl net.core.tstamp_allow_data is 0. This option disables SOF_TIMESTAMPING_OPT_CMSG</td>
</tr>
<tr>
<td>SOF_TIMESTAMPING_OPT_STATS</td>
<td>Optional stats that are obtained along with the transmit timestamps. It must be used together with SOF_TIMESTAMPING_OPT_TSONLY. When the transmit timestamp is available, the stats are available in a separate control message of type SCM_TIMESTAMPING_OPT_STATS, as a list of TLVs (struct nlattr) of types. These stats allow the application to associate various transport layer stats with the transmit timestamps, such as how long a certain block of data was limited by peer’s receiver window.</td>
</tr>
<tr>
<td>SOF_TIMESTAMPING_OPT_PKTINFO</td>
<td>Enable the SCM_TIMESTAMPING_PKTINFO control message for incoming packets with hardware timestamps. The message contains struct scm_ts_pktinfo, which supplies the index of the real interface which received the packet and its length at layer 2. A valid (non-zero) interface index will be returned only if CONFIG_NET_RX_BUSY_POLL is enabled and the driver is using NAPI. The struct contains also two other fields, but they are reserved and undefined</td>
</tr>
<tr>
<td>SOF_TIMESTAMPING_OPT_TX_SWHW</td>
<td>Request both hardware and software timestamps for outgoing packets when SOF_TIMESTAMPING_TX_HARDWARE and SOF_TIMESTAMPING_TX_SOFTWARE are enabled at the same time. If both timestamps are generated, two separate messages will be looped to the socket’s error queue, each containing just one timestamp</td>
</tr>
</tbody></table>
<p>New applications are encouraged to pass SOF_TIMESTAMPING_OPT_ID to disambiguate timestamps and SOF_TIMESTAMPING_OPT_TSONLY to operate regardless of the setting of sysctl net.core.tstamp_allow_data.</p>
<p>An exception is when a process needs additional cmsg data, for instance SOL_IP/IP_PKTINFO to detect the egress network interface. Then pass option SOF_TIMESTAMPING_OPT_CMSG. This option depends on having access to the contents of the original packet, so cannot be combined with SOF_TIMESTAMPING_OPT_TSONLY.</p>
<h3 id="2-4-单条消息的设置标记"><a href="#2-4-单条消息的设置标记" class="headerlink" title="2.4 单条消息的设置标记"></a>2.4 单条消息的设置标记</h3><h4 id="1-3-4-Enabling-timestamps-via-control-messages"><a href="#1-3-4-Enabling-timestamps-via-control-messages" class="headerlink" title="1.3.4. Enabling timestamps via control messages"></a>1.3.4. Enabling timestamps via control messages</h4><p>In addition to socket options, timestamp generation can be requested per write via cmsg, only for SOF_TIMESTAMPING_TX_* (see Section 1.3.1). Using this feature, applications can sample timestamps per sendmsg() without paying the overhead of enabling and disabling timestamps via setsockopt:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct msghdr *msg;</span><br><span class="line">...</span><br><span class="line">cmsg                         &#x3D; CMSG_FIRSTHDR(msg);</span><br><span class="line">cmsg-&gt;cmsg_level             &#x3D; SOL_SOCKET;</span><br><span class="line">cmsg-&gt;cmsg_type              &#x3D; SO_TIMESTAMPING;</span><br><span class="line">cmsg-&gt;cmsg_len               &#x3D; CMSG_LEN(sizeof(__u32));</span><br><span class="line">*((__u32 *) CMSG_DATA(cmsg)) &#x3D; SOF_TIMESTAMPING_TX_SCHED |</span><br><span class="line">                               SOF_TIMESTAMPING_TX_SOFTWARE |</span><br><span class="line">                               SOF_TIMESTAMPING_TX_ACK;</span><br><span class="line">err &#x3D; sendmsg(fd, msg, 0);</span><br></pre></td></tr></table></figure>

<p>The SOF_TIMESTAMPING_TX_* flags set via cmsg will override the SOF_TIMESTAMPING_TX_* flags set via setsockopt.</p>
<p>Moreover, applications must still enable timestamp reporting via setsockopt to receive timestamps:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__u32 val &#x3D; SOF_TIMESTAMPING_SOFTWARE |</span><br><span class="line">            SOF_TIMESTAMPING_OPT_ID &#x2F;* or any other flag *&#x2F;;</span><br><span class="line">err &#x3D; setsockopt(fd, SOL_SOCKET, SO_TIMESTAMPING, &amp;val, sizeof(val));</span><br></pre></td></tr></table></figure>



<h2 id="三-数据接口"><a href="#三-数据接口" class="headerlink" title="三. 数据接口"></a>三. 数据接口</h2><h2 id="四-硬件时间戳配置"><a href="#四-硬件时间戳配置" class="headerlink" title="四. 硬件时间戳配置"></a>四. 硬件时间戳配置</h2><h2 id="2-Data-Interfaces"><a href="#2-Data-Interfaces" class="headerlink" title="2 Data Interfaces"></a>2 Data Interfaces</h2><p>Timestamps are read using the ancillary data feature of recvmsg(). See man 3 cmsg for details of this interface. The socket manual page (man 7 socket) describes how timestamps generated with SO_TIMESTAMP and SO_TIMESTAMPNS records can be retrieved.</p>
<h3 id="2-1-SCM-TIMESTAMPING-records"><a href="#2-1-SCM-TIMESTAMPING-records" class="headerlink" title="2.1 SCM_TIMESTAMPING records"></a>2.1 SCM_TIMESTAMPING records</h3><p>These timestamps are returned in a control message with cmsg_level SOL_SOCKET, cmsg_type SCM_TIMESTAMPING, and payload of type</p>
<p>For SO_TIMESTAMPING_OLD:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct scm_timestamping &#123;</span><br><span class="line">        struct timespec ts[3];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>For SO_TIMESTAMPING_NEW:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct scm_timestamping64 &#123;</span><br><span class="line">        struct __kernel_timespec ts[3];</span><br></pre></td></tr></table></figure>

<p>Always use SO_TIMESTAMPING_NEW timestamp to always get timestamp in struct scm_timestamping64 format.</p>
<p>SO_TIMESTAMPING_OLD returns incorrect timestamps after the year 2038 on 32 bit machines.</p>
<p>The structure can return up to three timestamps. This is a legacy feature. At least one field is non-zero at any time. Most timestamps are passed in ts[0]. Hardware timestamps are passed in ts[2].</p>
<p>ts[1] used to hold hardware timestamps converted to system time. Instead, expose the hardware clock device on the NIC directly as a HW PTP clock source, to allow time conversion in userspace and optionally synchronize system time with a userspace PTP stack such as linuxptp. For the PTP clock API, see <a href="https://www.kernel.org/doc/html/next/driver-api/ptp.html" target="_blank" rel="noopener">PTP hardware clock infrastructure for Linux</a>.</p>
<p>Note that if the SO_TIMESTAMP or SO_TIMESTAMPNS option is enabled together with SO_TIMESTAMPING using SOF_TIMESTAMPING_SOFTWARE, a false software timestamp will be generated in the recvmsg() call and passed in ts[0] when a real software timestamp is missing. This happens also on hardware transmit timestamps.</p>
<h4 id="2-1-1-Transmit-timestamps-with-MSG-ERRQUEUE"><a href="#2-1-1-Transmit-timestamps-with-MSG-ERRQUEUE" class="headerlink" title="2.1.1 Transmit timestamps with MSG_ERRQUEUE"></a>2.1.1 Transmit timestamps with MSG_ERRQUEUE</h4><p>For transmit timestamps the outgoing packet is looped back to the socket’s error queue with the send timestamp(s) attached. A process receives the timestamps by calling recvmsg() with flag MSG_ERRQUEUE set and with a msg_control buffer sufficiently large to receive the relevant metadata structures. The recvmsg call returns the original outgoing data packet with two ancillary messages attached.</p>
<p>A message of cm_level SOL_IP(V6) and cm_type IP(V6)_RECVERR embeds a struct sock_extended_err. This defines the error type. For timestamps, the ee_errno field is ENOMSG. The other ancillary message will have cm_level SOL_SOCKET and cm_type SCM_TIMESTAMPING. This embeds the struct scm_timestamping.</p>
<h5 id="2-1-1-2-Timestamp-types"><a href="#2-1-1-2-Timestamp-types" class="headerlink" title="2.1.1.2 Timestamp types"></a>2.1.1.2 Timestamp types</h5><p>The semantics of the three struct timespec are defined by field ee_info in the extended error structure. It contains a value of type SCM_TSTAMP_* to define the actual timestamp passed in scm_timestamping.</p>
<p>The SCM_TSTAMP_* types are 1:1 matches to the SOF_TIMESTAMPING_* control fields discussed previously, with one exception. For legacy reasons, SCM_TSTAMP_SND is equal to zero and can be set for both SOF_TIMESTAMPING_TX_HARDWARE and SOF_TIMESTAMPING_TX_SOFTWARE. It is the first if ts[2] is non-zero, the second otherwise, in which case the timestamp is stored in ts[0].</p>
<h5 id="2-1-1-3-Fragmentation"><a href="#2-1-1-3-Fragmentation" class="headerlink" title="2.1.1.3 Fragmentation"></a>2.1.1.3 Fragmentation</h5><p>Fragmentation of outgoing datagrams is rare, but is possible, e.g., by explicitly disabling PMTU discovery. If an outgoing packet is fragmented, then only the first fragment is timestamped and returned to the sending socket.</p>
<h5 id="2-1-1-4-Packet-Payload"><a href="#2-1-1-4-Packet-Payload" class="headerlink" title="2.1.1.4 Packet Payload"></a>2.1.1.4 Packet Payload</h5><p>The calling application is often not interested in receiving the whole packet payload that it passed to the stack originally: the socket error queue mechanism is just a method to piggyback the timestamp on. In this case, the application can choose to read datagrams with a smaller buffer, possibly even of length 0. The payload is truncated accordingly. Until the process calls recvmsg() on the error queue, however, the full packet is queued, taking up budget from SO_RCVBUF.</p>
<h5 id="2-1-1-5-Blocking-Read"><a href="#2-1-1-5-Blocking-Read" class="headerlink" title="2.1.1.5 Blocking Read"></a>2.1.1.5 Blocking Read</h5><p>Reading from the error queue is always a non-blocking operation. To block waiting on a timestamp, use poll or select. poll() will return POLLERR in pollfd.revents if any data is ready on the error queue. There is no need to pass this flag in pollfd.events. This flag is ignored on request. See also man 2 poll.</p>
<h4 id="2-1-2-Receive-timestamps"><a href="#2-1-2-Receive-timestamps" class="headerlink" title="2.1.2 Receive timestamps"></a>2.1.2 Receive timestamps</h4><p>On reception, there is no reason to read from the socket error queue. The SCM_TIMESTAMPING ancillary data is sent along with the packet data on a normal recvmsg(). Since this is not a socket error, it is not accompanied by a message SOL_IP(V6)/IP(V6)_RECVERROR. In this case, the meaning of the three fields in struct scm_timestamping is implicitly defined. ts[0] holds a software timestamp if set, ts[1] is again deprecated and ts[2] holds a hardware timestamp if set.</p>
<h2 id="3-Hardware-Timestamping-configuration-SIOCSHWTSTAMP-and-SIOCGHWTSTAMP"><a href="#3-Hardware-Timestamping-configuration-SIOCSHWTSTAMP-and-SIOCGHWTSTAMP" class="headerlink" title="3. Hardware Timestamping configuration: SIOCSHWTSTAMP and SIOCGHWTSTAMP"></a>3. Hardware Timestamping configuration: SIOCSHWTSTAMP and SIOCGHWTSTAMP</h2><p>Hardware time stamping must also be initialized for each device driver that is expected to do hardware time stamping. The parameter is defined in include/uapi/linux/net_tstamp.h as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct hwtstamp_config &#123;</span><br><span class="line">        int flags;      &#x2F;* no flags defined right now, must be zero *&#x2F;</span><br><span class="line">        int tx_type;    &#x2F;* HWTSTAMP_TX_* *&#x2F;</span><br><span class="line">        int rx_filter;  &#x2F;* HWTSTAMP_FILTER_* *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Desired behavior is passed into the kernel and to a specific device by calling ioctl(SIOCSHWTSTAMP) with a pointer to a struct ifreq whose ifr_data points to a struct hwtstamp_config. The tx_type and rx_filter are hints to the driver what it is expected to do. If the requested fine-grained filtering for incoming packets is not supported, the driver may time stamp more than just the requested types of packets.</p>
<p>Drivers are free to use a more permissive configuration than the requested configuration. It is expected that drivers should only implement directly the most generic mode that can be supported. For example if the hardware can support HWTSTAMP_FILTER_PTP_V2_EVENT, then it should generally always upscale HWTSTAMP_FILTER_PTP_V2_L2_SYNC, and so forth, as HWTSTAMP_FILTER_PTP_V2_EVENT is more generic (and more useful to applications).</p>
<p>A driver which supports hardware time stamping shall update the struct with the actual, possibly more permissive configuration. If the requested packets cannot be time stamped, then nothing should be changed and ERANGE shall be returned (in contrast to EINVAL, which indicates that SIOCSHWTSTAMP is not supported at all).</p>
<p>Only a processes with admin rights may change the configuration. User space is responsible to ensure that multiple processes don’t interfere with each other and that the settings are reset.</p>
<p>Any process can read the actual configuration by passing this structure to ioctl(SIOCGHWTSTAMP) in the same way. However, this has not been implemented in all drivers.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* possible values for hwtstamp_config-&gt;tx_type *&#x2F;</span><br><span class="line">enum &#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">        * no outgoing packet will need hardware time stamping;</span><br><span class="line">        * should a packet arrive which asks for it, no hardware</span><br><span class="line">        * time stamping will be done</span><br><span class="line">        *&#x2F;</span><br><span class="line">        HWTSTAMP_TX_OFF,</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">        * enables hardware time stamping for outgoing packets;</span><br><span class="line">        * the sender of the packet decides which are to be</span><br><span class="line">        * time stamped by setting SOF_TIMESTAMPING_TX_SOFTWARE</span><br><span class="line">        * before sending the packet</span><br><span class="line">        *&#x2F;</span><br><span class="line">        HWTSTAMP_TX_ON,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* possible values for hwtstamp_config-&gt;rx_filter *&#x2F;</span><br><span class="line">enum &#123;</span><br><span class="line">        &#x2F;* time stamp no incoming packet at all *&#x2F;</span><br><span class="line">        HWTSTAMP_FILTER_NONE,</span><br><span class="line"></span><br><span class="line">        &#x2F;* time stamp any incoming packet *&#x2F;</span><br><span class="line">        HWTSTAMP_FILTER_ALL,</span><br><span class="line"></span><br><span class="line">        &#x2F;* return value: time stamp all packets requested plus some others *&#x2F;</span><br><span class="line">        HWTSTAMP_FILTER_SOME,</span><br><span class="line"></span><br><span class="line">        &#x2F;* PTP v1, UDP, any kind of event packet *&#x2F;</span><br><span class="line">        HWTSTAMP_FILTER_PTP_V1_L4_EVENT,</span><br><span class="line"></span><br><span class="line">        &#x2F;* for the complete list of values, please check</span><br><span class="line">        * the include file include&#x2F;uapi&#x2F;linux&#x2F;net_tstamp.h</span><br><span class="line">        *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-Hardware-Timestamping-Implementation-Device-Drivers"><a href="#3-1-Hardware-Timestamping-Implementation-Device-Drivers" class="headerlink" title="3.1 Hardware Timestamping Implementation: Device Drivers"></a>3.1 Hardware Timestamping Implementation: Device Drivers</h3><p>A driver which supports hardware time stamping must support the SIOCSHWTSTAMP ioctl and update the supplied struct hwtstamp_config with the actual values as described in the section on SIOCSHWTSTAMP. It should also support SIOCGHWTSTAMP.</p>
<p>Time stamps for received packets must be stored in the skb. To get a pointer to the shared time stamp structure of the skb call skb_hwtstamps(). Then set the time stamps in the structure:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct skb_shared_hwtstamps &#123;</span><br><span class="line">        &#x2F;* hardware time stamp transformed into duration</span><br><span class="line">        * since arbitrary point in time</span><br><span class="line">        *&#x2F;</span><br><span class="line">        ktime_t     hwtstamp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Time stamps for outgoing packets are to be generated as follows:</p>
<ul>
<li><p>In hard_start_xmit(), check if (skb_shinfo(skb)-&gt;tx_flags &amp; SKBTX_HW_TSTAMP) is set no-zero. If yes, then the driver is expected to do hardware time stamping.</p>
</li>
<li><p>If this is possible for the skb and requested, then declare that the driver is doing the time stamping by setting the flag SKBTX_IN_PROGRESS in skb_shinfo(skb)-&gt;tx_flags , e.g. with:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skb_shinfo(skb)-&gt;tx_flags |&#x3D; SKBTX_IN_PROGRESS;</span><br></pre></td></tr></table></figure>

<p>You might want to keep a pointer to the associated skb for the next step and not free the skb. A driver not supporting hardware time stamping doesn’t do that. A driver must never touch sk_buff::tstamp! It is used to store software generated time stamps by the network subsystem.</p>
</li>
<li><p>Driver should call <a href="https://www.kernel.org/doc/html/next/networking/kapi.html#c.skb_tx_timestamp" target="_blank" rel="noopener"><code>skb_tx_timestamp()</code></a> as close to passing sk_buff to hardware as possible. <a href="https://www.kernel.org/doc/html/next/networking/kapi.html#c.skb_tx_timestamp" target="_blank" rel="noopener"><code>skb_tx_timestamp()</code></a> provides a software time stamp if requested and hardware timestamping is not possible (SKBTX_IN_PROGRESS not set).</p>
</li>
<li><p>As soon as the driver has sent the packet and/or obtained a hardware time stamp for it, it passes the time stamp back by calling <a href="https://www.kernel.org/doc/html/next/networking/kapi.html#c.skb_tstamp_tx" target="_blank" rel="noopener"><code>skb_tstamp_tx()</code></a> with the original skb, the raw hardware time stamp. <a href="https://www.kernel.org/doc/html/next/networking/kapi.html#c.skb_tstamp_tx" target="_blank" rel="noopener"><code>skb_tstamp_tx()</code></a> clones the original skb and adds the timestamps, therefore the original skb has to be freed now. If obtaining the hardware time stamp somehow fails, then the driver should not fall back to software time stamping. The rationale is that this would occur at a later time in the processing pipeline than other software time stamping and therefore could lead to unexpected deltas between time stamps.</p>
</li>
</ul>
<h3 id="3-2-Special-considerations-for-stacked-PTP-Hardware-Clocks"><a href="#3-2-Special-considerations-for-stacked-PTP-Hardware-Clocks" class="headerlink" title="3.2 Special considerations for stacked PTP Hardware Clocks"></a>3.2 Special considerations for stacked PTP Hardware Clocks</h3><p>There are situations when there may be more than one PHC (PTP Hardware Clock) in the data path of a packet. The kernel has no explicit mechanism to allow the user to select which PHC to use for timestamping Ethernet frames. Instead, the assumption is that the outermost PHC is always the most preferable, and that kernel drivers collaborate towards achieving that goal. Currently there are 3 cases of stacked PHCs, detailed below:</p>
<h4 id="3-2-1-DSA-Distributed-Switch-Architecture-switches"><a href="#3-2-1-DSA-Distributed-Switch-Architecture-switches" class="headerlink" title="3.2.1 DSA (Distributed Switch Architecture) switches"></a>3.2.1 DSA (Distributed Switch Architecture) switches</h4><p>These are Ethernet switches which have one of their ports connected to an (otherwise completely unaware) host Ethernet interface, and perform the role of a port multiplier with optional forwarding acceleration features. Each DSA switch port is visible to the user as a standalone (virtual) network interface, and its network I/O is performed, under the hood, indirectly through the host interface (redirecting to the host port on TX, and intercepting frames on RX).</p>
<p>When a DSA switch is attached to a host port, PTP synchronization has to suffer, since the switch’s variable queuing delay introduces a path delay jitter between the host port and its PTP partner. For this reason, some DSA switches include a timestamping clock of their own, and have the ability to perform network timestamping on their own MAC, such that path delays only measure wire and PHY propagation latencies. Timestamping DSA switches are supported in Linux and expose the same ABI as any other network interface (save for the fact that the DSA interfaces are in fact virtual in terms of network I/O, they do have their own PHC). It is typical, but not mandatory, for all interfaces of a DSA switch to share the same PHC.</p>
<p>By design, PTP timestamping with a DSA switch does not need any special handling in the driver for the host port it is attached to. However, when the host port also supports PTP timestamping, DSA will take care of intercepting the <code>.ndo_eth_ioctl</code> calls towards the host port, and block attempts to enable hardware timestamping on it. This is because the SO_TIMESTAMPING API does not allow the delivery of multiple hardware timestamps for the same packet, so anybody else except for the DSA switch port must be prevented from doing so.</p>
<p>In the generic layer, DSA provides the following infrastructure for PTP timestamping:</p>
<ul>
<li><code>.port_txtstamp()</code>: a hook called prior to the transmission of packets with a hardware TX timestamping request from user space. This is required for two-step timestamping, since the hardware timestamp becomes available after the actual MAC transmission, so the driver must be prepared to correlate the timestamp with the original packet so that it can re-enqueue the packet back into the socket’s error queue. To save the packet for when the timestamp becomes available, the driver can call <code>skb_clone_sk</code> , save the clone pointer in skb-&gt;cb and enqueue a tx skb queue. Typically, a switch will have a PTP TX timestamp register (or sometimes a FIFO) where the timestamp becomes available. In case of a FIFO, the hardware might store key-value pairs of PTP sequence ID/message type/domain number and the actual timestamp. To perform the correlation correctly between the packets in a queue waiting for timestamping and the actual timestamps, drivers can use a BPF classifier (<code>ptp_classify_raw</code>) to identify the PTP transport type, and <code>ptp_parse_header</code> to interpret the PTP header fields. There may be an IRQ that is raised upon this timestamp’s availability, or the driver might have to poll after invoking <code>dev_queue_xmit()</code> towards the host interface. One-step TX timestamping do not require packet cloning, since there is no follow-up message required by the PTP protocol (because the TX timestamp is embedded into the packet by the MAC), and therefore user space does not expect the packet annotated with the TX timestamp to be re-enqueued into its socket’s error queue.</li>
<li><code>.port_rxtstamp()</code>: On RX, the BPF classifier is run by DSA to identify PTP event messages (any other packets, including PTP general messages, are not timestamped). The original (and only) timestampable skb is provided to the driver, for it to annotate it with a timestamp, if that is immediately available, or defer to later. On reception, timestamps might either be available in-band (through metadata in the DSA header, or attached in other ways to the packet), or out-of-band (through another RX timestamping FIFO). Deferral on RX is typically necessary when retrieving the timestamp needs a sleepable context. In that case, it is the responsibility of the DSA driver to call <code>netif_rx()</code> on the freshly timestamped skb.</li>
</ul>
<h4 id="3-2-2-Ethernet-PHYs"><a href="#3-2-2-Ethernet-PHYs" class="headerlink" title="3.2.2 Ethernet PHYs"></a>3.2.2 Ethernet PHYs</h4><p>These are devices that typically fulfill a Layer 1 role in the network stack, hence they do not have a representation in terms of a network interface as DSA switches do. However, PHYs may be able to detect and timestamp PTP packets, for performance reasons: timestamps taken as close as possible to the wire have the potential to yield a more stable and precise synchronization.</p>
<p>A PHY driver that supports PTP timestamping must create a <code>struct mii_timestamper</code> and add a pointer to it in <code>phydev-&gt;mii_ts</code>. The presence of this pointer will be checked by the networking stack.</p>
<p>Since PHYs do not have network interface representations, the timestamping and ethtool ioctl operations for them need to be mediated by their respective MAC driver. Therefore, as opposed to DSA switches, modifications need to be done to each individual MAC driver for PHY timestamping support. This entails:</p>
<ul>
<li><p>Checking, in <code>.ndo_eth_ioctl</code>, whether <code>phy_has_hwtstamp(netdev-&gt;phydev)</code> is true or not. If it is, then the MAC driver should not process this request but instead pass it on to the PHY using <code>phy_mii_ioctl()</code>.</p>
</li>
<li><p>On RX, special intervention may or may not be needed, depending on the function used to deliver skb’s up the network stack. In the case of plain <code>netif_rx()</code> and similar, MAC drivers must check whether <code>skb_defer_rx_timestamp(skb)</code> is necessary or not - and if it is, don’t call <code>netif_rx()</code> at all. If <code>CONFIG_NETWORK_PHY_TIMESTAMPING</code> is enabled, and <code>skb-&gt;dev-&gt;phydev-&gt;mii_ts</code> exists, its <code>.rxtstamp()</code> hook will be called now, to determine, using logic very similar to DSA, whether deferral for RX timestamping is necessary. Again like DSA, it becomes the responsibility of the PHY driver to send the packet up the stack when the timestamp is available.</p>
<p>For other skb receive functions, such as <code>napi_gro_receive</code> and <code>netif_receive_skb</code>, the stack automatically checks whether <code>skb_defer_rx_timestamp()</code> is necessary, so this check is not needed inside the driver.</p>
</li>
<li><p>On TX, again, special intervention might or might not be needed. The function that calls the <code>mii_ts-&gt;txtstamp()</code> hook is named <code>skb_clone_tx_timestamp()</code>. This function can either be called directly (case in which explicit MAC driver support is indeed needed), but the function also piggybacks from the <code>skb_tx_timestamp()</code> call, which many MAC drivers already perform for software timestamping purposes. Therefore, if a MAC supports software timestamping, it does not need to do anything further at this stage.</p>
</li>
</ul>
<h4 id="3-2-3-MII-bus-snooping-devices"><a href="#3-2-3-MII-bus-snooping-devices" class="headerlink" title="3.2.3 MII bus snooping devices"></a>3.2.3 MII bus snooping devices</h4><p>These perform the same role as timestamping Ethernet PHYs, save for the fact that they are discrete devices and can therefore be used in conjunction with any PHY even if it doesn’t support timestamping. In Linux, they are discoverable and attachable to a <code>struct phy_device</code> through Device Tree, and for the rest, they use the same mii_ts infrastructure as those. See Documentation/devicetree/bindings/ptp/timestamper.txt for more details.</p>
<h4 id="3-2-4-Other-caveats-for-MAC-drivers"><a href="#3-2-4-Other-caveats-for-MAC-drivers" class="headerlink" title="3.2.4 Other caveats for MAC drivers"></a>3.2.4 Other caveats for MAC drivers</h4><p>Stacked PHCs, especially DSA (but not only) - since that doesn’t require any modification to MAC drivers, so it is more difficult to ensure correctness of all possible code paths - is that they uncover bugs which were impossible to trigger before the existence of stacked PTP clocks. One example has to do with this line of code, already presented earlier:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skb_shinfo(skb)-&gt;tx_flags |&#x3D; SKBTX_IN_PROGRESS;</span><br></pre></td></tr></table></figure>

<p>Any TX timestamping logic, be it a plain MAC driver, a DSA switch driver, a PHY driver or a MII bus snooping device driver, should set this flag. But a MAC driver that is unaware of PHC stacking might get tripped up by somebody other than itself setting this flag, and deliver a duplicate timestamp. For example, a typical driver design for TX timestamping might be to split the transmission part into 2 portions:</p>
<ol>
<li>“TX”: checks whether PTP timestamping has been previously enabled through the <code>.ndo_eth_ioctl</code> (“<code>priv-&gt;hwtstamp_tx_enabled == true</code>“) and the current skb requires a TX timestamp (“<code>skb_shinfo(skb)-&gt;tx_flags &amp; SKBTX_HW_TSTAMP</code>“). If this is true, it sets the “<code>skb_shinfo(skb)-&gt;tx_flags |= SKBTX_IN_PROGRESS</code>“ flag. Note: as described above, in the case of a stacked PHC system, this condition should never trigger, as this MAC is certainly not the outermost PHC. But this is not where the typical issue is. Transmission proceeds with this packet.</li>
<li>“TX confirmation”: Transmission has finished. The driver checks whether it is necessary to collect any TX timestamp for it. Here is where the typical issues are: the MAC driver takes a shortcut and only checks whether “<code>skb_shinfo(skb)-&gt;tx_flags &amp; SKBTX_IN_PROGRESS</code>“ was set. With a stacked PHC system, this is incorrect because this MAC driver is not the only entity in the TX data path who could have enabled SKBTX_IN_PROGRESS in the first place.</li>
</ol>
<p>The correct solution for this problem is for MAC drivers to have a compound check in their “TX confirmation” portion, not only for “<code>skb_shinfo(skb)-&gt;tx_flags &amp; SKBTX_IN_PROGRESS</code>“, but also for “<code>priv-&gt;hwtstamp_tx_enabled == true</code>“. Because the rest of the system ensures that PTP timestamping is not enabled for anything other than the outermost PHC, this enhanced check will avoid delivering a duplicated TX timestamp to user space.</p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创，坚持分享，谢谢鼓励和支持</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="Ty Chen 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="Ty Chen 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Ty Chen
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://ty-chen.github.io/linuxts-md/" title="linux网络编程时间戳详解">https://ty-chen.github.io/linuxts-md/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/linux/" rel="tag"># linux</a>
          
            <a href="/tags/timestamp/" rel="tag"># timestamp</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/ptp/" rel="next" title="ptp协议分析">
                <i class="fa fa-chevron-left"></i> ptp协议分析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/onload-functionality-md/" rel="prev" title="Onload手册学习（一）基本功能说明">
                Onload手册学习（一）基本功能说明 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        
  <div class="bdsharebuttonbox">
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
    <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
    <a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a>
    <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
    <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a class="bds_count" data-cmd="count"></a>
  </div>
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "2",
        "bdMiniList": false,
        "bdPic": ""
      },
      "share": {
        "bdSize": "16",
        "bdStyle": "0"
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/me.JPG"
                alt="Ty Chen" />
            
              <p class="site-author-name" itemprop="name">Ty Chen</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">54</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">87</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Ty-Chen" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:tianyuch@hotmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Friends
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://lishouxian.cn/" title="Stanleylsx" target="_blank">Stanleylsx</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一-简介"><span class="nav-text">一. 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二-控制接口"><span class="nav-text">二. 控制接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-时间戳生成标记"><span class="nav-text">2.1 时间戳生成标记</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-时间戳报告标记"><span class="nav-text">2.2 时间戳报告标记</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-其他操作标记"><span class="nav-text">2.3 其他操作标记</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-单条消息的设置标记"><span class="nav-text">2.4 单条消息的设置标记</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-4-Enabling-timestamps-via-control-messages"><span class="nav-text">1.3.4. Enabling timestamps via control messages</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三-数据接口"><span class="nav-text">三. 数据接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四-硬件时间戳配置"><span class="nav-text">四. 硬件时间戳配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Data-Interfaces"><span class="nav-text">2 Data Interfaces</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-SCM-TIMESTAMPING-records"><span class="nav-text">2.1 SCM_TIMESTAMPING records</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-Transmit-timestamps-with-MSG-ERRQUEUE"><span class="nav-text">2.1.1 Transmit timestamps with MSG_ERRQUEUE</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-1-2-Timestamp-types"><span class="nav-text">2.1.1.2 Timestamp types</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-1-3-Fragmentation"><span class="nav-text">2.1.1.3 Fragmentation</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-1-4-Packet-Payload"><span class="nav-text">2.1.1.4 Packet Payload</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-1-5-Blocking-Read"><span class="nav-text">2.1.1.5 Blocking Read</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-Receive-timestamps"><span class="nav-text">2.1.2 Receive timestamps</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Hardware-Timestamping-configuration-SIOCSHWTSTAMP-and-SIOCGHWTSTAMP"><span class="nav-text">3. Hardware Timestamping configuration: SIOCSHWTSTAMP and SIOCGHWTSTAMP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-Hardware-Timestamping-Implementation-Device-Drivers"><span class="nav-text">3.1 Hardware Timestamping Implementation: Device Drivers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-Special-considerations-for-stacked-PTP-Hardware-Clocks"><span class="nav-text">3.2 Special considerations for stacked PTP Hardware Clocks</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-DSA-Distributed-Switch-Architecture-switches"><span class="nav-text">3.2.1 DSA (Distributed Switch Architecture) switches</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-Ethernet-PHYs"><span class="nav-text">3.2.2 Ethernet PHYs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-MII-bus-snooping-devices"><span class="nav-text">3.2.3 MII bus snooping devices</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-4-Other-caveats-for-MAC-drivers"><span class="nav-text">3.2.4 Other caveats for MAC drivers</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2020 &mdash; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ty Chen</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">207.3k</span>
  
  <a href="http://www.beian.miit.gov.cn/" target="_blank" rel="noopener">粤ICP备20071543号</a> 
</div>









        
<div class="busuanzi-count">
	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>

  
    <span class="site-uv">
      你是来访的第
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      位同学
    </span>
  

  
    <span class="site-pv">
      访问次数：
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'aTqo2eFkO2Bn0AGX008uKDV7-gzGzoHsz',
        appKey: 'uJ6nxqW7RHWpAILCtttkJfJu',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
