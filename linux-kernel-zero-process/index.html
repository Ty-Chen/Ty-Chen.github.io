<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/kulamati128.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/kulamati32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/kulamati16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Linux,操作系统,start_kernel,0号进程,1号进程,2号进程," />










<meta name="description" content="一. 前言&amp;emsp;&amp;emsp;前文分析到Linux内核正式启动，完成了实模式到保护模式的切换，并做好了各种准备工作。下来就要看开始内核初始化工作了，源码位置位于init&#x2F;main.c中的start_kernel()，源码如附录所示。这包括了一系列重要的初始化工作，本文会介绍其中一部分较为重要的，但是详细的介绍依然会留在后文各个模块的源码学习中单独进行。本文的目的在于承接上文给出一个从内核启动到">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux操作系统学习笔记（三）内核初始化">
<meta property="og:url" content="https://ty-chen.github.io/linux-kernel-zero-process/index.html">
<meta property="og:site_name" content="Ty-Chen&#39;s Home">
<meta property="og:description" content="一. 前言&amp;emsp;&amp;emsp;前文分析到Linux内核正式启动，完成了实模式到保护模式的切换，并做好了各种准备工作。下来就要看开始内核初始化工作了，源码位置位于init&#x2F;main.c中的start_kernel()，源码如附录所示。这包括了一系列重要的初始化工作，本文会介绍其中一部分较为重要的，但是详细的介绍依然会留在后文各个模块的源码学习中单独进行。本文的目的在于承接上文给出一个从内核启动到">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/2b/42/2b53b470673cde8f9d8e2573f7d07242.jpg">
<meta property="article:published_time" content="2020-05-05T14:46:22.000Z">
<meta property="article:modified_time" content="2020-07-18T05:56:57.581Z">
<meta property="article:author" content="Ty Chen">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="start_kernel">
<meta property="article:tag" content="0号进程">
<meta property="article:tag" content="1号进程">
<meta property="article:tag" content="2号进程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://static001.geekbang.org/resource/image/2b/42/2b53b470673cde8f9d8e2573f7d07242.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://ty-chen.github.io/linux-kernel-zero-process/"/>





  <title>Linux操作系统学习笔记（三）内核初始化 | Ty-Chen's Home</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ty-Chen's Home</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Collecting, sharing and creating knowledge</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ty-chen.github.io/linux-kernel-zero-process/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ty Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty-Chen's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Linux操作系统学习笔记（三）内核初始化</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-05T22:46:22+08:00">
                2020-05-05
              </time>
            

            

            
          </span>
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2020-07-18T13:56:57+08:00" content="2020-07-18">
                2020-07-18
              </time>
            </span>
          
          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index">
                    <span itemprop="name">Linux操作系统内核学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/linux-kernel-zero-process/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/linux-kernel-zero-process/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv">访问次数：
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  16
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h2><p>&emsp;&emsp;前文分析到Linux内核正式启动，完成了实模式到保护模式的切换，并做好了各种准备工作。下来就要看开始内核初始化工作了，源码位置位于init/main.c中的<code>start_kernel()</code>，源码如附录所示。这包括了一系列重要的初始化工作，本文会介绍其中一部分较为重要的，但是详细的介绍依然会留在后文各个模块的源码学习中单独进行。本文的目的在于承接上文给出一个从内核启动到各个模块开始运转的过程介绍，而不是详细的各部分内容介绍。</p>
<ul>
<li><p>创建0号进程：<code>INIT_TASK(init_task)</code></p>
</li>
<li><p>异常处理类中断服务程序挂接：<code>trap_init()</code></p>
</li>
<li><p>内存初始化：<code>mm_init()</code></p>
</li>
<li><p>调度器初始化<code>sched_init()</code></p>
</li>
<li><p>剩余初始化：<code>rest_init()</code></p>
<a id="more"></a>

</li>
</ul>
<h2 id="二-0号进程的创建"><a href="#二-0号进程的创建" class="headerlink" title="二. 0号进程的创建"></a>二. 0号进程的创建</h2><p>&emsp;&emsp;<code>start_kernel()</code>上来就会运行 <code>set_task_stack_end_magic(&amp;init_task)</code>创建初始进程。<code>init_task</code>的定义是 <code>struct task_struct init_task = INIT_TASK(init_task)</code>。它是系统创建的第一个进程，我们称为 0 号进程。<strong>这是唯一一个没有通过 <code>fork</code> 或者 <code>kernel_thread</code>产生的进程，是进程列表的第一个</strong>。</p>
<p>&emsp;&emsp;如下所示为init_task的定义，这里只节选了部分，采用了gcc的结构体初始化方式为其进行了直接赋值生成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set up the first task table, touch at your own risk!. Base=0,</span></span><br><span class="line"><span class="comment"> * limit=0x1fffff (=2MB)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> <span class="title">init_task</span></span></span><br><span class="line"><span class="class">#<span class="title">ifdef</span> <span class="title">CONFIG_ARCH_TASK_STRUCT_ON_STACK</span></span></span><br><span class="line"><span class="class">    __<span class="title">init_task_data</span></span></span><br><span class="line"><span class="class">#<span class="title">endif</span></span></span><br><span class="line"><span class="class">= &#123;</span></span><br><span class="line">    ......</span><br><span class="line">    .state             = <span class="number">0</span>,</span><br><span class="line">    .<span class="built_in">stack</span>             = init_stack,</span><br><span class="line">    .usage             = REFCOUNT_INIT(<span class="number">2</span>),</span><br><span class="line">    .flags             = PF_KTHREAD,</span><br><span class="line">    .prio             = MAX_PRIO - <span class="number">20</span>,</span><br><span class="line">    .static_prio     = MAX_PRIO - <span class="number">20</span>,</span><br><span class="line">    .normal_prio     = MAX_PRIO - <span class="number">20</span>,</span><br><span class="line">    .policy             = SCHED_NORMAL,</span><br><span class="line">    .cpus_ptr         = &amp;init_task.cpus_mask,</span><br><span class="line">    .cpus_mask         = CPU_MASK_ALL,</span><br><span class="line">    .nr_cpus_allowed = NR_CPUS,</span><br><span class="line">    .mm                 = <span class="literal">NULL</span>,</span><br><span class="line">    .active_mm         = &amp;init_mm,</span><br><span class="line">    ......</span><br><span class="line">    .thread_pid         = &amp;init_struct_pid,</span><br><span class="line">    .thread_group     = LIST_HEAD_INIT(init_task.thread_group),</span><br><span class="line">    .thread_node     = LIST_HEAD_INIT(init_signals.thread_head),</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL(init_task);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;而 <code>set_task_stack_end_magic(&amp;init_task)</code>函数的源码如下，主要是通过<code>end_of_stack()</code>获取栈边界地址，然后把栈底地址设置为STACK_END_MAGIC，作为栈溢出的标记。每个进程创建的时候，系统会为这个进程创建2个页大小的内核栈。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_task_stack_end_magic</span><span class="params">(struct task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *stackend;</span><br><span class="line"></span><br><span class="line">    stackend = end_of_stack(tsk);</span><br><span class="line">    *stackend = STACK_END_MAGIC;    <span class="comment">/* for overflow detection */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>init_task</code>是静态定义的一个进程，也就是说当内核被放入内存时，它就已经存在，它没有自己的用户空间，一直处于内核空间中运行，并且也只处于内核空间运行。0号进程用于包括内存、页表、必要数据结构、信号、调度器、硬件设备等的初始化。当它执行到最后（剩余初始化）时，将<code>start_kernel</code>中所有的初始化执行完成后，会在内核中启动一个<code>kernel_init</code>内核线程和一个<code>kthreadd</code>内核线程，<code>kernel_init</code>内核线程执行到最后会通过<code>execve</code>系统调用执行转变为我们所熟悉的<code>init</code>进程，而<code>kthreadd</code>内核线程是内核用于管理调度其他的内核线程的守护线程。在最后<code>init_task</code>将变成一个idle进程，用于在CPU没有进程运行时运行它，它在此时仅仅用于空转。</p>
<h2 id="三-中断初始化"><a href="#三-中断初始化" class="headerlink" title="三. 中断初始化"></a>三. 中断初始化</h2><p>&emsp;&emsp;由代码可见，<code>trap_init()</code>设置了很多的中断门（Interrupt Gate)，用于处理各种中断，如系统调用的中断门<code>set_system_intr_gate(IA32_SYSCALL_VECTOR, entry_INT80_32)</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trap_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//设置系统的硬件中断 中断位于kernel/asm.s 或 system_call.s</span></span><br><span class="line">    set_trap_gate(<span class="number">0</span>,÷_error);<span class="comment">//0中断，位于/kernel/asm.s 19行</span></span><br><span class="line">    set_trap_gate(<span class="number">1</span>,&amp;debug);</span><br><span class="line">    set_trap_gate(<span class="number">2</span>,&amp;nmi);</span><br><span class="line">    set_system_gate(<span class="number">3</span>,&amp;int3);    <span class="comment">/* int3-5 can be called from all */</span></span><br><span class="line">    set_system_gate(<span class="number">4</span>,&amp;<span class="built_in">overflow</span>);</span><br><span class="line">    set_system_gate(<span class="number">5</span>,&amp;bounds);</span><br><span class="line">    set_trap_gate(<span class="number">6</span>,&amp;invalid_op);</span><br><span class="line">    set_trap_gate(<span class="number">7</span>,&amp;device_not_available);</span><br><span class="line">    set_trap_gate(<span class="number">8</span>,&amp;double_fault);</span><br><span class="line">    set_trap_gate(<span class="number">9</span>,&amp;coprocessor_segment_overrun);</span><br><span class="line">    set_trap_gate(<span class="number">10</span>,&amp;invalid_TSS);</span><br><span class="line">    set_trap_gate(<span class="number">11</span>,&amp;segment_not_present);</span><br><span class="line">    set_trap_gate(<span class="number">12</span>,&amp;stack_segment);</span><br><span class="line">    set_trap_gate(<span class="number">13</span>,&amp;general_protection);</span><br><span class="line">    set_trap_gate(<span class="number">14</span>,&amp;page_fault);</span><br><span class="line">    set_trap_gate(<span class="number">15</span>,&amp;reserved);</span><br><span class="line">    set_trap_gate(<span class="number">16</span>,&amp;coprocessor_error);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">17</span>;i&lt;<span class="number">48</span>;i++)</span><br><span class="line">        set_trap_gate(i,&amp;reserved);</span><br><span class="line">    set_trap_gate(<span class="number">45</span>,&amp;irq13);</span><br><span class="line">    outb_p(inb_p(<span class="number">0x21</span>)&amp;<span class="number">0xfb</span>,<span class="number">0x21</span>);</span><br><span class="line">    outb(inb_p(<span class="number">0xA1</span>)&amp;<span class="number">0xdf</span>,<span class="number">0xA1</span>);</span><br><span class="line">    set_trap_gate(<span class="number">39</span>,¶llel_interrupt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四-内存初始化"><a href="#四-内存初始化" class="headerlink" title="四. 内存初始化"></a>四. 内存初始化</h2><p>&emsp;&emsp;内存相关的初始化内容放在<code>mm_init()</code>中进行，代码如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init/main.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set up kernel memory allocators</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * page_ext requires contiguous pages,</span></span><br><span class="line"><span class="comment">     * bigger than MAX_ORDER unless SPARSEMEM.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    page_ext_init_flatmem();</span><br><span class="line">    mem_init();</span><br><span class="line">    kmem_cache_init();</span><br><span class="line">    pgtable_init();</span><br><span class="line">    vmalloc_init();</span><br><span class="line">    ioremap_huge_init();</span><br><span class="line">    <span class="comment">/* Should be run before the first non-init thread is created */</span></span><br><span class="line">    init_espfix_bsp();</span><br><span class="line">    <span class="comment">/* Should be run after espfix64 is set up. */</span></span><br><span class="line">    pti_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;调用的函数功能基本如名字所示，主要进行了以下初始化设置：</p>
<ul>
<li><code>page_ext_init_flatmem()</code>和cgroup的初始化相关，该部分是docker技术的核心部分</li>
<li><code>mem_init()</code>初始化内存管理的伙伴系统</li>
<li><code>kmem_cache_init()</code>完成内核slub内存分配体系的初始化，相关的还有<code>buffer_init</code></li>
<li><code>pgtable_init()</code>完成页表初始化，包括页表锁<code>ptlock_init()</code>和</li>
<li><code>vmalloc_init()</code>完成vmalloc的初始化</li>
<li><code>ioremap_huge_init()</code> ioremap实现I/O内存资源由物理地址映射到虚拟地址空间，此处为其功能的初始化</li>
<li><code>init_espfix_bsp()</code>和<code>pti_init()</code>完成PTI（page table isolation）的初始化</li>
</ul>
<p>&emsp;&emsp;此处不展开说明这些函数，留待后面内存管理部分详细分析各个部分。</p>
<h2 id="五-调度器初始化"><a href="#五-调度器初始化" class="headerlink" title="五. 调度器初始化"></a>五. 调度器初始化</h2><p>&emsp;&emsp;调度器初始化通过<code>sched_init()</code>完成，其主要工作包括</p>
<ul>
<li><p>对相关数据结构分配内存：如初始化<code>waitqueues</code>数组，根据调度方式FAIR/RT设置<code>alloc_size</code>，调用<code>kzalloc</code>分配空间</p>
</li>
<li><p>初始化<code>root_task_group</code>：根据FAIR/RT的不同，将<code>kzalloc</code>分配的空间用于其初始化，主要结构<code>task_group</code>包含以下几个重要组成部分：<code>se</code>, <code>rt_se</code>, <code>cfs_rq</code> 以及 <code>rt_rq</code>。其中<code>cfs_rq</code>和<code>rt_rq</code>表示<code>run queue</code>，即一种特殊的<code>per-cpu</code>结构体用于内核调度器存储激活的线程。</p>
</li>
<li><p>调用<code>for_each_possible_cpu()</code>初始化每个<code>possible</code>CPU（存储于<code>cpu_possible_mask</code>为图中）的<code>runqueue</code>队列(包括其中的cfs队列和实时进程队列)，<a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/sched/sched.h#L625" target="_blank" rel="noopener">rq</a>结构体是调度进程的基本数据结构，调度器用rq决定下一个将要被调度的进程。详细介绍会在调度一节进行。</p>
</li>
<li><p>调用<code>set_load_weight(&amp;init_task)</code>，将<code>init_task</code>进程转变为idle进程</p>
<p>需要说明的是<code>init_task</code>在这里会被转变为<code>idle</code>进程，但是它还会继续执行初始化工作，相当于这里只是给<code>init_task</code>挂个<code>idle</code>进程的名号，它其实还是<code>init_task</code>进程，只有到最后<code>init_task</code>进程开启了<code>kernel_init</code>和<code>kthreadd</code>进程之后，才转变为真正意义上的<code>idle</code>进程。</p>
</li>
</ul>
<h2 id="六-剩余初始化"><a href="#六-剩余初始化" class="headerlink" title="六. 剩余初始化"></a>六. 剩余初始化</h2><p>&emsp;&emsp;<code>rest_init</code>是非常重要的一步，主要包括了区分内核态和用户态、初始化1号进程和初始化2号进程。</p>
<h3 id="6-1-内核态和用户态"><a href="#6-1-内核态和用户态" class="headerlink" title="6.1 内核态和用户态"></a>6.1 内核态和用户态</h3><p>&emsp;&emsp;在运行用户进程之前，尚需要完成一件事：区分内核态和用户态。x86 提供了分层的权限机制，把区域分成了四个 Ring，越往里权限越高，越往外权限越低。操作系统很好地利用了这个机制，将能够访问关键资源的代码放在 Ring0，我们称为内核态（Kernel Mode）；将普通的程序代码放在 Ring3，我们称为用户态（User Mode）。</p>
<img src="https://static001.geekbang.org/resource/image/2b/42/2b53b470673cde8f9d8e2573f7d07242.jpg" alt="img" style="zoom:25%;" />



<h3 id="6-2-初始化1号进程"><a href="#6-2-初始化1号进程" class="headerlink" title="6.2 初始化1号进程"></a>6.2 初始化1号进程</h3><p>&emsp;&emsp;<code>rest_init()</code> 的一大工作是，用 <code>kernel_thread(kernel_init, NULL, CLONE_FS)</code>创建第二个进程，这个是 1 号进程。1 号进程对于操作系统来讲，有“划时代”的意义，因为它将运行一个用户进程，并从此开始形成用户态进程树。这里主要需要分析的是如何完成从内核态到用户态切换的过程。<code>kernel_thread()</code>代码如下所示，可见其中最主要的是第一个参数指针函数fn决定了栈中的内容，根据fn的不同将生成1号进程和后面的2号进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Create a kernel thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">kernel_thread</span><span class="params">(<span class="keyword">int</span> (*fn)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kernel_clone_args</span> <span class="title">args</span> = &#123;</span></span><br><span class="line">        .flags        = ((flags | CLONE_VM | CLONE_UNTRACED) &amp; ~CSIGNAL),</span><br><span class="line">        .exit_signal    = (flags &amp; CSIGNAL),</span><br><span class="line">        .<span class="built_in">stack</span>        = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)fn,</span><br><span class="line">        .stack_size    = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)arg,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _do_fork(&amp;args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>kernel_thread()</code> 的参数是一个函数 <code>kernel_init()</code>，核心代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ramdisk_execute_command) </span><br><span class="line">&#123; </span><br><span class="line">    ret = run_init_process(ramdisk_execute_command);</span><br><span class="line">    ...... </span><br><span class="line">&#125;</span><br><span class="line">...... </span><br><span class="line"><span class="keyword">if</span> (!try_to_run_init_process(<span class="string">"/sbin/init"</span>) || </span><br><span class="line">    !try_to_run_init_process(<span class="string">"/etc/init"</span>)  || </span><br><span class="line">    !try_to_run_init_process(<span class="string">"/bin/init"</span>)  || </span><br><span class="line">    !try_to_run_init_process(<span class="string">"/bin/sh"</span>)) </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这就说明，1 号进程运行的是一个文件。如果我们打开 <code>run_init_process()</code> 函数，会发现它调用的是 <code>do_execve()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">run_init_process</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init_filename)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    argv_init[<span class="number">0</span>] = init_filename; </span><br><span class="line">    <span class="keyword">return</span> do_execve(getname_kernel(init_filename), </span><br><span class="line">                     (<span class="keyword">const</span> <span class="keyword">char</span> __user *<span class="keyword">const</span> __user *)argv_init, </span><br><span class="line">                     (<span class="keyword">const</span> <span class="keyword">char</span> __user *<span class="keyword">const</span> __user *)envp_init);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;接着会进行一系列的调用：<code>do_execve-&gt;do_execveat_common-&gt;exec_binprm-&gt;search_binary_handler</code>，这里<code>search_binary_handler()</code>主要是加载ELF文件（Executable and Linkable Format，可执行与可链接格式），代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search_binary_handler</span><span class="params">(struct linux_binprm *bprm)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    ...... </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> *<span class="title">fmt</span>;</span> </span><br><span class="line">    ...... </span><br><span class="line">    retval = fmt-&gt;load_binary(bprm); </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>load_binary</code>先调用<code>load_elf_binary</code>，最后调用<code>start_thread</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">start_thread(struct pt_regs *regs, <span class="keyword">unsigned</span> <span class="keyword">long</span> new_ip, <span class="keyword">unsigned</span> <span class="keyword">long</span> new_sp)</span><br><span class="line">&#123;</span><br><span class="line">    set_user_gs(regs, <span class="number">0</span>);</span><br><span class="line">    regs-&gt;fs  = <span class="number">0</span>;</span><br><span class="line">    regs-&gt;ds  = __USER_DS;</span><br><span class="line">    regs-&gt;es  = __USER_DS;</span><br><span class="line">    regs-&gt;ss  = __USER_DS;</span><br><span class="line">    regs-&gt;cs  = __USER_CS;</span><br><span class="line">    regs-&gt;ip  = new_ip;</span><br><span class="line">    regs-&gt;sp  = new_sp;</span><br><span class="line">    regs-&gt;flags  = X86_EFLAGS_IF;</span><br><span class="line">    force_iret();</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(start_thread);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个结构就是在系统调用的时候，内核中保存用户态运行上下文的，里面将用户态的代码段 CS 设置为 <code>__USER_CS</code>，将用户态的数据段 DS 设置为 <code>__USER_DS</code>，以及指令指针寄存器 IP、栈指针寄存器 SP。这里相当于补上了原来系统调用里，保存寄存器的一个步骤。最后的 iret 是干什么的呢？它是用于从系统调用中返回。这个时候会恢复寄存器。从哪里恢复呢？按说是从进入系统调用的时候，保存的寄存器里面拿出。好在上面的函数补上了寄存器。CS 和指令指针寄存器 IP 恢复了，指向用户态下一个要执行的语句。DS 和函数栈指针 SP 也被恢复了，指向用户态函数栈的栈顶。所以，下一条指令，就从用户态开始运行了。</p>
<p>&emsp;&emsp;经过上述过程，我们完成了从内核态切换到用户态。而此时代码其实还在运行 <code>kernel_init</code>函数，会调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!ramdisk_execute_command)</span><br><span class="line">    ramdisk_execute_command = <span class="string">"/init"</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;结合上面的<code>init</code>程序，这里出现了第二个init。这是有其存在的必要性的：上文提到的 init 程序是在文件系统上的，文件系统一定是在一个存储设备上的，例如硬盘。Linux 访问存储设备，要有驱动才能访问。如果存储系统数目很有限，那驱动可以直接放到内核里面，反正前面我们加载过内核到内存里了，现在可以直接对存储系统进行访问。但是存储系统越来越多了，如果所有市面上的存储系统的驱动都默认放进内核，内核就太大了。这该怎么办呢？</p>
<p>&emsp;&emsp;我们只好先弄一个基于内存的文件系统。内存访问是不需要驱动的，这个就是 ramdisk。这个时候，ramdisk 是根文件系统。然后，我们开始运行 ramdisk 上的 /init。等它运行完了就已经在用户态了。/init 这个程序会先根据存储系统的类型加载驱动，有了驱动就可以设置真正的根文件系统了。有了真正的根文件系统，ramdisk 上的 /init 会启动文件系统上的 init。接下来就是各种系统的初始化。启动系统的服务，启动控制台，用户就可以登录进来了。</p>
<h3 id="6-3-初始化2号进程"><a href="#6-3-初始化2号进程" class="headerlink" title="6.3 初始化2号进程"></a>6.3 初始化2号进程</h3><p>&emsp;&emsp;<code>rest_init</code> 另一大事情就是创建第三个进程，就是 2 号进程。<code>kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES)</code>又一次使用 <code>kernel_thread</code> 函数创建进程。这里需要指出一点，函数名 thread 可以翻译成“线程”，这也是操作系统很重要的一个概念。从内核态来看，无论是进程，还是线程，我们都可以统称为任务（Task），都使用相同的数据结构，平放在同一个链表中。这里的函数<code>kthreadd</code>，负责所有内核态的线程的调度和管理，是内核态所有线程运行的祖先。</p>
<p>&emsp;&emsp;<code>kthreadd</code>，即2号进程，用于内核态线程的管理，是一个守护线程。其源码如下所示，运行流程包括</p>
<ul>
<li>初始化了<code>task</code>结构，并将该线程设置为允许任意CPU运行。</li>
<li>进入循环，将线程状态设置为<code>TASK_INTERRUPTIBLE</code>，如果当前<code>kthread_create_list</code>为空，没有要创建的线程，则执行<code>schedule()</code>让出CPU资源。</li>
<li>如果需要创建，则设置为<code>TASK_RUNNING</code>状态，加上锁<code>spin_lock</code>，从链表中取得<code>kthread_create_info</code> 结构的地址，在上文中已经完成插入操作(将<code>kthread_create_info</code>结构中的 list 成员加到链表中，此时根据成员 list 的偏移获得 create)</li>
<li>调用<code>create_kthread(create)</code>完成线程的创建</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthreadd</span><span class="params">(<span class="keyword">void</span> *unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> = <span class="title">current</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Setup a clean context for our children to inherit. */</span></span><br><span class="line">    set_task_comm(tsk, <span class="string">"kthreadd"</span>);</span><br><span class="line">    ignore_signals(tsk);</span><br><span class="line">    set_cpus_allowed_ptr(tsk, cpu_all_mask);</span><br><span class="line">    set_mems_allowed(node_states[N_MEMORY]);</span><br><span class="line"></span><br><span class="line">    current-&gt;flags |= PF_NOFREEZE;</span><br><span class="line">    cgroup_init_kthreadd();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">        <span class="keyword">if</span> (list_empty(&amp;kthread_create_list))</span><br><span class="line">            schedule();</span><br><span class="line">        __set_current_state(TASK_RUNNING);</span><br><span class="line"></span><br><span class="line">        spin_lock(&amp;kthread_create_lock);</span><br><span class="line">        <span class="keyword">while</span> (!list_empty(&amp;kthread_create_list)) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">kthread_create_info</span> *<span class="title">create</span>;</span></span><br><span class="line"></span><br><span class="line">            create = list_entry(kthread_create_list.next,</span><br><span class="line">                        struct kthread_create_info, <span class="built_in">list</span>);</span><br><span class="line">            list_del_init(&amp;create-&gt;<span class="built_in">list</span>);</span><br><span class="line">            spin_unlock(&amp;kthread_create_lock);</span><br><span class="line"></span><br><span class="line">            create_kthread(create);</span><br><span class="line"></span><br><span class="line">            spin_lock(&amp;kthread_create_lock);</span><br><span class="line">        &#125;</span><br><span class="line">        spin_unlock(&amp;kthread_create_lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;而<code>create_kthread(create)</code>函数做了一件让人意外的事情：调用了<code>kernel_thread()</code>，所以又回到了创建1号进程和2号进程的函数上，这次的回调函数为<code>kthread</code>，该函数才会真正意义上分配内存、初始化一个新的内核线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create_kthread</span><span class="params">(struct kthread_create_info *create)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    current-&gt;pref_node_fork = create-&gt;node;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* We want our own signal handler (we take no signals by default). */</span></span><br><span class="line">    pid = kernel_thread(kthread, create, CLONE_FS | CLONE_FILES | SIGCHLD);</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* If user was SIGKILLed, I release the structure. */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">completion</span> *<span class="title">done</span> = <span class="title">xchg</span>(&amp;<span class="title">create</span>-&gt;<span class="title">done</span>, <span class="title">NULL</span>);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">            kfree(create);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        create-&gt;result = ERR_PTR(pid);</span><br><span class="line">        complete(done);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;下面是<code>kthread</code>的源码，这里有个很重要的地方：新创建的线程由于执行了 schedule() 调度，此时并没有执行，直到我们使用<code>wake_up_process(p)</code>唤醒新创建的线程。线程被唤醒后, 会接着执行最后一段<code>threadfn(data)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kthread</span><span class="params">(<span class="keyword">void</span> *_create)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Copy data: it's on kthread's stack */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kthread_create_info</span> *<span class="title">create</span> = _<span class="title">create</span>;</span></span><br><span class="line">    <span class="keyword">int</span> (*threadfn)(<span class="keyword">void</span> *data) = create-&gt;threadfn;</span><br><span class="line">    <span class="keyword">void</span> *data = create-&gt;data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">completion</span> *<span class="title">done</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kthread</span> *<span class="title">self</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    self = kzalloc(<span class="keyword">sizeof</span>(*self), GFP_KERNEL);</span><br><span class="line">    set_kthread_struct(self);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If user was SIGKILLed, I release the structure. */</span></span><br><span class="line">    done = xchg(&amp;create-&gt;done, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">        kfree(create);</span><br><span class="line">        do_exit(-EINTR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!self) &#123;</span><br><span class="line">        create-&gt;result = ERR_PTR(-ENOMEM);</span><br><span class="line">        complete(done);</span><br><span class="line">        do_exit(-ENOMEM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self-&gt;data = data;</span><br><span class="line">    init_completion(&amp;self-&gt;exited);</span><br><span class="line">    init_completion(&amp;self-&gt;parked);</span><br><span class="line">    current-&gt;vfork_done = &amp;self-&gt;exited;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* OK, tell user we're spawned, wait for stop or wakeup */</span></span><br><span class="line">    __set_current_state(TASK_UNINTERRUPTIBLE);</span><br><span class="line">    create-&gt;result = current;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread is going to call schedule(), do not preempt it,</span></span><br><span class="line"><span class="comment">     * or the creator may spend more time in wait_task_inactive().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    preempt_disable();</span><br><span class="line">    complete(done);</span><br><span class="line">    schedule_preempt_disabled();</span><br><span class="line">    preempt_enable();</span><br><span class="line"></span><br><span class="line">    ret = -EINTR;</span><br><span class="line">    <span class="keyword">if</span> (!test_bit(KTHREAD_SHOULD_STOP, &amp;self-&gt;flags)) &#123;</span><br><span class="line">        cgroup_kthread_ready();</span><br><span class="line">        __kthread_parkme(self);</span><br><span class="line">        ret = threadfn(data);</span><br><span class="line">    &#125;</span><br><span class="line">    do_exit(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;由此，我们可以总结一下第2号进程的工作流程：</p>
<ul>
<li>第2号进程<code>kthreadd</code>进程由第0号进程通过<code>kernel_thread()</code>创建，并始终运行在内核空间, 负责所有内核线程的调度和管理</li>
<li>第2号进程会循环检测<code>kthread_create_list</code>全局链表, 当我们调用<code>kernel_thread</code>创建内核线程时，新线程会被加入到此链表中，因此所有的内核线程都是直接或者间接的以kthreadd为父进程</li>
<li>检测到新线程创建，则调用<code>kernel_thread()</code>创建线程，其回调为<code>kthread</code></li>
<li><code>kthread</code>在创建完后调用<code>schedule()</code>让出CPU资源，而不是直接运行。等待收到<code>wake_up_process(p)</code>的唤醒后再继续执行<code>threadfn(data)</code>。</li>
</ul>
<p>因此</p>
<ul>
<li><p>任何一个内核线程入口都是 kthread()</p>
</li>
<li><p>通过<code>kthread_create()</code>创建的内核线程不会立刻运行，需要手工 <code>wake up</code>.</p>
</li>
<li><p>通过<code>kthread_create()</code> 创建的内核线程有可能不会执行相应线程函数<code>threadfn</code>而直接退出</p>
</li>
</ul>
<p>&emsp;&emsp;回到<code>rest_init()</code>，当完成了1号2号进程的创建后，我们将0号进程真正归位idle进程，结束<code>rest_init()</code>，也正事结束了<code>start_kernel()</code>函数，由此，内核初始化全部完成。</p>
<h2 id="七-总结"><a href="#七-总结" class="headerlink" title="七. 总结"></a>七. 总结</h2><p>&emsp;&emsp;本文介绍了内核初始化的几个重要部分，其实还有很多初始化没有介绍，如cgroup初始化、虚拟文件系统初始化、radix树初始化、rcu初始化、计时器和时间初始化、架构初始化等等，这些会在后面有针对性的单独介绍。</p>
<h2 id="源码资料"><a href="#源码资料" class="headerlink" title="源码资料"></a>源码资料</h2><p>[1] <a href="https://elixir.bootlin.com/linux/v5.7-rc1/source/init/main.c" target="_blank" rel="noopener">init/main.c</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] Linux-insides</p>
<p>[2] 深入理解Linux内核</p>
<p>[3] Linux内核设计的艺术</p>
<p>[4] 极客时间 趣谈Linux操作系统</p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创，坚持分享，谢谢鼓励和支持</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="Ty Chen 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="Ty Chen 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Ty Chen
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://ty-chen.github.io/linux-kernel-zero-process/" title="Linux操作系统学习笔记（三）内核初始化">https://ty-chen.github.io/linux-kernel-zero-process/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
            <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a>
          
            <a href="/tags/start-kernel/" rel="tag"># start_kernel</a>
          
            <a href="/tags/0%E5%8F%B7%E8%BF%9B%E7%A8%8B/" rel="tag"># 0号进程</a>
          
            <a href="/tags/1%E5%8F%B7%E8%BF%9B%E7%A8%8B/" rel="tag"># 1号进程</a>
          
            <a href="/tags/2%E5%8F%B7%E8%BF%9B%E7%A8%8B/" rel="tag"># 2号进程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/linux-kernel-protecd-mode/" rel="next" title="Linux操作系统学习笔记（二）内核运行">
                <i class="fa fa-chevron-left"></i> Linux操作系统学习笔记（二）内核运行
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/linux-kernel-system-call/" rel="prev" title="Linux操作系统学习笔记（四）系统调用">
                Linux操作系统学习笔记（四）系统调用 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        
  <div class="bdsharebuttonbox">
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
    <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
    <a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a>
    <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
    <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a class="bds_count" data-cmd="count"></a>
  </div>
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "2",
        "bdMiniList": false,
        "bdPic": ""
      },
      "share": {
        "bdSize": "16",
        "bdStyle": "0"
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/me.JPG"
                alt="Ty Chen" />
            
              <p class="site-author-name" itemprop="name">Ty Chen</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">53</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">86</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Ty-Chen" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:tianyuch@hotmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Friends
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://lishouxian.cn/" title="Stanleylsx" target="_blank">Stanleylsx</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一-前言"><span class="nav-text">一. 前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二-0号进程的创建"><span class="nav-text">二. 0号进程的创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三-中断初始化"><span class="nav-text">三. 中断初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四-内存初始化"><span class="nav-text">四. 内存初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五-调度器初始化"><span class="nav-text">五. 调度器初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六-剩余初始化"><span class="nav-text">六. 剩余初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-内核态和用户态"><span class="nav-text">6.1 内核态和用户态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-初始化1号进程"><span class="nav-text">6.2 初始化1号进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-初始化2号进程"><span class="nav-text">6.3 初始化2号进程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#七-总结"><span class="nav-text">七. 总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#源码资料"><span class="nav-text">源码资料</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2020 &mdash; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ty Chen</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">208.9k</span>
  
  <a href="http://www.beian.miit.gov.cn/" target="_blank" rel="noopener">粤ICP备20071543号</a> 
</div>









        
<div class="busuanzi-count">
	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>

  
    <span class="site-uv">
      你是来访的第
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      位同学
    </span>
  

  
    <span class="site-pv">
      访问次数：
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'aTqo2eFkO2Bn0AGX008uKDV7-gzGzoHsz',
        appKey: 'uJ6nxqW7RHWpAILCtttkJfJu',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
