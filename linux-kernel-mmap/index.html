<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/kulamati128.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/kulamati32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/kulamati16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Linux,操作系统,内存,内存映射,mmap,brk,malloc," />










<meta name="description" content="一. 前言&amp;emsp;&amp;emsp;本文为内存部分最后一篇，介绍内存映射。内存映射不仅是物理内存和虚拟内存间的映射，也包括将文件中的内容映射到虚拟内存空间。这个时候，访问内存空间就能够访问到文件里面的数据。而仅有物理内存和虚拟内存的映射，是一种特殊情况。本文首先分析用户态在堆中申请小块内存的brk和申请大块内存的mmap，之后会分析内核态的内存映射机制vmalloc，kmap_atomic，swap">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux操作系统学习笔记（十）内存管理之内存映射">
<meta property="og:url" content="https://ty-chen.github.io/linux-kernel-mmap/index.html">
<meta property="og:site_name" content="Ty-Chen&#39;s Home">
<meta property="og:description" content="一. 前言&amp;emsp;&amp;emsp;本文为内存部分最后一篇，介绍内存映射。内存映射不仅是物理内存和虚拟内存间的映射，也包括将文件中的内容映射到虚拟内存空间。这个时候，访问内存空间就能够访问到文件里面的数据。而仅有物理内存和虚拟内存的映射，是一种特殊情况。本文首先分析用户态在堆中申请小块内存的brk和申请大块内存的mmap，之后会分析内核态的内存映射机制vmalloc，kmap_atomic，swap">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/94/b3/94efd92cbeb4d4ff155a645b93d71eb3.jpg">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/27/9a/274e22b3f5196a4c68bb6813fb643f9a.png">
<meta property="article:published_time" content="2020-06-07T13:12:49.000Z">
<meta property="article:modified_time" content="2020-09-11T16:17:02.279Z">
<meta property="article:author" content="Ty Chen">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="内存">
<meta property="article:tag" content="内存映射">
<meta property="article:tag" content="mmap">
<meta property="article:tag" content="brk">
<meta property="article:tag" content="malloc">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://static001.geekbang.org/resource/image/94/b3/94efd92cbeb4d4ff155a645b93d71eb3.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://ty-chen.github.io/linux-kernel-mmap/"/>





  <title>Linux操作系统学习笔记（十）内存管理之内存映射 | Ty-Chen's Home</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ty-Chen's Home</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Collecting, sharing and creating knowledge</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ty-chen.github.io/linux-kernel-mmap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ty Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty-Chen's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Linux操作系统学习笔记（十）内存管理之内存映射</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-07T21:12:49+08:00">
                2020-06-07
              </time>
            

            

            
          </span>
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2020-09-12T00:17:02+08:00" content="2020-09-12">
                2020-09-12
              </time>
            </span>
          
          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index">
                    <span itemprop="name">Linux操作系统内核学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/linux-kernel-mmap/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/linux-kernel-mmap/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv">访问次数：
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  24
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h2><p>&emsp;&emsp;本文为内存部分最后一篇，介绍内存映射。内存映射不仅是物理内存和虚拟内存间的映射，也包括将文件中的内容映射到虚拟内存空间。这个时候，访问内存空间就能够访问到文件里面的数据。而仅有物理内存和虚拟内存的映射，是一种特殊情况。本文首先分析用户态在堆中申请小块内存的<code>brk</code>和申请大块内存的<code>mmap</code>，之后会分析内核态的内存映射机制<code>vmalloc</code>，<code>kmap_atomic</code>，<code>swapper_pg_dir</code>以及内核态缺页异常。</p>
<a id="more"></a>

<h2 id="二-用户态内存映射"><a href="#二-用户态内存映射" class="headerlink" title="二. 用户态内存映射"></a>二. 用户态内存映射</h2><p>&emsp;&emsp;用户态调用<code>malloc()</code>会分配堆内存空间，而实际上则是完成了一次用户态的内存映射，根据分配空间的大小，内存映射对应的系统调用主要有<code>brk()</code>和<code>mmap()</code>(当然我们也可以直接调用<code>mmap()</code>来映射文件)。对小块内存（小于 128K），C 标准库使用 <code>brk()</code> 来分配，也就是通过移动堆顶的位置来分配内存。这些内存释放后并不会立刻归还系统，而是被缓存起来，这样就可以重复使用。而大块内存（大于 128K），则直接使用内存映射 <code>mmap()</code> 来分配，也就是在文件映射段找一块空闲内存分配出去。这两种方式，自然各有优缺点。</p>
<p>&emsp;&emsp;<code>brk()</code> 方式的缓存，可以减少缺页异常的发生，提高内存访问效率。不过，由于这些内存没有归还系统，在内存工作繁忙时，频繁的内存分配和释放会造成内存碎片。</p>
<p>&emsp;&emsp; <code>mmap()</code> 方式分配的内存，会在释放时直接归还系统，所以每次 <code>mmap()</code> 都会发生缺页异常。在内存工作繁忙时，频繁的内存分配会导致大量的缺页异常，使内核的管理负担增大。这也是 <code>malloc()</code> 只对大块内存使用 <code>mmap()</code>  的原因。</p>
<h3 id="2-1-小块内存申请"><a href="#2-1-小块内存申请" class="headerlink" title="2.1 小块内存申请"></a>2.1 小块内存申请</h3><p>&emsp;&emsp;<code>brk()</code>系统调用为<code>sys_brk()</code>函数，其参数<code>brk</code>是新的堆顶位置，而<code>mm-&gt;brk</code>是原堆顶位置。该函数主要逻辑如下</p>
<ul>
<li>将原来的堆顶和现在的堆顶按照页对齐地址比较大小，判断是否在同一页中<ul>
<li>如果同一页则不需要分配新页，直接跳转至<code>set_brk</code>，设置<code>mm-&gt;brk</code>为新的<code>brk</code>即可</li>
<li>如果不在同一页<ul>
<li>如果新堆顶小于旧堆顶，则说明不是新分配内存而是释放内存，由此调用<code>__do_munmap()</code>释放</li>
<li>如果是新分配内存，则调用<code>find_vma()</code>，查找<code>vm_area_struct</code>红黑树中原堆顶所在<code>vm_area_struct</code>的下一个结构体，如果在二者之间有足够的空间分配一个页则调用<code>do_brk_flags()</code>分配堆空间。如果不可以则分配失败。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE1(brk, <span class="keyword">unsigned</span> <span class="keyword">long</span>, brk)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> retval;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> newbrk, oldbrk, origbrk;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">current</span>-&gt;<span class="title">mm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">next</span>;</span></span><br><span class="line">......</span><br><span class="line">    newbrk = PAGE_ALIGN(brk);</span><br><span class="line">    oldbrk = PAGE_ALIGN(mm-&gt;brk);</span><br><span class="line">    <span class="keyword">if</span> (oldbrk == newbrk) &#123;</span><br><span class="line">        mm-&gt;brk = brk;</span><br><span class="line">        <span class="keyword">goto</span> success;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Always allow shrinking brk.</span></span><br><span class="line"><span class="comment">     * __do_munmap() may downgrade mmap_sem to read.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (brk &lt;= mm-&gt;brk) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * mm-&gt;brk must to be protected by write mmap_sem so update it</span></span><br><span class="line"><span class="comment">         * before downgrading mmap_sem. When __do_munmap() fails,</span></span><br><span class="line"><span class="comment">         * mm-&gt;brk will be restored from origbrk.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        mm-&gt;brk = brk;</span><br><span class="line">        ret = __do_munmap(mm, newbrk, oldbrk-newbrk, &amp;uf, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            mm-&gt;brk = origbrk;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">1</span>) &#123;</span><br><span class="line">            downgraded = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> success;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Check against existing mmap mappings. */</span></span><br><span class="line">    next = find_vma(mm, oldbrk);</span><br><span class="line">    <span class="keyword">if</span> (next &amp;&amp; newbrk + PAGE_SIZE &gt; vm_start_gap(next))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="comment">/* Ok, looks good - let it rip. */</span></span><br><span class="line">    <span class="keyword">if</span> (do_brk_flags(oldbrk, newbrk-oldbrk, <span class="number">0</span>, &amp;uf) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    mm-&gt;brk = brk;</span><br><span class="line">success:</span><br><span class="line">    populate = newbrk &gt; oldbrk &amp;&amp; (mm-&gt;def_flags &amp; VM_LOCKED) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (downgraded)</span><br><span class="line">        up_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        up_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line">    userfaultfd_unmap_complete(mm, &amp;uf);</span><br><span class="line">    <span class="keyword">if</span> (populate)</span><br><span class="line">        mm_populate(oldbrk, newbrk - oldbrk);</span><br><span class="line">    <span class="keyword">return</span> brk;</span><br><span class="line">out:</span><br><span class="line">    retval = origbrk;</span><br><span class="line">    up_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在 <code>do_brk_flags()</code> 中，调用 <code>find_vma_links()</code> 找到将来的 <code>vm_area_struct</code> 节点在红黑树的位置，找到它的父节点、前序节点。接下来调用 <code>vma_merge()</code>，看这个新节点是否能够和现有树中的节点合并。如果地址是连着的，能够合并，则不用创建新的 <code>vm_area_struct</code> 了，直接跳到 out，更新统计值即可；如果不能合并，则创建新的 <code>vm_area_struct</code>，既加到 <code>anon_vma_chain</code> 链表中，也加到红黑树中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  this is really a simplified "do_mmap".  it only handles</span></span><br><span class="line"><span class="comment"> *  anonymous maps.  eventually we may be able to do some</span></span><br><span class="line"><span class="comment"> *  brk-specific accounting here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_brk_flags</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags, struct list_head *uf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">current</span>-&gt;<span class="title">mm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>, *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">rb_link</span>, *<span class="title">rb_parent</span>;</span></span><br><span class="line">......</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Clear old maps.  this also does some error checking for us</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (find_vma_links(mm, addr, addr + len, &amp;prev, &amp;rb_link,</span><br><span class="line">                  &amp;rb_parent)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (do_munmap(mm, addr, len, uf))</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* Can we just expand an old private anonymous mapping? */</span></span><br><span class="line">    vma = vma_merge(mm, prev, addr, addr + len, flags,</span><br><span class="line">            <span class="literal">NULL</span>, <span class="literal">NULL</span>, pgoff, <span class="literal">NULL</span>, NULL_VM_UFFD_CTX);</span><br><span class="line">    <span class="keyword">if</span> (vma)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * create a vma struct for an anonymous mapping</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    vma = vm_area_alloc(mm);</span><br><span class="line">    <span class="keyword">if</span> (!vma) &#123;</span><br><span class="line">        vm_unacct_memory(len &gt;&gt; PAGE_SHIFT);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    vma_set_anonymous(vma);</span><br><span class="line">    vma-&gt;vm_start = addr;</span><br><span class="line">    vma-&gt;vm_end = addr + len;</span><br><span class="line">    vma-&gt;vm_pgoff = pgoff;</span><br><span class="line">    vma-&gt;vm_flags = flags;</span><br><span class="line">    vma-&gt;vm_page_prot = vm_get_page_prot(flags);</span><br><span class="line">    vma_link(mm, vma, prev, rb_link, rb_parent);</span><br><span class="line">out:</span><br><span class="line">    perf_event_mmap(vma);</span><br><span class="line">    mm-&gt;total_vm += len &gt;&gt; PAGE_SHIFT;</span><br><span class="line">    mm-&gt;data_vm += len &gt;&gt; PAGE_SHIFT;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; VM_LOCKED)</span><br><span class="line">        mm-&gt;locked_vm += (len &gt;&gt; PAGE_SHIFT);</span><br><span class="line">    vma-&gt;vm_flags |= VM_SOFTDIRTY;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-大内存块申请"><a href="#2-2-大内存块申请" class="headerlink" title="2.2 大内存块申请"></a>2.2 大内存块申请</h3><p>&emsp;&emsp;大块内存的申请通过<code>mmap</code>系统调用实现，<code>mmap</code>既可以实现虚拟内存向物理内存的映射，也可以映射文件到自己的虚拟内存空间。映射文件时，实际是映射虚拟内存到物理内存再到文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE6(mmap, <span class="keyword">unsigned</span> <span class="keyword">long</span>, addr, <span class="keyword">unsigned</span> <span class="keyword">long</span>, len,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span>, prot, <span class="keyword">unsigned</span> <span class="keyword">long</span>, flags,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span>, fd, <span class="keyword">unsigned</span> <span class="keyword">long</span>, off)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">long</span> error;</span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (off &amp; ~PAGE_MASK)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    error = ksys_mmap_pgoff(addr, len, prot, flags, fd, off &gt;&gt; PAGE_SHIFT);</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里主要调用<code>ksys_mmap_pgoff()</code>函数，这里逻辑如下</p>
<ul>
<li>判断类型是否为匿名映射，如果不是则为文件映射，调用<code>fget()</code>获取文件描述符</li>
<li>如果是匿名映射，判断是否为大页，如果是则进行对齐处理并调用<code>hugetlb_file_setup()</code>获取文件描述符</li>
<li>调用<code>vm_mmap_pgoff()</code>函数找寻可以映射的区域并建立映射</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">ksys_mmap_pgoff</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">unsigned</span> <span class="keyword">long</span> prot, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">unsigned</span> <span class="keyword">long</span> fd, <span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> retval;</span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; MAP_ANONYMOUS)) &#123;</span><br><span class="line">        audit_mmap_fd(fd, flags);</span><br><span class="line">        file = fget(fd);</span><br><span class="line">        <span class="keyword">if</span> (!file)</span><br><span class="line">            <span class="keyword">return</span> -EBADF;</span><br><span class="line">        <span class="keyword">if</span> (is_file_hugepages(file))</span><br><span class="line">            len = ALIGN(len, huge_page_size(hstate_file(file)));</span><br><span class="line">        retval = -EINVAL;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(flags &amp; MAP_HUGETLB &amp;&amp; !is_file_hugepages(file)))</span><br><span class="line">            <span class="keyword">goto</span> out_fput;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; MAP_HUGETLB) &#123;</span><br><span class="line">        struct user_struct *user = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hstate</span> *<span class="title">hs</span>;</span></span><br><span class="line">        hs = hstate_sizelog((flags &gt;&gt; MAP_HUGE_SHIFT) &amp; MAP_HUGE_MASK);</span><br><span class="line">        <span class="keyword">if</span> (!hs)</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        len = ALIGN(len, huge_page_size(hs));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * VM_NORESERVE is used because the reservations will be</span></span><br><span class="line"><span class="comment">         * taken when vm_ops-&gt;mmap() is called</span></span><br><span class="line"><span class="comment">         * A dummy user value is used because we are not locking</span></span><br><span class="line"><span class="comment">         * memory so no accounting is necessary</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        file = hugetlb_file_setup(HUGETLB_ANON_FILE, len,</span><br><span class="line">                VM_NORESERVE,</span><br><span class="line">                &amp;user, HUGETLB_ANONHUGE_INODE,</span><br><span class="line">                (flags &gt;&gt; MAP_HUGE_SHIFT) &amp; MAP_HUGE_MASK);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(file))</span><br><span class="line">            <span class="keyword">return</span> PTR_ERR(file);</span><br><span class="line">    &#125;</span><br><span class="line">    flags &amp;= ~(MAP_EXECUTABLE | MAP_DENYWRITE);</span><br><span class="line">    retval = vm_mmap_pgoff(file, addr, len, prot, flags, pgoff);</span><br><span class="line">out_fput:</span><br><span class="line">    <span class="keyword">if</span> (file)</span><br><span class="line">        fput(file);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>vm_mmap_pgoff()</code>函数调用<code>do_mmap_pgoff()</code>，实际调用<code>do_mmap()</code>函数。这里<code>get_unmapped_area()</code>函数负责寻找可映射的区域，<code>mmap_region()</code>负责映射该区域。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The caller must hold down_write(&amp;current-&gt;mm-&gt;mmap_sem).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">do_mmap</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">unsigned</span> <span class="keyword">long</span> prot,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">unsigned</span> <span class="keyword">long</span> flags, <span class="keyword">vm_flags_t</span> vm_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff, <span class="keyword">unsigned</span> <span class="keyword">long</span> *populate,</span></span></span><br><span class="line"><span class="function"><span class="params">            struct list_head *uf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">current</span>-&gt;<span class="title">mm</span>;</span></span><br><span class="line">    <span class="keyword">int</span> pkey = <span class="number">0</span>;</span><br><span class="line">    *populate = <span class="number">0</span>;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* Obtain the address to map to. we verify (or select) it and ensure</span></span><br><span class="line"><span class="comment">     * that it represents a valid section of the address space.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    addr = get_unmapped_area(file, addr, len, pgoff, flags);</span><br><span class="line">......</span><br><span class="line">    addr = mmap_region(file, addr, len, vm_flags, pgoff, uf);</span><br><span class="line">    <span class="keyword">if</span> (!IS_ERR_VALUE(addr) &amp;&amp;</span><br><span class="line">        ((vm_flags &amp; VM_LOCKED) ||</span><br><span class="line">         (flags &amp; (MAP_POPULATE | MAP_NONBLOCK)) == MAP_POPULATE))</span><br><span class="line">        *populate = len;</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;首先来看看寻找映射区的函数<code>get_unmapped_area()</code>。</p>
<ul>
<li>如果是匿名映射，则调用<code>get_umapped_area</code>函数指针，这个函数其实是 <code>arch_get_unmapped_area()</code>。它会调用 <code>find_vma_prev()</code>，在表示虚拟内存区域的 <code>vm_area_struct</code> 红黑树上找到相应的位置。之所以叫 <code>prev</code>，是说这个时候虚拟内存区域还没有建立，找到前一个 <code>vm_area_struct</code>。</li>
<li>如果是映射到一个文件，在 Linux 里面每个打开的文件都有一个 <code>struct file</code> 结构，里面有一个 <code>file_operations</code>用来表示和这个文件相关的操作。如果是我们熟知的 <code>ext4</code> 文件系统，调用的也是<code>get_unmapped_area</code> 函数指针。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span></span><br><span class="line">get_unmapped_area(struct file *file, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> len,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*get_area)</span><span class="params">(struct file *, <span class="keyword">unsigned</span> <span class="keyword">long</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> error = arch_mmap_check(addr, len, flags);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    <span class="comment">/* Careful about overflows.. */</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt; TASK_SIZE)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    get_area = current-&gt;mm-&gt;get_unmapped_area;</span><br><span class="line">    <span class="keyword">if</span> (file) &#123;</span><br><span class="line">        <span class="keyword">if</span> (file-&gt;f_op-&gt;get_unmapped_area)</span><br><span class="line">            get_area = file-&gt;f_op-&gt;get_unmapped_area;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; MAP_SHARED) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * mmap_region() will call shmem_zero_setup() to create a file,</span></span><br><span class="line"><span class="comment">         * so use shmem's get_unmapped_area in case it can be huge.</span></span><br><span class="line"><span class="comment">         * do_mmap_pgoff() will clear pgoff, so match alignment.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        pgoff = <span class="number">0</span>;</span><br><span class="line">        get_area = shmem_get_unmapped_area;</span><br><span class="line">    &#125;</span><br><span class="line">    addr = get_area(file, addr, len, pgoff, flags);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR_VALUE(addr))</span><br><span class="line">        <span class="keyword">return</span> addr;</span><br><span class="line">    <span class="keyword">if</span> (addr &gt; TASK_SIZE - len)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    <span class="keyword">if</span> (offset_in_page(addr))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    error = security_mmap_addr(addr);</span><br><span class="line">    <span class="keyword">return</span> error ? error : addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>mmap_region()</code>首先会再次检测地址空间是否满足要求，然后清除旧的映射，校验内存的可用性，在一切均满足的情况下调用<code>vma_link()</code>将新创建的<code>vm_area_struct</code>结构挂在<code>mm_struct</code>内的红黑树上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">mmap_region</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">vm_flags_t</span> vm_flags, <span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct list_head *uf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">current</span>-&gt;<span class="title">mm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>, *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">rb_link</span>, *<span class="title">rb_parent</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> charged = <span class="number">0</span>;</span><br><span class="line">......</span><br><span class="line">    vma_link(mm, vma, prev, rb_link, rb_parent);</span><br><span class="line">    <span class="comment">/* Once vma denies write, undo our temporary denial count */</span></span><br><span class="line">    <span class="keyword">if</span> (file) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vm_flags &amp; VM_SHARED)</span><br><span class="line">            mapping_unmap_writable(file-&gt;f_mapping);</span><br><span class="line">        <span class="keyword">if</span> (vm_flags &amp; VM_DENYWRITE)</span><br><span class="line">            allow_write_access(file);</span><br><span class="line">    &#125;</span><br><span class="line">    file = vma-&gt;vm_file;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>vma_link()</code>本身是<code>__vma_link()</code>和<code>__vma_link_file()</code>的包裹函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">vma_link</span><span class="params">(struct mm_struct *mm, struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="function"><span class="params">            struct vm_area_struct *prev, struct rb_node **rb_link,</span></span></span><br><span class="line"><span class="function"><span class="params">            struct rb_node *rb_parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_file) &#123;</span><br><span class="line">        mapping = vma-&gt;vm_file-&gt;f_mapping;</span><br><span class="line">        i_mmap_lock_write(mapping);</span><br><span class="line">    &#125;</span><br><span class="line">    __vma_link(mm, vma, prev, rb_link, rb_parent);</span><br><span class="line">    __vma_link_file(vma);</span><br><span class="line">    <span class="keyword">if</span> (mapping)</span><br><span class="line">        i_mmap_unlock_write(mapping);</span><br><span class="line">    mm-&gt;map_count++;</span><br><span class="line">    validate_mm(mm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其中<code>__vma_link()</code>主要是链表和红黑表的插入，这属于基本数据结构操作，不展开讲解。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">__vma_link(struct mm_struct *mm, struct vm_area_struct *vma,</span><br><span class="line">    struct vm_area_struct *prev, struct rb_node **rb_link,</span><br><span class="line">    struct rb_node *rb_parent)</span><br><span class="line">&#123;</span><br><span class="line">    __vma_link_list(mm, vma, prev, rb_parent);</span><br><span class="line">    __vma_link_rb(mm, vma, rb_link, rb_parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;而<code>__vma_link_file()</code>会对文件映射进行处理，在<code>file</code>结构体中成员<code>f_mapping</code>指向<code>address_space</code>结构体，该结构体中存储红黑树<code>i_mmap</code>挂载<code>vm_area_struct</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __vma_link_file(struct vm_area_struct *vma)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    file = vma-&gt;vm_file;</span><br><span class="line">    <span class="keyword">if</span> (file) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span> = <span class="title">file</span>-&gt;<span class="title">f_mapping</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (vma-&gt;vm_flags &amp; VM_DENYWRITE)</span><br><span class="line">            atomic_dec(&amp;file_inode(file)-&gt;i_writecount);</span><br><span class="line">        <span class="keyword">if</span> (vma-&gt;vm_flags &amp; VM_SHARED)</span><br><span class="line">            atomic_inc(&amp;mapping-&gt;i_mmap_writable);</span><br><span class="line">        flush_dcache_mmap_lock(mapping);</span><br><span class="line">        vma_interval_tree_insert(vma, &amp;mapping-&gt;i_mmap);</span><br><span class="line">        flush_dcache_mmap_unlock(mapping);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;至此，我们完成了用户态内存的映射，但是此处仅在虚拟内存中建立了新的区域，尚未真正访问物理内存。物理内存的访问只有在调度到该进程时才会真正分配，即发生缺页异常时分配。</p>
<h2 id="三-用户态缺页异常"><a href="#三-用户态缺页异常" class="headerlink" title="三. 用户态缺页异常"></a>三. 用户态缺页异常</h2><p>&emsp;&emsp;一旦开始访问虚拟内存的某个地址，如果我们发现，并没有对应的物理页，那就触发缺页中断，调用 <code>do_page_fault()</code>。这里的逻辑如下</p>
<ul>
<li>判断是否为内核缺页中断<code>fault_in_kernel_space()</code>，如果是则调用<code>vmalloc_fault()</code></li>
<li>如果是用户态缺页异常，则调用<code>find_vma()</code>找到地址所在<code>vm_area_struct</code>区域</li>
<li>调用<code>handle_mm_fault()</code>映射找到的区域</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This routine handles page faults.  It determines the address,</span></span><br><span class="line"><span class="comment"> * and the problem, and then passes it off to one of the appropriate</span></span><br><span class="line"><span class="comment"> * routines.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">void</span> __kprobes <span class="title">do_page_fault</span><span class="params">(struct pt_regs *regs,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">unsigned</span> <span class="keyword">long</span> error_code,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">unsigned</span> <span class="keyword">long</span> address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We fault-in kernel-space virtual memory on-demand. The</span></span><br><span class="line"><span class="comment">     * 'reference' page table is init_mm.pgd.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * NOTE! We MUST NOT take any locks for this case. We may</span></span><br><span class="line"><span class="comment">     * be in an interrupt or a critical region, and should</span></span><br><span class="line"><span class="comment">     * only copy the information from the master page table,</span></span><br><span class="line"><span class="comment">     * nothing more.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(fault_in_kernel_space(address))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vmalloc_fault(address) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (notify_page_fault(regs, vec))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        bad_area_nosemaphore(regs, error_code, address);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    vma = find_vma(mm, address);</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If for any reason at all we couldn't handle the fault,</span></span><br><span class="line"><span class="comment">     * make sure we exit gracefully rather than endlessly redo</span></span><br><span class="line"><span class="comment">     * the fault.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    fault = handle_mm_fault(vma, address, flags);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>find_vma()</code>为红黑树查找操作，在此不做展开描述，下面重点看看<code>handle_mm_fault()</code>。这里经过一系列校验之后会根据是否是大页而选择调用<code>hugetlb_fault()</code>或者<code>__handle_mm_fault()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">vm_fault_t</span> <span class="title">handle_mm_fault</span><span class="params">(struct vm_area_struct *vma, <span class="keyword">unsigned</span> <span class="keyword">long</span> address,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (unlikely(is_vm_hugetlb_page(vma)))</span><br><span class="line">        ret = hugetlb_fault(vma-&gt;vm_mm, vma, address, flags);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret = __handle_mm_fault(vma, address, flags);</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>__handle_mm_fault()</code>完成实际上的映射操作。这里涉及到了由<code>pgd, p4g, pud, pmd, pte</code>组成的<a href="https://en.wikipedia.org/wiki/Intel_5-level_paging" target="_blank" rel="noopener">五级页表</a>，页表索引填充完后调用<code>handle_pte_fault()</code>创建页表项。</p>
<img src="https://static001.geekbang.org/resource/image/94/b3/94efd92cbeb4d4ff155a645b93d71eb3.jpg" alt="img" style="zoom: 25%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">vm_fault_t</span> __handle_mm_fault(struct vm_area_struct *vma,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_fault</span> <span class="title">vmf</span> = &#123;</span></span><br><span class="line">        .vma = vma,</span><br><span class="line">        .address = address &amp; PAGE_MASK,</span><br><span class="line">        .flags = flags,</span><br><span class="line">        .pgoff = linear_page_index(vma, address),</span><br><span class="line">        .gfp_mask = __get_fault_gfp_mask(vma),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> dirty = flags &amp; FAULT_FLAG_WRITE;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">vma</span>-&gt;<span class="title">vm_mm</span>;</span></span><br><span class="line">    <span class="keyword">pgd_t</span> *pgd;</span><br><span class="line">    <span class="keyword">p4d_t</span> *p4d;</span><br><span class="line">    <span class="keyword">vm_fault_t</span> ret;</span><br><span class="line">    pgd = pgd_offset(mm, address);</span><br><span class="line">    p4d = p4d_alloc(mm, pgd, address);</span><br><span class="line">......</span><br><span class="line">    vmf.pud = pud_alloc(mm, p4d, address);</span><br><span class="line">......</span><br><span class="line">    vmf.pmd = pmd_alloc(mm, vmf.pud, address);</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">return</span> handle_pte_fault(&amp;vmf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>handle_pte_fault()</code>处理以下三种情况</p>
<ul>
<li>页表项从未出现过，即新映射页表项<ul>
<li>匿名页映射，则映射到物理内存页，调用<code>do_anonymous_page()</code></li>
<li>文件映射，调用<code>do_fault()</code></li>
</ul>
</li>
<li>页表项曾出现过，则为从物理内存换出的页，调用<code>do_swap_page()</code>换回来</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These routines also need to handle stuff like marking pages dirty</span></span><br><span class="line"><span class="comment"> * and/or accessed for architectures that don't do it in hardware (most</span></span><br><span class="line"><span class="comment"> * RISC architectures).  The early dirtying is also good on the i386.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * There is also a hook called "update_mmu_cache()" that architectures</span></span><br><span class="line"><span class="comment"> * with external mmu caches can use to update those (ie the Sparc or</span></span><br><span class="line"><span class="comment"> * PowerPC hashed page tables that act as extended TLBs).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We enter with non-exclusive mmap_sem (to exclude vma changes, but allow</span></span><br><span class="line"><span class="comment"> * concurrent faults).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The mmap_sem may have been released depending on flags and our return value.</span></span><br><span class="line"><span class="comment"> * See filemap_fault() and __lock_page_or_retry().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">vm_fault_t</span> <span class="title">handle_pte_fault</span><span class="params">(struct vm_fault *vmf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pte_t</span> entry;</span><br><span class="line">......</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * A regular pmd is established and it can't morph into a huge</span></span><br><span class="line"><span class="comment">         * pmd from under us anymore at this point because we hold the</span></span><br><span class="line"><span class="comment">         * mmap_sem read mode and khugepaged takes it in write mode.</span></span><br><span class="line"><span class="comment">         * So now it's safe to run pte_offset_map().</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        vmf-&gt;pte = pte_offset_map(vmf-&gt;pmd, vmf-&gt;address);</span><br><span class="line">        vmf-&gt;orig_pte = *vmf-&gt;pte;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (!vmf-&gt;pte) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vma_is_anonymous(vmf-&gt;vma))</span><br><span class="line">            <span class="keyword">return</span> do_anonymous_page(vmf);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> do_fault(vmf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!pte_present(vmf-&gt;orig_pte))</span><br><span class="line">        <span class="keyword">return</span> do_swap_page(vmf);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-匿名页映射"><a href="#3-1-匿名页映射" class="headerlink" title="3.1 匿名页映射"></a>3.1 匿名页映射</h3><p>&emsp;&emsp;对于匿名页映射，流程如下</p>
<ul>
<li>调用<code>pte_alloc()</code>分配页表项</li>
<li>通过 <code>alloc_zeroed_user_highpage_movable()</code> 分配一个页，该函数会调用 <code>alloc_pages_vma()</code>，并最终调用 <code>__alloc_pages_nodemask()</code>。该函数是伙伴系统的核心函数，用于分配物理页面，在上文中已经详细分析过了。</li>
<li>调用<code>mk_pte()</code>将新分配的页表项指向分配的页</li>
<li>调用<code>set_pte_at()</code>将页表项加入该页</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We enter with non-exclusive mmap_sem (to exclude vma changes,</span></span><br><span class="line"><span class="comment"> * but allow concurrent faults), and pte mapped but not yet locked.</span></span><br><span class="line"><span class="comment"> * We return with mmap_sem still held, but pte unmapped and unlocked.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">vm_fault_t</span> <span class="title">do_anonymous_page</span><span class="params">(struct vm_fault *vmf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> = <span class="title">vmf</span>-&gt;<span class="title">vma</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">memcg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="keyword">vm_fault_t</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pte_t</span> entry;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Use pte_alloc() instead of pte_alloc_map().  We can't run</span></span><br><span class="line"><span class="comment">     * pte_offset_map() on pmds where a huge pmd might be created</span></span><br><span class="line"><span class="comment">     * from a different thread.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * pte_alloc_map() is safe to use under down_write(mmap_sem) or when</span></span><br><span class="line"><span class="comment">     * parallel threads are excluded by other means.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Here we only have down_read(mmap_sem).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (pte_alloc(vma-&gt;vm_mm, vmf-&gt;pmd))</span><br><span class="line">        <span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line">......</span><br><span class="line">    page = alloc_zeroed_user_highpage_movable(vma, vmf-&gt;address);</span><br><span class="line">......</span><br><span class="line">    entry = mk_pte(page, vma-&gt;vm_page_prot);</span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_flags &amp; VM_WRITE)</span><br><span class="line">        entry = pte_mkwrite(pte_mkdirty(entry));</span><br><span class="line">    vmf-&gt;pte = pte_offset_map_lock(vma-&gt;vm_mm, vmf-&gt;pmd, vmf-&gt;address,</span><br><span class="line">            &amp;vmf-&gt;ptl);</span><br><span class="line">......</span><br><span class="line">    set_pte_at(vma-&gt;vm_mm, vmf-&gt;address, vmf-&gt;pte, entry);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __alloc_zeroed_user_highpage(movableflags, vma, vaddr) \</span></span><br><span class="line">    alloc_page_vma(GFP_HIGHUSER | __GFP_ZERO | movableflags, vma, vaddr)</span><br></pre></td></tr></table></figure>

<h3 id="3-2-文件映射"><a href="#3-2-文件映射" class="headerlink" title="3.2 文件映射"></a>3.2 文件映射</h3><p>&emsp;&emsp;映射文件<code>do_fault()</code>函数调用了<code>fault</code>函数，该函数实际会根据不同的文件系统调用不同的函数，如<code>ext4</code>文件系统中<code>vm_ops</code>指向<code>ext4_file_vm_ops</code>，实际调用<code>ext4_filemap_fault()</code>函数，该函数会调用<code>filemap_fault()</code>完成实际的文件映射操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">vm_fault_t</span> <span class="title">do_fault</span><span class="params">(struct vm_fault *vmf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> = <span class="title">vmf</span>-&gt;<span class="title">vma</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span> = <span class="title">vma</span>-&gt;<span class="title">vm_mm</span>;</span></span><br><span class="line">    <span class="keyword">vm_fault_t</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!vma-&gt;vm_ops-&gt;fault) &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">vm_fault_t</span> <span class="title">ext4_filemap_fault</span><span class="params">(struct vm_fault *vmf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">    ret = filemap_fault(vmf);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>file_map_fault()</code>主要逻辑为</p>
<ul>
<li>调用<code>find_ge_page()</code>找到映射文件<code>vm_file</code>对应的物理内存缓存页面<ul>
<li>如果找到了，则调用<code>do_async_mmap_readahead()</code>，预读一些数据到内存里面</li>
<li>否则调用<code>pagecache_get_page()</code>分配一个缓存页，将该页加入LRU表中，并在<code>address_space</code>中调用</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">vm_fault_t</span> <span class="title">filemap_fault</span><span class="params">(struct vm_fault *vmf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> = <span class="title">vmf</span>-&gt;<span class="title">vma</span>-&gt;<span class="title">vm_file</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fpin</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span> = <span class="title">file</span>-&gt;<span class="title">f_mapping</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span> *<span class="title">ra</span> = &amp;<span class="title">file</span>-&gt;<span class="title">f_ra</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> = <span class="title">mapping</span>-&gt;<span class="title">host</span>;</span></span><br><span class="line">......</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Do we have something in the page cache already?</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    page = find_get_page(mapping, offset);</span><br><span class="line">    <span class="keyword">if</span> (likely(page) &amp;&amp; !(vmf-&gt;flags &amp; FAULT_FLAG_TRIED)) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * We found the page, so try async readahead before</span></span><br><span class="line"><span class="comment">         * waiting for the lock.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        fpin = do_async_mmap_readahead(vmf, page);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!page) &#123;</span><br><span class="line">        <span class="comment">/* No page in the page cache at all */</span></span><br><span class="line">......       </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">struct page *pagecache_get_page(struct address_space *mapping, <span class="keyword">pgoff_t</span> offset,</span><br><span class="line">    <span class="keyword">int</span> fgp_flags, <span class="keyword">gfp_t</span> gfp_mask)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">        page = __page_cache_alloc(gfp_mask);</span><br><span class="line">......</span><br><span class="line">        err = add_to_page_cache_lru(page, mapping, offset, gfp_mask);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-页交换"><a href="#3-3-页交换" class="headerlink" title="3.3 页交换"></a>3.3 页交换</h3><p>&emsp;&emsp;前文提到了我们会通过主动回收或者被动回收的方式将物理内存已映射的页面回收至硬盘中，当数据再次访问时，我们又需要通过<code>do_swap_page()</code>将其从硬盘中读回来。<code>do_swap_page()</code> 函数逻辑流程如下：查找 <code>swap</code> 文件有没有缓存页。如果没有，就调用 <code>swapin_readahead()</code>将 <code>swap</code> 文件读到内存中来形成内存页，并通过 <code>mk_pte()</code> 生成页表项。<code>set_pte_at</code> 将页表项插入页表，<code>swap_free</code> 将 <code>swap</code> 文件清理。因为重新加载回内存了，不再需要 <code>swap</code> 文件了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">vm_fault_t</span> <span class="title">do_swap_page</span><span class="params">(struct vm_fault *vmf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">    entry = pte_to_swp_entry(vmf-&gt;orig_pte);</span><br><span class="line">......</span><br><span class="line">    page = lookup_swap_cache(entry, vma, vmf-&gt;address);</span><br><span class="line">    swapcache = page;</span><br><span class="line">    <span class="keyword">if</span> (!page) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">swap_info_struct</span> *<span class="title">si</span> = <span class="title">swp_swap_info</span>(<span class="title">entry</span>);</span></span><br><span class="line">        <span class="keyword">if</span> (si-&gt;flags &amp; SWP_SYNCHRONOUS_IO &amp;&amp;</span><br><span class="line">                __swap_count(si, entry) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">/* skip swapcache */</span></span><br><span class="line">            page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma,</span><br><span class="line">                            vmf-&gt;address);</span><br><span class="line">......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            page = swapin_readahead(entry, GFP_HIGHUSER_MOVABLE,</span><br><span class="line">                        vmf);</span><br><span class="line">            swapcache = page;</span><br><span class="line">        &#125;</span><br><span class="line">......</span><br><span class="line">    pte = mk_pte(page, vma-&gt;vm_page_prot);</span><br><span class="line">......</span><br><span class="line">    set_pte_at(vma-&gt;vm_mm, vmf-&gt;address, vmf-&gt;pte, pte);</span><br><span class="line">    arch_do_swap_page(vma-&gt;vm_mm, vma, vmf-&gt;address, pte, vmf-&gt;orig_pte);</span><br><span class="line">    vmf-&gt;orig_pte = pte;</span><br><span class="line">......</span><br><span class="line">    swap_free(entry);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;通过以上步骤，用户态的缺页异常就处理完毕了。物理内存中有了页面，页表也建立好了映射。接下来，用户程序在虚拟内存空间里面可以通过虚拟地址顺利经过页表映射的访问物理页面上的数据了。页表一般都很大，只能存放在内存中。操作系统每次访问内存都要折腾两步，先通过查询页表得到物理地址，然后访问该物理地址读取指令、数据。为了加快映射速度，我们引入了 <a href="https://en.wikipedia.org/wiki/Translation_lookaside_buffer#:~:text=A%20translation%20lookaside%20buffer%20(TLB,called%20an%20address%2Dtranslation%20cache" target="_blank" rel="noopener">TLB</a>（Translation Lookaside Buffer），我们经常称为快表，专门用来做地址映射的硬件设备。它不在内存中，可存储的数据比较少，但是比内存要快。所以我们可以想象，TLB 就是页表的 Cache，其中存储了当前最可能被访问到的页表项，其内容是部分页表项的一个副本。有了 TLB 之后，我们先查块表，块表中有映射关系，然后直接转换为物理地址。如果在 TLB 查不到映射关系时，才会到内存中查询页表。</p>
<h2 id="四-内核态内存映射及缺页异常"><a href="#四-内核态内存映射及缺页异常" class="headerlink" title="四. 内核态内存映射及缺页异常"></a>四. 内核态内存映射及缺页异常</h2><p>&emsp;&emsp;和用户态使用<code>malloc()</code>类似，内核态也有相应的内存映射函数：<code>vmalloc()</code>可用于分配不连续物理页（使用伙伴系统），<code>kmem_cache_alloc()</code>和<code>kmem_cache_create()</code>使用slub分配器分配小块内存，而<code>kmalloc()</code>类似于<code>malloc()</code>，在分配大内存的时候会使用伙伴系统，分配小内存则使用slub分配器。分配内存后会转换为虚拟地址，保存在内核页表中进行映射，有需要时直接访问。由于<code>vmalloc()</code>会带来虚拟连续页和物理不连续页的映射，因此一般速度较慢，使用较少，相比而言<code>kmalloc()</code>使用的更为频繁。而<code>kmem_cache_alloc()</code>和<code>kmem_cache_create()</code>会分配更为精准的小内存块用于特定任务，因此也比较常用。</p>
<p>&emsp;&emsp;相对于用户态，内核态还有一种特殊的映射：临时映射。内核态高端内存地区为了节省空间会选择临时映射，采用<code>kmap_atomic()</code>实现。如果是 32 位有高端地址的，就需要调用 <code>set_pte</code> 通过内核页表进行临时映射；如果是 64 位没有高端地址的，就调用 <code>page_address</code>，里面会调用 <code>lowmem_page_address</code>。其实低端内存的映射，会直接使用 <code>__va</code> 进行临时映射。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">kmap_atomic_prot</span><span class="params">(struct page *page, <span class="keyword">pgprot_t</span> prot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (!PageHighMem(page))</span><br><span class="line">        <span class="keyword">return</span> page_address(page);</span><br><span class="line">......</span><br><span class="line">    vaddr = __fix_to_virt(FIX_KMAP_BEGIN + idx);</span><br><span class="line">    set_pte(kmap_pte-idx, mk_pte(page, prot));</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)vaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">kmap_atomic</span><span class="params">(struct page *page)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> kmap_atomic_prot(page, kmap_prot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *<span class="title">lowmem_page_address</span><span class="params">(<span class="keyword">const</span> struct page *page)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> page_to_virt(page);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> page_to_virt(x)  __va(PFN_PHYS(page_to_pfn(x)</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>kmap_atomic ()</code>发现没有页表的时候会直接创建页表进行映射。而 <code>vmalloc ()</code>只分配了内核的虚拟地址。所以访问它的时候，会产生缺页异常。内核态的缺页异常还是会调用 <code>do_page_fault()</code>，最终进入<code>vmalloc_fault()</code>。在这里会实现内核页表项的关联操作，从而完成分配，整体流程和用户态相似。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> noinline <span class="keyword">int</span> <span class="title">vmalloc_fault</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> pgd_paddr;</span><br><span class="line">    <span class="keyword">pmd_t</span> *pmd_k;</span><br><span class="line">    <span class="keyword">pte_t</span> *pte_k;</span><br><span class="line">    <span class="comment">/* Make sure we are in vmalloc area: */</span></span><br><span class="line">    <span class="keyword">if</span> (!(address &gt;= VMALLOC_START &amp;&amp; address &lt; VMALLOC_END))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Synchronize this task's top level page-table</span></span><br><span class="line"><span class="comment">     * with the 'reference' page table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Do _not_ use "current" here. We might be inside</span></span><br><span class="line"><span class="comment">     * an interrupt in the middle of a task switch..</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    pgd_paddr = read_cr3_pa();</span><br><span class="line">    pmd_k = vmalloc_sync_one(__va(pgd_paddr), address);</span><br><span class="line">    <span class="keyword">if</span> (!pmd_k)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    pte_k = pte_offset_kernel(pmd_k, address);</span><br><span class="line">    <span class="keyword">if</span> (!pte_present(*pte_k))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五. 总结"></a>五. 总结</h2><p>&emsp;&emsp;至此，我们分析了内存物理地址和虚拟地址的映射关系，结合前文页的分配和管理，内存部分的主要功能就算是大致分析清楚了，最后引用极客时间中的一幅图作为总结，算是全部知识点的汇总。</p>
<img src="https://static001.geekbang.org/resource/image/27/9a/274e22b3f5196a4c68bb6813fb643f9a.png" alt="img" style="zoom:33%;" />

<h2 id="代码资料"><a href="#代码资料" class="headerlink" title="代码资料"></a>代码资料</h2><p>[1] <a href="https://code.woboq.org/linux/linux/mm/mmap.c.html#191" target="_blank" rel="noopener">brk</a></p>
<p>[2] <a href="https://code.woboq.org/linux/linux/mm/mmap.c.html#ksys_mmap_pgoff" target="_blank" rel="noopener">mmap</a></p>
<p>[3] <a href="https://code.woboq.org/linux/linux/arch/sh/mm/fault.c.html#do_page_fault" target="_blank" rel="noopener">page_fault</a></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] wiki</p>
<p>[2] <a href="https://elixir.bootlin.com/linux/v5.7-rc1/source" target="_blank" rel="noopener">elixir.bootlin.com/linux</a></p>
<p>[3] <a href="https://code.woboq.org/" target="_blank" rel="noopener">woboq</a></p>
<p>[4] Linux-insides</p>
<p>[5] 深入理解Linux内核</p>
<p>[6] Linux内核设计的艺术</p>
<p>[7] 极客时间 趣谈Linux操作系统</p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创，坚持分享，谢谢鼓励和支持</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="Ty Chen 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="Ty Chen 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Ty Chen
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://ty-chen.github.io/linux-kernel-mmap/" title="Linux操作系统学习笔记（十）内存管理之内存映射">https://ty-chen.github.io/linux-kernel-mmap/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
            <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a>
          
            <a href="/tags/%E5%86%85%E5%AD%98/" rel="tag"># 内存</a>
          
            <a href="/tags/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/" rel="tag"># 内存映射</a>
          
            <a href="/tags/mmap/" rel="tag"># mmap</a>
          
            <a href="/tags/brk/" rel="tag"># brk</a>
          
            <a href="/tags/malloc/" rel="tag"># malloc</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/linux-kernel-mm-mgr/" rel="next" title="Linux操作系统学习笔记（九）内存管理之分页">
                <i class="fa fa-chevron-left"></i> Linux操作系统学习笔记（九）内存管理之分页
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/linux-kernel-fs/" rel="prev" title="Linux操作系统学习笔记（十一）文件系统">
                Linux操作系统学习笔记（十一）文件系统 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        
  <div class="bdsharebuttonbox">
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
    <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
    <a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a>
    <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
    <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a class="bds_count" data-cmd="count"></a>
  </div>
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "2",
        "bdMiniList": false,
        "bdPic": ""
      },
      "share": {
        "bdSize": "16",
        "bdStyle": "0"
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/me.JPG"
                alt="Ty Chen" />
            
              <p class="site-author-name" itemprop="name">Ty Chen</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">55</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Ty-Chen" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:tianyuch@hotmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Friends
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://lishouxian.cn/" title="Stanleylsx" target="_blank">Stanleylsx</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一-前言"><span class="nav-text">一. 前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二-用户态内存映射"><span class="nav-text">二. 用户态内存映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-小块内存申请"><span class="nav-text">2.1 小块内存申请</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-大内存块申请"><span class="nav-text">2.2 大内存块申请</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三-用户态缺页异常"><span class="nav-text">三. 用户态缺页异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-匿名页映射"><span class="nav-text">3.1 匿名页映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-文件映射"><span class="nav-text">3.2 文件映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-页交换"><span class="nav-text">3.3 页交换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四-内核态内存映射及缺页异常"><span class="nav-text">四. 内核态内存映射及缺页异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五-总结"><span class="nav-text">五. 总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码资料"><span class="nav-text">代码资料</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文献"><span class="nav-text">参考文献</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ty Chen</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">155.3k</span>
  
  <a href="http://www.beian.miit.gov.cn/" target="_blank" rel="noopener">粤ICP备20071543号</a> 
</div>









        
<div class="busuanzi-count">
	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>

  
    <span class="site-uv">
      你是来访的第
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      位同学
    </span>
  

  
    <span class="site-pv">
      访问次数：
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'aTqo2eFkO2Bn0AGX008uKDV7-gzGzoHsz',
        appKey: 'uJ6nxqW7RHWpAILCtttkJfJu',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
