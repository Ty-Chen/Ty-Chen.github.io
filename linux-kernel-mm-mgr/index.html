<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/kulamati128.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/kulamati32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/kulamati16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Linux,操作系统,内存,伙伴系统,Slub Allocator," />










<meta name="description" content="一. 前言&amp;emsp;&amp;emsp;上文分析了内存再用户态的结构体mm_struct及各个区域映射的vm_area_struct以及32位和64位的内核态结构体，本文将基于这些结构来分析Linux的内存管理系统。内存管理系统包括虚拟内存和物理内存的分页以及虚拟内存和物理内存的映射。本文将介绍分页机制，而映射则在下文中说明。本文首先简单介绍SMP和NUMA系统，然后对物理内存的节点、区域、页结构进行分">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux操作系统学习笔记（九）内存管理之分页">
<meta property="og:url" content="https://ty-chen.github.io/linux-kernel-mm-mgr/index.html">
<meta property="og:site_name" content="Ty-Chen&#39;s Home">
<meta property="og:description" content="一. 前言&amp;emsp;&amp;emsp;上文分析了内存再用户态的结构体mm_struct及各个区域映射的vm_area_struct以及32位和64位的内核态结构体，本文将基于这些结构来分析Linux的内存管理系统。内存管理系统包括虚拟内存和物理内存的分页以及虚拟内存和物理内存的映射。本文将介绍分页机制，而映射则在下文中说明。本文首先简单介绍SMP和NUMA系统，然后对物理内存的节点、区域、页结构进行分">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/be/d9/be6cabdecc2ec98893f67ebd5b9aead9.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/3f/4f/3fa8123990e5ae2c86859f70a8351f4f.jpeg">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/78/6d/78c8d44d7d8c08c03eee6f7a94652d6d.png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/c1/20/c1054f1e71037795c6f290e670b29120.png">
<meta property="article:published_time" content="2020-06-02T15:01:44.000Z">
<meta property="article:modified_time" content="2020-09-20T16:14:10.119Z">
<meta property="article:author" content="Ty Chen">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="内存">
<meta property="article:tag" content="伙伴系统">
<meta property="article:tag" content="Slub Allocator">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://static001.geekbang.org/resource/image/be/d9/be6cabdecc2ec98893f67ebd5b9aead9.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://ty-chen.github.io/linux-kernel-mm-mgr/"/>





  <title>Linux操作系统学习笔记（九）内存管理之分页 | Ty-Chen's Home</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ty-Chen's Home</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Collecting, sharing and creating knowledge</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ty-chen.github.io/linux-kernel-mm-mgr/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ty Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty-Chen's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Linux操作系统学习笔记（九）内存管理之分页</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-02T23:01:44+08:00">
                2020-06-02
              </time>
            

            

            
          </span>
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2020-09-21T00:14:10+08:00" content="2020-09-21">
                2020-09-21
              </time>
            </span>
          
          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index">
                    <span itemprop="name">Linux操作系统内核学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/linux-kernel-mm-mgr/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/linux-kernel-mm-mgr/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv">访问次数：
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  40
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h2><p>&emsp;&emsp;上文分析了内存再用户态的结构体<code>mm_struct</code>及各个区域映射的<code>vm_area_struct</code>以及32位和64位的内核态结构体，本文将基于这些结构来分析Linux的内存管理系统。内存管理系统包括虚拟内存和物理内存的分页以及虚拟内存和物理内存的映射。本文将介绍分页机制，而映射则在下文中说明。本文首先简单介绍<code>SMP</code>和<code>NUMA</code>系统，然后对物理内存的节点、区域、页结构进行分析，在此基础上剖析伙伴系统和<code>Slub Allocator</code>的实现原理，最后介绍页面交换。</p>
<a id="more"></a>

<h2 id="二-内存模型"><a href="#二-内存模型" class="headerlink" title="二. 内存模型"></a>二. 内存模型</h2><p>&emsp;&emsp;在计算机的发展历程中，内存模型经历了平坦内存模型、SMP和NUMA三种架构。</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Flat_memory_model" target="_blank" rel="noopener">平坦内存模型(Flat Memory Model)</a>，又称线性内存模型，在这种模式下，采取连续的物理地址和页，所以非常容易根据地址获取页号，反之亦然。此种布局非常简单，而且是线性增长，利于使用。但是随着内存需求的增大、进程数的变多、为了安全考虑，这种模型渐渐地无法满足要求。</li>
<li><a href="https://en.wikipedia.org/wiki/Symmetric_multiprocessing" target="_blank" rel="noopener">对称多处理 SMP(Symmetric MultiProcessing)</a>，是一种多处理器的电脑硬件架构，在对称多处理架构下，每个处理器的地位都是平等的，对资源的使用权限相同。现代多数的多处理器系统都采用对称多处理架构。在这个系统中，拥有超过一个以上的处理器，这些处理器都连接到同一个共享的主存上，并由单一操作系统来控制。在对称多处理系统上，在操作系统的支持下，无论进程是处于用户空间，或是内核态，都可以分配到任何一个处理器上运行。因此，进程可以在不同的处理器间移动，达到负载平衡，使系统的效率提升。</li>
<li><a href="https://en.wikipedia.org/wiki/Non-uniform_memory_access" target="_blank" rel="noopener">非均衡访存模型 NUMA(Non-Uniform Memory Access)</a>。在这种模式下，内存不是一整块。每个 CPU 都有自己的本地内存，CPU 访问本地内存不用过总线，因而速度要快很多，每个 CPU 和内存在一起，称为一个 NUMA 节点。但是，在本地内存不足的情况下，每个 CPU 都可以去另外的 NUMA 节点申请内存，这个时候访问延时就会比较长。</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/be/d9/be6cabdecc2ec98893f67ebd5b9aead9.png" alt="img"></p>
<h2 id="三-节点、区域和页"><a href="#三-节点、区域和页" class="headerlink" title="三. 节点、区域和页"></a>三. 节点、区域和页</h2><h3 id="3-1-节点"><a href="#3-1-节点" class="headerlink" title="3.1 节点"></a>3.1 节点</h3><p>&emsp;&emsp;这里主要分析NUMA模型。我们将内存分为多个节点对应多个CPU，每个节点再被分成一个一个的区域，每个区域有多个页面。由于页需要全局唯一定位，页还是需要有全局唯一的页号的。但是由于物理内存不是连起来的了，因此页号也就不再连续了。于是内存模型就变成了非连续内存模型。NUMA节点对应的结构为<code>pglist_data</code>，主要包括</p>
<ul>
<li>节点ID <code>node_id</code></li>
<li>节点区域相关：<code>node_zones</code>，<code>node_zonelists</code>，<code>nr_zones</code></li>
<li>节点的页数组：<code>node_mam_map</code></li>
<li>节点的起始页号：<code>node_start_pfn</code></li>
<li>节点中包含不连续的物理内存地址页数：<code>node_spanned_pages</code></li>
<li>可用的物理页面数目：<code>node_present_pates</code></li>
<li>页面回收、交换相关：<code>kswapd_wait</code>，<code>kswapd</code>，<code>kswapd_order</code>，<code>kswapd_failures</code>，<code>kswapd_classzone_idx</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On NUMA machines, each NUMA node would have a pg_data_t to describe</span></span><br><span class="line"><span class="comment"> * it's memory layout. On UMA machines there is a single pglist_data which</span></span><br><span class="line"><span class="comment"> * describes the whole memory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Memory statistics and page replacement data structures are maintained on a</span></span><br><span class="line"><span class="comment"> * per-zone basis.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zone</span> <span class="title">node_zones</span>[<span class="title">MAX_NR_ZONES</span>];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> <span class="title">node_zonelists</span>[<span class="title">MAX_ZONELISTS</span>];</span></span><br><span class="line">    <span class="keyword">int</span> nr_zones;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">node_mem_map</span>;</span>    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> node_start_pfn;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> node_present_pages; <span class="comment">/* total number of physical pages */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> node_spanned_pages; <span class="comment">/* total size of physical page range, including holes */</span></span><br><span class="line">    <span class="keyword">int</span> node_id;</span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> kswapd_wait;</span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> pfmemalloc_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kswapd</span>;</span>	<span class="comment">/* Protected by mem_hotplug_begin/end() */</span></span><br><span class="line">    <span class="keyword">int</span> kswapd_order;</span><br><span class="line">    <span class="keyword">enum</span> zone_type kswapd_classzone_idx;</span><br><span class="line">    <span class="keyword">int</span> kswapd_failures;		<span class="comment">/* Number of 'reclaimed == 0' runs */</span></span><br><span class="line">......</span><br><span class="line">&#125; <span class="keyword">pg_data_t</span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-区域"><a href="#3-2-区域" class="headerlink" title="3.2 区域"></a>3.2 区域</h3><p>每个节点可分成一个个的区域，<code>node_zones</code>存储了这些区域，<code>node_zonelist</code>以链表形式存储备用节点和它的内存区域的情况，<code>nr_zones</code>表示区域总数。区域的类型有如下几种，在上节中已简单提过，这里详细说明。</p>
<ul>
<li>ZONE_DMA 是指可用于作 DMA（Direct Memory Access，直接内存存取）的内存。DMA 是这样一种机制：要把外设的数据读入内存或把内存的数据传送到外设，原来都要通过 CPU 控制完成，但是这会占用 CPU，影响 CPU 处理其他事情，所以有了 DMA 模式。CPU 只需向 DMA 控制器下达指令，让 DMA 控制器来处理数据的传送，数据传送完毕再把信息反馈给 CPU，这样就可以解放 CPU。对于 64 位系统，有两个 DMA 区域。除了上面说的 ZONE_DMA，还有 ZONE_DMA32。</li>
<li>ZONE_NORMAL 是直接映射区，即内核态前896M空间</li>
<li>ZONE_HIGHMEM 是高端内存区，对于 32 位系统来说超过 896M 的地方，对于 64 位没必要有的一段区域。</li>
<li>ZONE_MOVABLE 是可移动区域，通过将物理内存划分为可移动分配区域和不可移动分配区域来避免内存碎片。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">enum</span> zone_type &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ZONE_DMA</span></span><br><span class="line">    ZONE_DMA,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ZONE_DMA32</span></span><br><span class="line">    ZONE_DMA32,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ZONE_NORMAL,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HIGHMEM</span></span><br><span class="line">    ZONE_HIGHMEM,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ZONE_MOVABLE,</span><br><span class="line">    __MAX_NR_ZONES</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>区域的实现数据结构为<code>zone</code>，主要包括</p>
<ul>
<li>区域初始页<code>zone_start_pfn</code></li>
<li>区域总共跨多少页 <code>spanned_pages</code></li>
<li>区域在物理内存中真实存在的页数<code>present_pages</code></li>
<li>区域被伙伴系统管理的所有页数<code>managed_pages</code></li>
<li>冷热页区分<code>per_cpu_pagest</code>：如果一个页被加载到 CPU 高速缓存里面，这就是一个热页（Hot Page），CPU 读起来速度会快很多，如果没有就是冷页（Cold Page）。由于每个 CPU 都有自己的高速缓存，因而 <code>per_cpu_pageset</code> 也是每个 CPU 一个。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">......</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span>	*<span class="title">zone_pgdat</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pageset</span> __<span class="title">percpu</span> *<span class="title">pageset</span>;</span></span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>		zone_start_pfn;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * spanned_pages is the total pages spanned by the zone, including</span></span><br><span class="line"><span class="comment">     * holes, which is calculated as:</span></span><br><span class="line"><span class="comment">     * 	spanned_pages = zone_end_pfn - zone_start_pfn;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * present_pages is physical pages existing within the zone, which</span></span><br><span class="line"><span class="comment">     * is calculated as:</span></span><br><span class="line"><span class="comment">     *	present_pages = spanned_pages - absent_pages(pages in holes);</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * managed_pages is present pages managed by the buddy system, which</span></span><br><span class="line"><span class="comment">     * is calculated as (reserved_pages includes pages allocated by the</span></span><br><span class="line"><span class="comment">     * bootmem allocator):</span></span><br><span class="line"><span class="comment">     *	managed_pages = present_pages - reserved_pages;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * So present_pages may be used by memory hotplug or memory power</span></span><br><span class="line"><span class="comment">     * management logic to figure out unmanaged pages by checking</span></span><br><span class="line"><span class="comment">     * (present_pages - managed_pages). And managed_pages should be used</span></span><br><span class="line"><span class="comment">     * by page allocator and vm scanner to calculate all kinds of watermarks</span></span><br><span class="line"><span class="comment">     * and thresholds.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Locking rules:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * zone_start_pfn and spanned_pages are protected by span_seqlock.</span></span><br><span class="line"><span class="comment">     * It is a seqlock because it has to be read outside of zone-&gt;lock,</span></span><br><span class="line"><span class="comment">     * and it is done in the main allocator path.  But, it is written</span></span><br><span class="line"><span class="comment">     * quite infrequently.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The span_seq lock is declared along with zone-&gt;lock because it is</span></span><br><span class="line"><span class="comment">     * frequently read in proximity to zone-&gt;lock.  It's good to</span></span><br><span class="line"><span class="comment">     * give them a chance of being in the same cacheline.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Write access to present_pages at runtime should be protected by</span></span><br><span class="line"><span class="comment">     * mem_hotplug_begin/end(). Any reader who can't tolerant drift of</span></span><br><span class="line"><span class="comment">     * present_pages should get_online_mems() to get a stable value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">atomic_long_t</span>		managed_pages;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>		spanned_pages;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>		present_pages;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">int</span> initialized;</span><br><span class="line">    <span class="comment">/* Write-intensive fields used from the page allocator */</span></span><br><span class="line">    ZONE_PADDING(_pad1_)</span><br><span class="line">    <span class="comment">/* free areas of different sizes */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>	<span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br><span class="line">    <span class="comment">/* zone flags, see below */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>		flags;</span><br><span class="line">    <span class="comment">/* Primarily protects free_area */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>		lock;</span><br><span class="line">    <span class="comment">/* Write-intensive fields used by compaction and vmstats. */</span></span><br><span class="line">    ZONE_PADDING(_pad2_)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * When free pages are below this point, additional steps are taken</span></span><br><span class="line"><span class="comment">     * when reading the number of free pages to avoid per-cpu counter</span></span><br><span class="line"><span class="comment">     * drift allowing watermarks to be breached</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> percpu_drift_mark;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">bool</span>			contiguous;</span><br><span class="line">    ZONE_PADDING(_pad3_)</span><br><span class="line">    <span class="comment">/* Zone statistics */</span></span><br><span class="line">    <span class="keyword">atomic_long_t</span>		vm_stat[NR_VM_ZONE_STAT_ITEMS];</span><br><span class="line">    <span class="keyword">atomic_long_t</span>		vm_numa_stat[NR_VM_NUMA_STAT_ITEMS];</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-页"><a href="#3-3-页" class="headerlink" title="3.3 页"></a>3.3 页</h3><p>每个区域有很多个页，现在让我们将目光投向页的结构<code>page</code>。页中使用了大量的联合，其原因在于页有着多种不同的使用方式。</p>
<ul>
<li>整页使用方式。在前面介绍过，该种情况也存在两种页，一种是直接映射虚拟地址空间的匿名页（Anonymous Page），另一种则是用于关联文件、然后再和虚拟地址空间建立映射的页，称之为<a href="https://en.wikipedia.org/wiki/Memory-mapped_file" target="_blank" rel="noopener">内存映射文件（Memory-mapped File）</a>。对于该种模式，会使用联合里的以下变量<ul>
<li><code>struct address_space *mapping</code> ：用于内存映射，如果是匿名页，最低位为 1；如果是映射文件，最低位为 0</li>
<li><code>pgoff_t index</code> ：映射区的偏移量</li>
<li><code>atomic_t _mapcount</code>：指向该页的页表数</li>
<li><code>struct list_head lru</code> ：表示这一页应该在一个链表上，例如这个页面被换出，就在换出页的链表中；</li>
<li><code>compound</code> 相关的变量用于复合页（Compound Page），就是将物理上连续的两个或多个页看成一个独立的大页。</li>
</ul>
</li>
<li>小块内存使用方式。在很多情况下，我们只需要使用少量内存，因此采用了<a href="https://en.wikipedia.org/wiki/Slab_allocation" target="_blank" rel="noopener"><strong>slab allocator</strong>技术</a>用于分配小块内存<code>slab</code>。它的基本原理是从内存管理模块申请一整块页，然后划分成多个小块的存储池，用复杂的队列来维护这些小块的状态（状态包括：被分配了 / 被放回池子 / 应该被回收）。也正是因为 <code>slab allocator</code> 对于队列的维护过于复杂，后来就有了一种不使用队列的分配器 <code>slub allocator</code>，但是里面还是用了很多 带有<code>slab</code>的API ，因为它保留了 <code>slab</code> 的用户接口，可以看成 slab allocator 的另一种实现。该种模式会使用联合里的以下变量<ul>
<li><code>s_mem</code> ：正在使用的 slab 的第一个对象</li>
<li><code>freelist</code> ：池子中的空闲对象</li>
<li><code>rcu_head</code> ：需要释放的列表</li>
</ul>
</li>
<li>小块内存分配器slob，非常简单，常用于小型嵌入式系统</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;		<span class="comment">/* Atomic flags, some possibly updated asynchronously */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Five words (20/40 bytes) are available in this union.</span></span><br><span class="line"><span class="comment">     * WARNING: bit 0 of the first word is used for PageTail(). That</span></span><br><span class="line"><span class="comment">     * means the other users of this union MUST NOT use the bit to</span></span><br><span class="line"><span class="comment">     * avoid collision and false-positive PageTail().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* Page cache and anonymous pages */</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * @lru: Pageout list, eg. active_list protected by</span></span><br><span class="line"><span class="comment">             * pgdat-&gt;lru_lock.  Sometimes used as a generic list</span></span><br><span class="line"><span class="comment">             * by the page owner.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span></span><br><span class="line">            <span class="comment">/* See page-flags.h for PAGE_MAPPING_FLAGS */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span></span><br><span class="line">            <span class="keyword">pgoff_t</span> index;		<span class="comment">/* Our offset within mapping. */</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * @private: Mapping-private opaque data.</span></span><br><span class="line"><span class="comment">             * Usually used for buffer_heads if PagePrivate.</span></span><br><span class="line"><span class="comment">             * Used for swp_entry_t if PageSwapCache.</span></span><br><span class="line"><span class="comment">             * Indicates order in the buddy system if PageBuddy.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* page_pool used by netstack */</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * @dma_addr: might require a 64-bit value even on</span></span><br><span class="line"><span class="comment">             * 32-bit architectures.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">dma_addr_t</span> dma_addr;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* slab, slob and slub */</span></span><br><span class="line">            <span class="keyword">union</span> &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span>	<span class="comment">/* uses lru */</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* Partial pages */</span></span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">next</span>;</span></span><br><span class="line">......</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span> <span class="comment">/* not slob */</span></span><br><span class="line">            <span class="comment">/* Double-word boundary */</span></span><br><span class="line">            <span class="keyword">void</span> *freelist;		<span class="comment">/* first free object */</span></span><br><span class="line">            <span class="keyword">union</span> &#123;</span><br><span class="line">                <span class="keyword">void</span> *s_mem;	<span class="comment">/* slab: first object */</span></span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> counters;		<span class="comment">/* SLUB */</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span>			<span class="comment">/* SLUB */</span></span><br><span class="line">                    <span class="keyword">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line">                    <span class="keyword">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line">                    <span class="keyword">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">......</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* ZONE_DEVICE pages */</span></span><br><span class="line">            <span class="comment">/** @pgmap: Points to the hosting device page map. */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">dev_pagemap</span> *<span class="title">pgmap</span>;</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> hmm_data;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> _zd_pad_1;	<span class="comment">/* uses mapping */</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/** @rcu_head: You can use this to free a page by RCU. */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">......</span><br><span class="line">&#125; _struct_page_alignment;</span><br></pre></td></tr></table></figure>

<h2 id="四-用户态页的分配"><a href="#四-用户态页的分配" class="headerlink" title="四. 用户态页的分配"></a>四. 用户态页的分配</h2><p>&emsp;&emsp;在上节中我们介绍了页按大小分配大致有伙伴系统和小块内存分配的slub分配。本节就这两种展开讨论。</p>
<h3 id="4-1-伙伴系统"><a href="#4-1-伙伴系统" class="headerlink" title="4.1 伙伴系统"></a>4.1 伙伴系统</h3><p>&emsp;&emsp;对于要分配比较大的内存，例如到分配页级别的，可以使用<a href="https://en.wikipedia.org/wiki/Buddy_memory_allocation" target="_blank" rel="noopener">伙伴系统（Buddy System）</a>。伙伴分配机制可以归纳如下。</p>
<ul>
<li>采取多个链表将空闲页组织起来，每个链表中的节点包含的页块数目不同，即第<code>i</code>个链表中的每个节点拥有<code>2^i</code>个页。</li>
<li>当向内核请求分配 <code>(2^(i-1)，2^i]</code>数目的页块时，按照 <code>2^i</code> 页块请求处理，并将其分裂。</li>
<li>如果对应的页块链表中没有空闲页块，那我们就在更大的页块链表中去找，并对其进行分裂。如请求128个页，如果128页块链表无空闲则请求256链表，并将其分裂为两个128链表。</li>
</ul>
<p>&emsp;&emsp;源码实现于<code>alloc_pages()</code>中，传参的定义如注释中所示，<code>order</code>表示分配2的<code>order</code>次方个页，<code>gfp_mask</code>表示分配区域，主要有</p>
<ul>
<li>GFP_USER：用于一个用户进程希望通过内存映射的方式访问某些硬件的缓存，例如显卡缓存</li>
<li>GFP_KERNEL：用于内核中分配页，主要分配 ZONE_NORMAL 区域，也即直接映射区</li>
<li>GFP_HIGHMEM：用于分配高端内存区域</li>
<li>GFP_FS：用于文件映射区</li>
<li>GFP_ATOMIC：表示该页内容不会进入休眠</li>
</ul>
<p>&emsp;&emsp;这里涉及到了一种加快内存速度的技术：<a href="https://en.wikipedia.org/wiki/Interleaved_memory" target="_blank" rel="noopener">交叉存取技术（interleaved memory）</a>。该存储方式会将存储体分为多个模块，每个模块类似于负载均衡逐个写入，这样当前字节被刷新时，可以不影响下一个字节的访问。交叉存储主要补偿DRAM等存储器相对较慢的读写速度。读或写每一个内存块，都需要等待内存块给出ready信号，才能读写下一字节。交叉存储将连续信息分散到各个块中，读写时可以同时等待多个内存块给出ready信号，从而提高了读写的速度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class"><span class="title">alloc_pages</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> alloc_pages_current(gfp_mask, order);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 	alloc_pages_current - Allocate pages.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	@gfp:</span></span><br><span class="line"><span class="comment"> *		    %GFP_USER   user allocation,</span></span><br><span class="line"><span class="comment"> *      	%GFP_KERNEL kernel allocation,</span></span><br><span class="line"><span class="comment"> *      	%GFP_HIGHMEM highmem allocation,</span></span><br><span class="line"><span class="comment"> *      	%GFP_FS     don't call back into a file system.</span></span><br><span class="line"><span class="comment"> *      	%GFP_ATOMIC don't sleep.</span></span><br><span class="line"><span class="comment"> *	@order: Power of two of allocation size in pages. 0 is a single page.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Allocate a page from the kernel page pool.  When not in</span></span><br><span class="line"><span class="comment"> *	interrupt context and apply the current process NUMA policy.</span></span><br><span class="line"><span class="comment"> *	Returns NULL when no page can be allocated.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct page *<span class="title">alloc_pages_current</span><span class="params">(<span class="keyword">gfp_t</span> gfp, <span class="keyword">unsigned</span> order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span> *<span class="title">pol</span> = &amp;<span class="title">default_policy</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!in_interrupt() &amp;&amp; !(gfp &amp; __GFP_THISNODE))</span><br><span class="line">        pol = get_task_policy(current);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * No reference counting needed for current-&gt;mempolicy</span></span><br><span class="line"><span class="comment">     * nor system default_policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (pol-&gt;mode == MPOL_INTERLEAVE)</span><br><span class="line">        page = alloc_page_interleave(gfp, order, interleave_nodes(pol));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        page = __alloc_pages_nodemask(gfp, order,</span><br><span class="line">                policy_node(gfp, pol, numa_node_id()),</span><br><span class="line">                policy_nodemask(gfp, pol));</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(alloc_pages_current);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;交叉存取的<code>alloc_page_interleave()</code>函数实际上通过调用<code>__alloc_page()</code>最终也会调用<code>__alloc_pages_nodemask()</code>函数来实现分配。<code>__alloc_pages_nodemask()</code>是伙伴系统的核心方法，它会调用 <code>get_page_from_freelist()</code>在一个循环中轮询区域，先看当前节点的 zone，如果找不到空闲页则再看备用节点的 zone，直到找到为止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the 'heart' of the zoned buddy allocator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages_nodemask</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">preferred_nid</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">nodemask_t</span> *<span class="title">nodemask</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> alloc_flags = ALLOC_WMARK_LOW;</span><br><span class="line">    <span class="keyword">gfp_t</span> alloc_mask; <span class="comment">/* The gfp_t that was actually used for allocation */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">alloc_context</span> <span class="title">ac</span> = &#123;</span> &#125;;</span><br><span class="line">......</span><br><span class="line">    gfp_mask &amp;= gfp_allowed_mask;</span><br><span class="line">    alloc_mask = gfp_mask;</span><br><span class="line">    <span class="keyword">if</span> (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &amp;ac, &amp;alloc_mask, &amp;alloc_flags))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    finalise_ac(gfp_mask, &amp;ac);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Forbid the first pass from falling back to types that fragment</span></span><br><span class="line"><span class="comment">     * memory until all local zones are considered.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    alloc_flags |= alloc_flags_nofragment(ac.preferred_zoneref-&gt;zone, gfp_mask);</span><br><span class="line">    <span class="comment">/* First allocation attempt */</span></span><br><span class="line">    page = get_page_from_freelist(alloc_mask, order, alloc_flags, &amp;ac);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__alloc_pages_nodemask);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>get_page_from_freelist()</code>函数如下所示，主要调用<code>rmqueue()</code>找寻合适大小的队列，并取出页面。通过<code>rmqueue()-&gt;__rmqueue()-&gt;__rmqueue_smallest()</code>最终来到<code>__rmqueue_smallest()函数</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * get_page_from_freelist goes through the zonelist trying to allocate</span></span><br><span class="line"><span class="comment"> * a page.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class"><span class="title">get_page_from_freelist</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">alloc_flags</span>,</span></span><br><span class="line"><span class="class">                        <span class="title">const</span> <span class="title">struct</span> <span class="title">alloc_context</span> *<span class="title">ac</span>)</span></span><br><span class="line"><span class="class">&#123;</span>	</span><br><span class="line">......</span><br><span class="line">    for_next_zone_zonelist_nodemask(zone, z, ac-&gt;zonelist, ac-&gt;high_zoneidx,</span><br><span class="line">                                ac-&gt;nodemask) &#123;</span><br><span class="line">......</span><br><span class="line">        page = rmqueue(ac-&gt;preferred_zoneref-&gt;zone, zone, order,</span><br><span class="line">                gfp_mask, alloc_flags, ac-&gt;migratetype);</span><br><span class="line">        <span class="keyword">if</span> (page) &#123;</span><br><span class="line">            prep_new_page(page, order, gfp_mask, alloc_flags);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * If this is a high-order atomic allocation then check</span></span><br><span class="line"><span class="comment">             * if the pageblock should be reserved for the future</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (unlikely(order &amp;&amp; (alloc_flags &amp; ALLOC_HARDER)))</span><br><span class="line">                reserve_highatomic_pageblock(page, zone, order);</span><br><span class="line">            <span class="keyword">return</span> page;</span><br><span class="line">        &#125; </span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在<code>__rmqueue_smallest()</code>中，实现了伙伴系统的找寻逻辑。从当前的<code>order</code>开始循环，如果<code>page</code>为空则<code>order++</code>，否则从当前链表<code>lru</code>中删除该页块，通过<code>expand()</code>函数将该区域剩余页块分配到其他对应的<code>order</code>链表中，最后返回该页块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Go through the free lists for the given migratetype and remove</span></span><br><span class="line"><span class="comment"> * the smallest available page from the freelists</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> __always_inline</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">rmqueue_smallest</span>(<span class="title">struct</span> <span class="title">zone</span> *<span class="title">zone</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class">                        <span class="title">int</span> <span class="title">migratetype</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> current_order;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> *<span class="title">area</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="comment">/* Find a page of the appropriate size in the preferred list */</span></span><br><span class="line">    <span class="keyword">for</span> (current_order = order; current_order &lt; MAX_ORDER; ++current_order) &#123;</span><br><span class="line">        area = &amp;(zone-&gt;free_area[current_order]);</span><br><span class="line">        page = list_first_entry_or_null(&amp;area-&gt;free_list[migratetype],</span><br><span class="line">                            struct page, lru);</span><br><span class="line">        <span class="keyword">if</span> (!page)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        list_del(&amp;page-&gt;lru);</span><br><span class="line">        rmv_page_order(page);</span><br><span class="line">        area-&gt;nr_free--;</span><br><span class="line">        expand(zone, page, order, current_order, area, migratetype);</span><br><span class="line">        set_pcppage_migratetype(page, migratetype);</span><br><span class="line">        <span class="keyword">return</span> page;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>expand()</code>函数中将页块区域前移，<code>size</code>右移即除2，然后使用<code>list_add</code>加入链表之中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The order of subdivision here is critical for the IO subsystem.</span></span><br><span class="line"><span class="comment"> * Please do not alter this order without good reasons and regression</span></span><br><span class="line"><span class="comment"> * testing. Specifically, as large blocks of memory are subdivided,</span></span><br><span class="line"><span class="comment"> * the order in which smaller blocks are delivered depends on the order</span></span><br><span class="line"><span class="comment"> * they're subdivided in this function. This is the primary factor</span></span><br><span class="line"><span class="comment"> * influencing the order in which pages are delivered to the IO</span></span><br><span class="line"><span class="comment"> * subsystem according to empirical testing, and this is also justified</span></span><br><span class="line"><span class="comment"> * by considering the behavior of a buddy system containing a single</span></span><br><span class="line"><span class="comment"> * large block of memory acted on by a series of small allocations.</span></span><br><span class="line"><span class="comment"> * This behavior is a critical factor in sglist merging's success.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -- nyc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">expand</span><span class="params">(struct zone *zone, struct page *page,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> low, <span class="keyword">int</span> high, struct free_area *area,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> migratetype)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span> = <span class="number">1</span> &lt;&lt; high;</span><br><span class="line">    <span class="keyword">while</span> (high &gt; low) &#123;</span><br><span class="line">        area--;</span><br><span class="line">        high--;</span><br><span class="line">        <span class="built_in">size</span> &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        VM_BUG_ON_PAGE(bad_range(zone, &amp;page[<span class="built_in">size</span>]), &amp;page[<span class="built_in">size</span>]);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Mark as guard pages (or page), that will allow to</span></span><br><span class="line"><span class="comment">         * merge back to allocator when buddy will be freed.</span></span><br><span class="line"><span class="comment">         * Corresponding page table entries will not be touched,</span></span><br><span class="line"><span class="comment">         * pages will stay not present in virtual address space</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (set_page_guard(zone, &amp;page[<span class="built_in">size</span>], high, migratetype))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        list_add(&amp;page[<span class="built_in">size</span>].lru, &amp;area-&gt;free_list[migratetype]);</span><br><span class="line">        area-&gt;nr_free++;</span><br><span class="line">        set_page_order(&amp;page[<span class="built_in">size</span>], high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后以一张结构图作为总结</p>
<img src="https://static001.geekbang.org/resource/image/3f/4f/3fa8123990e5ae2c86859f70a8351f4f.jpeg" alt="img" style="zoom: 25%;" />

<h3 id="4-2-slub-allocator"><a href="#4-2-slub-allocator" class="headerlink" title="4.2 slub allocator"></a>4.2 <code>slub allocator</code></h3><p>&emsp;&emsp;任务<code>task_struct</code>在派生时，会调用<code>alloc_task_struct_node()</code>分配<code>task_struct</code>对象，其底层调用<code>kmem_cache_alloc_node()</code>函数在<code>task_struct</code>的缓存区域<code>kmem_cache *task_struct_cachep</code>分配内存。在系统初始化的时候，<code>task_struct_cachep</code> 会被 <code>kmem_cache_create()</code> 函数创建。这个函数专门用于分配 <code>task_struct</code> 对象的缓存。这个缓存区的名字就叫 <code>task_struct</code>。</p>
<p>&emsp;&emsp;缓存区中每一块的大小正好等于 <code>task_struct</code> 的大小，也即 <code>arch_task_struct_size</code>。有了这个缓存区，每次创建 <code>task_struct</code> 的时候，先调用 <code>kmem_cache_alloc_node()</code>函数在缓存里面看看有没有直接可用的。当一个进程结束，<code>task_struct</code> 也不用直接被销毁，而是调用<code>kmem_cache_free()</code>放回到缓存中。这样，新进程创建的时候，我们就可以直接用现成的缓存中的 <code>task_struct</code> 了，从而加快了申请、释放速度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">task_struct_cachep</span>;</span></span><br><span class="line"></span><br><span class="line">task_struct_cachep = kmem_cache_create(<span class="string">"task_struct"</span>,</span><br><span class="line">      arch_task_struct_size, align,</span><br><span class="line">      SLAB_PANIC|SLAB_NOTRACK|SLAB_ACCOUNT, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct task_struct *<span class="title">alloc_task_struct_node</span><span class="params">(<span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> kmem_cache_alloc_node(task_struct_cachep, GFP_KERNEL, node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">free_task_struct</span><span class="params">(struct task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kmem_cache_free(task_struct_cachep, tsk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;下面分析一下缓冲区<code>kmem_cache</code>结构体。</p>
<ul>
<li><code>kmem_cached_cpu</code>和<code>kmem_cached_node</code>：每个NUMA节点都对应一个，分别是缓存分配的<code>fast path</code>和<code>slow path</code>。每次分配的时候，要先从 <code>kmem_cache_cpu</code> 进行分配。如果 <code>kmem_cache_cpu</code> 里面没有空闲的块，那就到 <code>kmem_cache_node</code> 中进行分配；如果还是没有空闲的块，才去伙伴系统分配新的页。</li>
<li><code>size</code>，<code>object_size</code>和<code>offset</code>：通过链表<code>list_head</code>，所有的小内存块会联系起来存放在缓冲区，用于<code>task_struct</code>、<code>mm_struct</code>、<code>fs_struct</code>等申请小内存块，<code>object_size</code>表示某内存块的大小，<code>size</code>表示该内存块加上指针的总大小，<code>offset</code>表示下一个空闲内存块的指针的偏移量。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Slab cache management.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> __<span class="title">percpu</span> *<span class="title">cpu_slab</span>;</span></span><br><span class="line">    <span class="comment">/* Used for retrieving partial slabs, etc. */</span></span><br><span class="line">    <span class="keyword">slab_flags_t</span> flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> min_partial;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">size</span>;	<span class="comment">/* The size of an object including metadata */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> object_size;<span class="comment">/* The size of an object without metadata */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> offset;	<span class="comment">/* Free pointer offset */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">    <span class="comment">/* Number of per cpu partial objects to keep around */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> cpu_partial;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">oo</span>;</span></span><br><span class="line">    <span class="comment">/* Allocation and freeing of slabs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">max</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">min</span>;</span></span><br><span class="line">    <span class="keyword">gfp_t</span> allocflags;	<span class="comment">/* gfp flags to use on each alloc */</span></span><br><span class="line">    <span class="keyword">int</span> refcount;		<span class="comment">/* Refcount for slab cache destroy */</span></span><br><span class="line">    <span class="keyword">void</span> (*ctor)(<span class="keyword">void</span> *);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> inuse;		<span class="comment">/* Offset to metadata */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> align;		<span class="comment">/* Alignment */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> red_left_pad;	<span class="comment">/* Left redzone padding size */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;	<span class="comment">/* Name (only for display!) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>	<span class="comment">/* List of slab caches */</span></span><br><span class="line">......</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> useroffset;	<span class="comment">/* Usercopy region offset */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> usersize;		<span class="comment">/* Usercopy region size */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">node</span>[<span class="title">MAX_NUMNODES</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;首先来看看快分配方式<code>kmem_cached_cpu</code>，该结构体中<code>page</code>指向内存页块的第一页，<code>freelist</code>指向下一个可用的内存页块，<code>partial</code>表示部分被分配部分为空的页，该项为备用项，仅当<code>page</code>满了才会在<code>partial</code>中寻找，而<code>partial</code>本身指向的是<code>kmem_cached_node</code>中的<code>partial</code>链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> **freelist;	<span class="comment">/* Pointer to next available object */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> tid;	<span class="comment">/* Globally unique transaction id */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span>	<span class="comment">/* The slab from which we are allocating */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">partial</span>;</span>	<span class="comment">/* Partially allocated frozen slabs */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB_STATS</span></span><br><span class="line">    <span class="keyword">unsigned</span> stat[NR_SLUB_STAT_ITEMS];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>kmem_cached_node</code>结构体中也有类似的成员变量，但是相较之下会有更多详细信息，如<code>slab</code>链表总长度、空闲内存块的数量等等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The slab lists for all objects.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> list_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLAB</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_partial</span>;</span>	<span class="comment">/* partial list first, better asm code */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_full</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_free</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> total_slabs;	<span class="comment">/* length of all slab lists */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> free_slabs;	<span class="comment">/* length of free slab list only */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> free_objects;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> free_limit;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> colour_next;	<span class="comment">/* Per-node cache coloring */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> *<span class="title">shared</span>;</span>	<span class="comment">/* shared per node */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">alien_cache</span> **<span class="title">alien</span>;</span>	<span class="comment">/* on other nodes */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> next_reap;	<span class="comment">/* updated without locking */</span></span><br><span class="line">    <span class="keyword">int</span> free_touched;		<span class="comment">/* updated without locking */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_partial;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">partial</span>;</span></span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;下面回到缓冲区的分配函数<code>kmem_cache_alloc_node()</code>和释放函数<code>kmem_cache_free</code>。分配函数<code>kmem_cache_alloc_node()</code>实际调用<code>slab_alloc_node()</code>。从这里可以看出快通道和慢通道的处理逻辑。</p>
<ul>
<li>快通道：尝试取出<code>kmem_cache_cpu cpu_slab</code>的<code>freelist</code>，如果有空闲则返回，否则进入慢通道</li>
<li>慢通道：调用<code>__slab_alloc()</code>分配新的内存块</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Inlined fastpath so that allocation functions (kmalloc, kmem_cache_alloc)</span></span><br><span class="line"><span class="comment"> * have the fastpath folded into their functions. So no function call</span></span><br><span class="line"><span class="comment"> * overhead for requests that can be satisfied on the fastpath.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The fastpath works by first checking if the lockless freelist can be used.</span></span><br><span class="line"><span class="comment"> * If not then __slab_alloc is called for slow processing.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Otherwise we can simply pick the next object from the lockless free list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *<span class="title">slab_alloc_node</span><span class="params">(struct kmem_cache *s,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">gfp_t</span> gfpflags, <span class="keyword">int</span> node, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *object;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> *<span class="title">c</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> tid;</span><br><span class="line">    s = slab_pre_alloc_hook(s, gfpflags);</span><br><span class="line">    <span class="keyword">if</span> (!s)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">redo:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Must read kmem_cache cpu data via this cpu ptr. Preemption is</span></span><br><span class="line"><span class="comment">     * enabled. We may switch back and forth between cpus while</span></span><br><span class="line"><span class="comment">     * reading from one cpu area. That does not matter as long</span></span><br><span class="line"><span class="comment">     * as we end up on the original cpu again when doing the cmpxchg.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * We should guarantee that tid and kmem_cache are retrieved on</span></span><br><span class="line"><span class="comment">     * the same cpu. It could be different if CONFIG_PREEMPT so we need</span></span><br><span class="line"><span class="comment">     * to check if it is matched or not.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        tid = this_cpu_read(s-&gt;cpu_slab-&gt;tid);</span><br><span class="line">        c = raw_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">    &#125; <span class="keyword">while</span> (IS_ENABLED(CONFIG_PREEMPT) &amp;&amp;</span><br><span class="line">         unlikely(tid != READ_ONCE(c-&gt;tid)));</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Irqless object alloc/free algorithm used here depends on sequence</span></span><br><span class="line"><span class="comment">     * of fetching cpu_slab's data. tid should be fetched before anything</span></span><br><span class="line"><span class="comment">     * on c to guarantee that object and page associated with previous tid</span></span><br><span class="line"><span class="comment">     * won't be used with current tid. If we fetch tid first, object and</span></span><br><span class="line"><span class="comment">     * page could be one associated with next tid and our alloc/free</span></span><br><span class="line"><span class="comment">     * request will be failed. In this case, we will retry. So, no problem.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    barrier();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The transaction ids are globally unique per cpu and per operation on</span></span><br><span class="line"><span class="comment">     * a per cpu queue. Thus they can be guarantee that the cmpxchg_double</span></span><br><span class="line"><span class="comment">     * occurs on the right processor and that there was no operation on the</span></span><br><span class="line"><span class="comment">     * linked list in between.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    object = c-&gt;freelist;</span><br><span class="line">    page = c-&gt;page;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!object || !node_match(page, node))) &#123;</span><br><span class="line">        object = __slab_alloc(s, gfpflags, node, addr, c);</span><br><span class="line">        stat(s, ALLOC_SLOWPATH);</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>__slab_alloc()</code>主要逻辑如下</p>
<ul>
<li>在此尝试<code>kmem_cache_cpu</code>中的<code>freelist</code>是否可用，因为当前进程可能被中断，等回到该进程继续执行时可能已经有了空闲内存块可以直接使用了，因此先检查一下</li>
<li>跳转到<code>new_slab</code>标签，检查<code>kmem_cache_cpu</code>中的<code>paritial</code>，如果<code>partial</code>不为空则将<code>kmem_cache_cpu</code>中的<code>page</code>替换为<code>partial</code>，跳转至<code>redo</code>标签再次尝试分配</li>
<li>依然失败，则调用<code>new_slab_objects()</code>分配新内存块</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Slow path. The lockless freelist is empty or we need to perform</span></span><br><span class="line"><span class="comment"> * debugging duties.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Processing is still very fast if new objects have been freed to the</span></span><br><span class="line"><span class="comment"> * regular freelist. In that case we simply take over the regular freelist</span></span><br><span class="line"><span class="comment"> * as the lockless freelist and zap the regular freelist.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If that is not working then we fall back to the partial lists. We take the</span></span><br><span class="line"><span class="comment"> * first element of the freelist as the object to allocate now and move the</span></span><br><span class="line"><span class="comment"> * rest of the freelist to the lockless freelist.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * And if we were unable to get a new slab from the partial slab lists then</span></span><br><span class="line"><span class="comment"> * we need to allocate a new slab. This is the slowest path since it involves</span></span><br><span class="line"><span class="comment"> * a call to the page allocator and the setup of a new slab.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Version of __slab_alloc to use when we know that interrupts are</span></span><br><span class="line"><span class="comment"> * already disabled (which is the case for bulk allocation).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *___slab_alloc(struct kmem_cache *s, <span class="keyword">gfp_t</span> gfpflags, <span class="keyword">int</span> node,</span><br><span class="line">              <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, struct kmem_cache_cpu *c)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *freelist;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    page = c-&gt;page;</span><br><span class="line">    <span class="keyword">if</span> (!page)</span><br><span class="line">        <span class="keyword">goto</span> new_slab;</span><br><span class="line">redo:</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!node_match(page, node))) &#123;</span><br><span class="line">        <span class="keyword">int</span> searchnode = node;</span><br><span class="line">        <span class="keyword">if</span> (node != NUMA_NO_NODE &amp;&amp; !node_present_pages(node))</span><br><span class="line">            searchnode = node_to_mem_node(node);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(!node_match(page, searchnode))) &#123;</span><br><span class="line">            stat(s, ALLOC_NODE_MISMATCH);</span><br><span class="line">            deactivate_slab(s, page, c-&gt;freelist, c);</span><br><span class="line">            <span class="keyword">goto</span> new_slab;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * By rights, we should be searching for a slab page that was</span></span><br><span class="line"><span class="comment">     * PFMEMALLOC but right now, we are losing the pfmemalloc</span></span><br><span class="line"><span class="comment">     * information when the page leaves the per-cpu allocator</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!pfmemalloc_match(page, gfpflags))) &#123;</span><br><span class="line">        deactivate_slab(s, page, c-&gt;freelist, c);</span><br><span class="line">        <span class="keyword">goto</span> new_slab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* must check again c-&gt;freelist in case of cpu migration or IRQ */</span></span><br><span class="line">    freelist = c-&gt;freelist;</span><br><span class="line">    <span class="keyword">if</span> (freelist)</span><br><span class="line">        <span class="keyword">goto</span> load_freelist;</span><br><span class="line">    freelist = get_freelist(s, page);</span><br><span class="line">    <span class="keyword">if</span> (!freelist) &#123;</span><br><span class="line">        c-&gt;page = <span class="literal">NULL</span>;</span><br><span class="line">        stat(s, DEACTIVATE_BYPASS);</span><br><span class="line">        <span class="keyword">goto</span> new_slab;</span><br><span class="line">    &#125;</span><br><span class="line">    stat(s, ALLOC_REFILL);</span><br><span class="line">load_freelist:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * freelist is pointing to the list of objects to be used.</span></span><br><span class="line"><span class="comment">     * page is pointing to the page from which the objects are obtained.</span></span><br><span class="line"><span class="comment">     * That page must be frozen for per cpu allocations to work.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    VM_BUG_ON(!c-&gt;page-&gt;frozen);</span><br><span class="line">    c-&gt;freelist = get_freepointer(s, freelist);</span><br><span class="line">    c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line">    <span class="keyword">return</span> freelist;</span><br><span class="line">new_slab:</span><br><span class="line">    <span class="keyword">if</span> (slub_percpu_partial(c)) &#123;</span><br><span class="line">        page = c-&gt;page = slub_percpu_partial(c);</span><br><span class="line">        slub_set_percpu_partial(c, page);</span><br><span class="line">        stat(s, CPU_PARTIAL_ALLOC);</span><br><span class="line">        <span class="keyword">goto</span> redo;</span><br><span class="line">    &#125;</span><br><span class="line">    freelist = new_slab_objects(s, gfpflags, node, &amp;c);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!freelist)) &#123;</span><br><span class="line">        slab_out_of_memory(s, gfpflags, node);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    page = c-&gt;page;</span><br><span class="line">    <span class="keyword">if</span> (likely(!kmem_cache_debug(s) &amp;&amp; pfmemalloc_match(page, gfpflags)))</span><br><span class="line">        <span class="keyword">goto</span> load_freelist;</span><br><span class="line">    <span class="comment">/* Only entered in the debug case */</span></span><br><span class="line">    <span class="keyword">if</span> (kmem_cache_debug(s) &amp;&amp;</span><br><span class="line">            !alloc_debug_processing(s, page, freelist, addr))</span><br><span class="line">        <span class="keyword">goto</span> new_slab;	<span class="comment">/* Slab failed checks. Next slab needed */</span></span><br><span class="line">    deactivate_slab(s, page, get_freepointer(s, freelist), c);</span><br><span class="line">    <span class="keyword">return</span> freelist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>new_slab_objects()</code>函数逻辑如下</p>
<ul>
<li>调用<code>get_partial()</code>函数，根据<code>node</code>找到对应的<code>kmem_cache_node</code>然后调用<code>get_partial_node()</code>分配内存块。实际分配通过<code>acquire_slab()</code>函数完成，该函数会分配完成返回内存块指针并保存在<code>freelist</code>中，从 <code>kmem_cache_node</code> 的 <code>partial</code> 链表中拿下一大块内存来，并且将 <code>freelist</code>，也就是第一块空闲的缓存块赋值给 <code>t</code>。并且当第一轮循环的时候，将 <code>kmem_cache_cpu</code> 的 <code>page</code> 指向取下来的这一大块内存，返回的 <code>object</code> 就是这块内存里面的第一个缓存块 <code>t</code>。如果 <code>kmem_cache_cpu</code> 也有一个 <code>partial</code>，就会进行第二轮，再次取下一大块内存来，这次调用 <code>put_cpu_partial()</code>，放到 <code>kmem_cache_cpu</code> 的 <code>partial</code> 里面。如果 <code>kmem_cache_node</code> 里面也没有空闲的内存，这就说明原来分配的页里面都放满了，执行下一步。</li>
<li>调用<code>new_slab()</code>函数，向伙伴系统请求<code>2^order</code>个<code>page</code>，将请求的<code>page</code>构建成一个<code>slab</code>。分配的时候，要按 <code>kmem_cache_order_objects</code> 里面的 <code>order</code> 来。如果第一次分配不成功，说明内存已经很紧张了，那就换成 min 版本的 <code>kmem_cache_order_objects</code>。其调用链为<code>new_slab()-&gt;allocate_slab()-&gt;alloc_slab_page()-&gt;__alloc_pages_node()-&gt;__alloc_pages()-&gt;__alloc_pages_nodemask()</code>，从这里回到了伙伴系统，可见上文对该函数的分析。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">new_slab_objects</span><span class="params">(struct kmem_cache *s, <span class="keyword">gfp_t</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> node, struct kmem_cache_cpu **pc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *freelist;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> *<span class="title">c</span> = *<span class="title">pc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    WARN_ON_ONCE(s-&gt;ctor &amp;&amp; (flags &amp; __GFP_ZERO));</span><br><span class="line">    freelist = get_partial(s, flags, node, c);</span><br><span class="line">    <span class="keyword">if</span> (freelist)</span><br><span class="line">        <span class="keyword">return</span> freelist;</span><br><span class="line">    page = new_slab(s, flags, node);</span><br><span class="line">    <span class="keyword">if</span> (page) &#123;</span><br><span class="line">        c = raw_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;page)</span><br><span class="line">            flush_slab(s, c);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * No other reference to the page yet so we can</span></span><br><span class="line"><span class="comment">         * muck around with it freely without cmpxchg</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        freelist = page-&gt;freelist;</span><br><span class="line">        page-&gt;freelist = <span class="literal">NULL</span>;</span><br><span class="line">        stat(s, ALLOC_SLAB);</span><br><span class="line">        c-&gt;page = page;</span><br><span class="line">        *pc = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> freelist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;至此，页的分配就介绍完了。简单概括就是伙伴系统将多个连续页面整合为页块以供大规模使用，<code>slub allocator</code>将从伙伴系统申请的大块切成小块，放在缓存，并分配给其他系统。物理内存分页之后，通过<code>page_address()-&gt;lowmem_page_address()-&gt;page_to_virt()</code>调用链转化为虚拟地址以使用。</p>
<h2 id="五-内核页表"><a href="#五-内核页表" class="headerlink" title="五. 内核页表"></a>五. 内核页表</h2><p>&emsp;&emsp;内核态的页表在系统初始化的时候就需要创建，而非可以等到用的时候再创建页并映射。在 <code>arch/x86/include/asm/pgtable_64.h</code>有如下定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">p4d_t</span> level4_kernel_pgt[<span class="number">512</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">p4d_t</span> level4_ident_pgt[<span class="number">512</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">pud_t</span> level3_kernel_pgt[<span class="number">512</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">pud_t</span> level3_ident_pgt[<span class="number">512</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">pmd_t</span> level2_kernel_pgt[<span class="number">512</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">pmd_t</span> level2_fixmap_pgt[<span class="number">512</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">pmd_t</span> level2_ident_pgt[<span class="number">512</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">pte_t</span> level1_fixmap_pgt[<span class="number">512</span> * FIXMAP_PMD_NUM];</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">pgd_t</span> init_top_pgt[];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swapper_pg_dir init_top_pgt</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其中<code>swapper_pg_dir</code> 指向内核最顶级的目录 <code>pgd</code>，同时出现的还有几个页表目录，其中 <code>XXX_ident_pgt</code> 对应的是直接映射区，<code>XXX_kernel_pgt</code> 对应的是内核代码区，<code>XXX_fixmap_pgt</code> 对应的是固定映射区。</p>
<p>&emsp;&emsp;初始化的位置位于<code>arch\x86\kernel\head_64.S</code>，以全局变量的方式保存。这里<code>quad</code> 表示声明了一项的内容，<code>org</code>表示跳到了某个位置。</p>
<p>&emsp;&emsp;<code>init_top_pgt</code>是内核页的顶级目录，首先将其指向<code>level3_ident_pgt</code>，即直接映射区页表的三级目录。前文中有说过直接映射区物理内存和虚拟内存通过减去偏移量实现，即<code>__START_KERNEL_map</code>，虚拟地址空间的内核代码段的起始地址。通过这种方式，我们得到了其对应的物理地址。接着我们通过<code>PGD_PAGE_OFFSET</code>偏移量和<code>PGD_START_KERNEL</code>偏移量进行两次跳转，其中<code>PGD_PAGE_OFFSET</code>对应<code>__PAGE_OFFSET_BASE</code>，即虚拟地址空间里面内核的起始地址。第二项则指向<code>__START_KERNEL_map</code>，即虚拟地址空间里面内核代码段的起始地址。其他代码也是同理，最终形成如下表所示的整个页表项的初始化工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">__INITDATA</span><br><span class="line"></span><br><span class="line">NEXT_PAGE(init_top_pgt)</span><br><span class="line">  .quad   level3_ident_pgt - __START_KERNEL_map + _KERNPG_TABLE</span><br><span class="line">  .org    init_top_pgt + PGD_PAGE_OFFSET*8, 0</span><br><span class="line">  .quad   level3_ident_pgt - __START_KERNEL_map + _KERNPG_TABLE</span><br><span class="line">  .org    init_top_pgt + PGD_START_KERNEL*8, 0</span><br><span class="line">  &#x2F;* (2^48-(2*1024*1024*1024))&#x2F;(2^39) &#x3D; 511 *&#x2F;</span><br><span class="line">  .quad   level3_kernel_pgt - __START_KERNEL_map + _PAGE_TABLE</span><br><span class="line"></span><br><span class="line">NEXT_PAGE(level3_ident_pgt)</span><br><span class="line">  .quad  level2_ident_pgt - __START_KERNEL_map + _KERNPG_TABLE</span><br><span class="line">  .fill  511, 8, 0</span><br><span class="line">NEXT_PAGE(level2_ident_pgt)</span><br><span class="line">  &#x2F;* Since I easily can, map the first 1G.</span><br><span class="line">   * Don&#39;t set NX because code runs from these pages.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  PMDS(0, __PAGE_KERNEL_IDENT_LARGE_EXEC, PTRS_PER_PMD)</span><br><span class="line"></span><br><span class="line">NEXT_PAGE(level3_kernel_pgt)</span><br><span class="line">  .fill  L3_START_KERNEL,8,0</span><br><span class="line">  &#x2F;* (2^48-(2*1024*1024*1024)-((2^39)*511))&#x2F;(2^30) &#x3D; 510 *&#x2F;</span><br><span class="line">  .quad  level2_kernel_pgt - __START_KERNEL_map + _KERNPG_TABLE</span><br><span class="line">  .quad  level2_fixmap_pgt - __START_KERNEL_map + _PAGE_TABLE</span><br><span class="line"></span><br><span class="line">NEXT_PAGE(level2_kernel_pgt)</span><br><span class="line">  &#x2F;*</span><br><span class="line">   * 512 MB kernel mapping. We spend a full page on this pagetable</span><br><span class="line">   * anyway.</span><br><span class="line">   *</span><br><span class="line">   * The kernel code+data+bss must not be bigger than that.</span><br><span class="line">   *</span><br><span class="line">   * (NOTE: at +512MB starts the module area, see MODULES_VADDR.</span><br><span class="line">   *  If you want to increase this then increase MODULES_VADDR</span><br><span class="line">   *  too.)</span><br><span class="line">   *&#x2F;</span><br><span class="line">  PMDS(0, __PAGE_KERNEL_LARGE_EXEC,</span><br><span class="line">    KERNEL_IMAGE_SIZE&#x2F;PMD_SIZE)</span><br><span class="line"></span><br><span class="line">NEXT_PAGE(level2_fixmap_pgt)</span><br><span class="line">  .fill  506,8,0</span><br><span class="line">  .quad  level1_fixmap_pgt - __START_KERNEL_map + _PAGE_TABLE</span><br><span class="line">  &#x2F;* 8MB reserved for vsyscalls + a 2MB hole &#x3D; 4 + 1 entries *&#x2F;</span><br><span class="line">  .fill  5,8,0</span><br><span class="line"></span><br><span class="line">NEXT_PAGE(level1_fixmap_pgt)</span><br><span class="line">  .fill  51</span><br><span class="line">  </span><br><span class="line">PGD_PAGE_OFFSET &#x3D; pgd_index(__PAGE_OFFSET_BASE)</span><br><span class="line">PGD_START_KERNEL &#x3D; pgd_index(__START_KERNEL_map)</span><br><span class="line">L3_START_KERNEL &#x3D; pud_index(__START_KERNEL_map)</span><br></pre></td></tr></table></figure>

<img src="https://static001.geekbang.org/resource/image/78/6d/78c8d44d7d8c08c03eee6f7a94652d6d.png" alt="img" style="zoom: 25%;" />

<p>&emsp;&emsp;内核页表定义完了，一开始这里面的页表能够覆盖的内存范围比较小。例如内核代码区 512M，直接映射区 1G。这个时候，其实只要能够映射基本的内核代码和数据结构就可以了。可以看出里面还空着很多项，可以用于将来映射巨大的内核虚拟地址空间，等用到的时候再进行映射。如果是用户态进程页表，会有 <code>mm_struct</code> 指向进程顶级目录 <code>pgd</code>，对于内核来讲，也定义了一个 <code>mm_struct</code>，指向 <code>swapper_pg_dir</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> <span class="title">init_mm</span> = &#123;</span></span><br><span class="line">    .mm_rb    = RB_ROOT,</span><br><span class="line">    .pgd    = swapper_pg_dir,</span><br><span class="line">    .mm_users  = ATOMIC_INIT(<span class="number">2</span>),</span><br><span class="line">    .mm_count  = ATOMIC_INIT(<span class="number">1</span>),</span><br><span class="line">    .mmap_sem  = __RWSEM_INITIALIZER(init_mm.mmap_sem),</span><br><span class="line">    .page_table_lock =  __SPIN_LOCK_UNLOCKED(init_mm.page_table_lock),</span><br><span class="line">    .mmlist    = LIST_HEAD_INIT(init_mm.mmlist),</span><br><span class="line">    .user_ns  = &amp;init_user_ns,</span><br><span class="line">    INIT_MM_CONTEXT(init_mm)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;内核页表的初始化工作会在系统启动时，<code>start_kernel()</code>通过调用<code>setup_arch()</code>完成。<code>load_cr3(swapper_pg_dir)</code> 说明内核页表要开始起作用了，并且刷新了 <code>TLB</code>，初始化 <code>init_mm</code> 的成员变量，最重要的就是 <code>init_mem_mapping()</code>，通过调用链<code>init_mem_mapping()-&gt;init_memory_mapping()-&gt;kernel_physical_mapping_init()</code>最终通过 <code>__va</code> 将物理地址转换为虚拟地址，然后再创建虚拟地址和物理地址的映射页表。<code>__va</code>和<code>__pa</code>本身可以直接完成物理地址和虚拟地址的转换，但是CPU在保护模式下访问虚拟地址需要通过CR3寄存器，因此必须完成该映射页表的创建工作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">setup_arch</span><span class="params">(<span class="keyword">char</span> **cmdline_p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * copy kernel address range established so far and switch</span></span><br><span class="line"><span class="comment">     * to the proper swapper page table</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    clone_pgd_range(swapper_pg_dir     + KERNEL_PGD_BOUNDARY,</span><br><span class="line">        initial_page_table + KERNEL_PGD_BOUNDARY,</span><br><span class="line">        KERNEL_PGD_PTRS);</span><br><span class="line"></span><br><span class="line">    load_cr3(swapper_pg_dir);</span><br><span class="line">    __flush_tlb_all();</span><br><span class="line">......</span><br><span class="line">    init_mm.start_code = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) _text;</span><br><span class="line">    init_mm.end_code = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) _etext;</span><br><span class="line">    init_mm.end_data = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) _edata;</span><br><span class="line">    init_mm.brk = _brk_end;</span><br><span class="line">......</span><br><span class="line">    init_mem_mapping();</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六-页面交换"><a href="#六-页面交换" class="headerlink" title="六. 页面交换"></a>六. 页面交换</h2><p>&emsp;&emsp;由于虚拟内存是远大于物理内存的，在物理内存中加载所有的虚拟内存页显然是异想天开，因此我们必须要有页面的交换。和CPU调度相似，页的交换也包括主动的交换和被动的交换。</p>
<ul>
<li>被动页面回收：当分配内存的时候发现物理内存不够用了，则尝试回收。如申请页面会调用<code>get_page_from_freelist()</code>，该函数会通过调用链<code>get_page_from_freelist()-&gt;node_reclaim()-&gt;__node_reclaim()-&gt;shrink_node()</code>尝试是否可以对当前的内存节点执行换出操作，从而腾出空</li>
<li>主动页面管理：在内核中，内核线程<code>kswapd0</code>即负责该部分的功能。下面详细展开分析一下该部分功能。</li>
</ul>
<p>&emsp;&emsp;为了衡量内存的使用情况，<code>kswapd0</code> 定义了三个内存阈值（watermark，也称为水位），分别是页最小阈值（pages_min）、页低阈值（pages_low）和页高阈值（pages_high）。剩余内存，则使用 pages_free 表示。</p>
<p><img src="https://static001.geekbang.org/resource/image/c1/20/c1054f1e71037795c6f290e670b29120.png" alt="img"></p>
<p>&emsp;&emsp;<code>kswapd0</code> 定期扫描内存的使用情况，并根据剩余内存落在这三个阈值的空间位置，进行内存的回收操作。</p>
<ul>
<li>剩余内存小于页最小阈值，说明进程可用内存都耗尽了，只有内核才可以分配内存。</li>
<li>剩余内存落在页最小阈值和页低阈值中间，说明内存压力比较大，剩余内存不多了。这时 kswapd0 会执行内存回收，直到剩余内存大于高阈值为止。</li>
<li>剩余内存落在页低阈值和页高阈值中间，说明内存有一定压力，但还可以满足新内存请求。</li>
<li>剩余内存大于页高阈值，说明剩余内存比较多，没有内存压力。</li>
</ul>
<p>&emsp;&emsp;一旦剩余内存小于页低阈值，就会触发内存的回收。这个页低阈值，其实可以通过内核选项 <code>/proc/sys/vm/min_free_kbytes</code> 来间接设置。<code>min_free_kbytes</code> 设置了页最小阈值，而其他两个阈值，都是根据页最小阈值计算生成的，计算方法如下 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pages_low &#x3D; pages_min*5&#x2F;4</span><br><span class="line">pages_high &#x3D; pages_min*3&#x2F;2</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如下所示为<code>kswapd()</code>源码，核心调用链为<code>balance_pgdat()-&gt;kswapd_shrink_node()-&gt;shrink_node()</code>，所以被动回收和主动管理最后殊途同归，回到了同样的函数<code>shrink_node()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The background pageout daemon, started as a kernel thread</span></span><br><span class="line"><span class="comment"> * from the init process.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This basically trickles out pages so that we have _some_</span></span><br><span class="line"><span class="comment"> * free memory available even if there is no other activity</span></span><br><span class="line"><span class="comment"> * that frees anything up. This is needed for things like routing</span></span><br><span class="line"><span class="comment"> * etc, where we otherwise might have all activity going on in</span></span><br><span class="line"><span class="comment"> * asynchronous contexts that cannot page things out.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If there are applications that are active memory-allocators</span></span><br><span class="line"><span class="comment"> * (most normal use), this basically shouldn't matter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kswapd</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> alloc_order, reclaim_order;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> classzone_idx = MAX_NR_ZONES - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">pg_data_t</span> *pgdat = (<span class="keyword">pg_data_t</span>*)p;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> = <span class="title">current</span>;</span></span><br><span class="line">......</span><br><span class="line">    <span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">......</span><br><span class="line">kswapd_try_sleep:</span><br><span class="line">        kswapd_try_to_sleep(pgdat, alloc_order, reclaim_order,</span><br><span class="line">                    classzone_idx);</span><br><span class="line">......</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Reclaim begins at the requested order but if a high-order</span></span><br><span class="line"><span class="comment">         * reclaim fails then kswapd falls back to reclaiming for</span></span><br><span class="line"><span class="comment">         * order-0. If that happens, kswapd will consider sleeping</span></span><br><span class="line"><span class="comment">         * for the order it finished reclaiming at (reclaim_order)</span></span><br><span class="line"><span class="comment">         * but kcompactd is woken to compact for the original</span></span><br><span class="line"><span class="comment">         * request (alloc_order).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        trace_mm_vmscan_kswapd_wake(pgdat-&gt;node_id, classzone_idx,</span><br><span class="line">                        alloc_order);</span><br><span class="line">        reclaim_order = balance_pgdat(pgdat, alloc_order, classzone_idx);</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>shrink_node()</code>实际调用<code>shrink_node_memcg()</code>。这里面有个 <code>LRU</code> 列表，所有的页面都被挂在 <code>LRU</code> 列表中。<code>LRU</code> 也就是最近最少使用。这个列表里面会按照活跃程度进行排序，这样就容易把不怎么用的内存页拿出来做处理。内存页总共分两类，一类是匿名页，和虚拟地址空间进行关联；一类是内存映射，不但和虚拟地址空间关联，还和文件管理关联。它们每一类都有两个列表，一个是 <code>active</code>，一个是 <code>inactive</code>。顾名思义，<code>active</code> 就是比较活跃的，<code>inactive</code> 就是不怎么活跃的。这两个里面的页会变化，过一段时间，活跃的可能变为不活跃，不活跃的可能变为活跃。如果要换出内存，那就是从不活跃的列表中找出最不活跃的，换出到硬盘上。</p>
<p>&emsp;&emsp;<code>shrink_list()</code> 会先缩减活跃页面列表，再压缩不活跃的页面列表。对于不活跃列表的缩减，<code>shrink_inactive_list()</code> 就需要对页面进行回收；对于匿名页来讲，需要分配 <code>swap()</code>，将内存页写入文件系统；对于内存映射关联了文件的，我们需要将在内存中对于文件的修改写回到文件中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is a basic per-node page freer.  Used by both kswapd and direct reclaim.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shrink_node_memcg</span><span class="params">(struct pglist_data *pgdat, struct mem_cgroup *memcg,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct scan_control *sc, <span class="keyword">unsigned</span> <span class="keyword">long</span> *lru_pages)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lruvec</span> *<span class="title">lruvec</span> = <span class="title">mem_cgroup_lruvec</span>(<span class="title">pgdat</span>, <span class="title">memcg</span>);</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nr[NR_LRU_LISTS];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> targets[NR_LRU_LISTS];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_to_scan;</span><br><span class="line">    <span class="keyword">enum</span> lru_list lru;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">while</span> (nr[LRU_INACTIVE_ANON] || nr[LRU_ACTIVE_FILE] ||</span><br><span class="line">                    nr[LRU_INACTIVE_FILE]) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_anon, nr_file, percentage;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_scanned;</span><br><span class="line">        for_each_evictable_lru(lru) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nr[lru]) &#123;</span><br><span class="line">                nr_to_scan = <span class="built_in">min</span>(nr[lru], SWAP_CLUSTER_MAX);</span><br><span class="line">                nr[lru] -= nr_to_scan;</span><br><span class="line">                nr_reclaimed += shrink_list(lru, nr_to_scan,</span><br><span class="line">                                lruvec, memcg, sc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">enum</span> lru_list &#123;</span><br><span class="line">  LRU_INACTIVE_ANON = LRU_BASE,</span><br><span class="line">  LRU_ACTIVE_ANON = LRU_BASE + LRU_ACTIVE,</span><br><span class="line">  LRU_INACTIVE_FILE = LRU_BASE + LRU_FILE,</span><br><span class="line">  LRU_ACTIVE_FILE = LRU_BASE + LRU_FILE + LRU_ACTIVE,</span><br><span class="line">  LRU_UNEVICTABLE,</span><br><span class="line">  NR_LRU_LISTS</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> for_each_evictable_lru(lru) for (lru = 0; lru &lt;= LRU_ACTIVE_FILE; lru++)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">shrink_list</span><span class="params">(<span class="keyword">enum</span> lru_list lru, <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_to_scan,</span></span></span><br><span class="line"><span class="function"><span class="params">                 struct lruvec *lruvec, struct mem_cgroup *memcg,</span></span></span><br><span class="line"><span class="function"><span class="params">                 struct scan_control *sc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_active_lru(lru)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inactive_list_is_low(lruvec, is_file_lru(lru),</span><br><span class="line">                     memcg, sc, <span class="literal">true</span>))</span><br><span class="line">            shrink_active_list(nr_to_scan, lruvec, sc, lru);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shrink_inactive_list(nr_to_scan, lruvec, sc, lru);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六-总结"><a href="#六-总结" class="headerlink" title="六. 总结"></a>六. 总结</h2><p>&emsp;&emsp;内存管理可谓非常复杂，本文较为详尽的介绍了内存管理中分页和页的分配相关内容，下文将继续介绍物理内存和虚拟内存的映射。</p>
<h2 id="源码资料"><a href="#源码资料" class="headerlink" title="源码资料"></a>源码资料</h2><p>[1] <a href="https://code.woboq.org/linux/linux/include/linux/mmzone.h.html#pglist_data" target="_blank" rel="noopener">pg_list_data</a></p>
<p>[2] <a href="https://code.woboq.org/linux/linux/include/linux/mm_types.h.html#page" target="_blank" rel="noopener">page</a></p>
<p>[3] <a href="https://code.woboq.org/linux/linux/mm/page_alloc.c.html#get_page_from_freelist" target="_blank" rel="noopener">buddy system</a></p>
<p>[4] <a href="https://code.woboq.org/linux/linux/include/linux/slub_def.h.html#kmem_cache" target="_blank" rel="noopener">slub allocator</a></p>
<p>[5] <a href="https://code.woboq.org/linux/linux/mm/slub.c.html#kmem_cache_alloc_node" target="_blank" rel="noopener">kmem_cache_alloc_node</a></p>
<p>[6] <a href="https://code.woboq.org/linux/linux/mm/vmscan.c.html#3825" target="_blank" rel="noopener">kswapd</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] wiki</p>
<p>[2] <a href="https://elixir.bootlin.com/linux/v5.7-rc1/source" target="_blank" rel="noopener">elixir.bootlin.com/linux</a></p>
<p>[3] <a href="https://code.woboq.org/" target="_blank" rel="noopener">woboq</a></p>
<p>[4] Linux-insides</p>
<p>[5] 深入理解Linux内核</p>
<p>[6] Linux内核设计的艺术</p>
<p>[7] 极客时间 趣谈Linux操作系统</p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创，坚持分享，谢谢鼓励和支持</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="Ty Chen 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="Ty Chen 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Ty Chen
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://ty-chen.github.io/linux-kernel-mm-mgr/" title="Linux操作系统学习笔记（九）内存管理之分页">https://ty-chen.github.io/linux-kernel-mm-mgr/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
            <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a>
          
            <a href="/tags/%E5%86%85%E5%AD%98/" rel="tag"># 内存</a>
          
            <a href="/tags/%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F/" rel="tag"># 伙伴系统</a>
          
            <a href="/tags/Slub-Allocator/" rel="tag"># Slub Allocator</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/linux-kernel-mmstruct/" rel="next" title="Linux操作系统学习笔记（八）任务空间管理">
                <i class="fa fa-chevron-left"></i> Linux操作系统学习笔记（八）任务空间管理
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/linux-kernel-mmap/" rel="prev" title="Linux操作系统学习笔记（十）内存管理之内存映射">
                Linux操作系统学习笔记（十）内存管理之内存映射 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        
  <div class="bdsharebuttonbox">
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
    <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
    <a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a>
    <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
    <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a class="bds_count" data-cmd="count"></a>
  </div>
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "2",
        "bdMiniList": false,
        "bdPic": ""
      },
      "share": {
        "bdSize": "16",
        "bdStyle": "0"
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/me.JPG"
                alt="Ty Chen" />
            
              <p class="site-author-name" itemprop="name">Ty Chen</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">40</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">63</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Ty-Chen" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:tianyuch@hotmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Friends
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://lishouxian.cn/" title="Stanleylsx" target="_blank">Stanleylsx</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一-前言"><span class="nav-text">一. 前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二-内存模型"><span class="nav-text">二. 内存模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三-节点、区域和页"><span class="nav-text">三. 节点、区域和页</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-节点"><span class="nav-text">3.1 节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-区域"><span class="nav-text">3.2 区域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-页"><span class="nav-text">3.3 页</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四-用户态页的分配"><span class="nav-text">四. 用户态页的分配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-伙伴系统"><span class="nav-text">4.1 伙伴系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-slub-allocator"><span class="nav-text">4.2 slub allocator</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五-内核页表"><span class="nav-text">五. 内核页表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六-页面交换"><span class="nav-text">六. 页面交换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六-总结"><span class="nav-text">六. 总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#源码资料"><span class="nav-text">源码资料</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2020 &mdash; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ty Chen</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">176.2k</span>
  
  <a href="http://www.beian.miit.gov.cn/" target="_blank" rel="noopener">粤ICP备20071543号</a> 
</div>









        
<div class="busuanzi-count">
	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>

  
    <span class="site-uv">
      你是来访的第
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      位同学
    </span>
  

  
    <span class="site-pv">
      访问次数：
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'aTqo2eFkO2Bn0AGX008uKDV7-gzGzoHsz',
        appKey: 'uJ6nxqW7RHWpAILCtttkJfJu',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
