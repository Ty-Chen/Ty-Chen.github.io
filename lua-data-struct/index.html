<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/kulamati128.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/kulamati32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/kulamati16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Lua,数据类型," />










<meta name="description" content="一. 前言&amp;emsp;&amp;emsp;在第一讲里，我们提到了对于脚本语言来说，传值如何存储是很需要慎重考虑的事，本文就展开详细看看Lua的数值是如何存储的。">
<meta property="og:type" content="article">
<meta property="og:title" content="Lua源码剖析（三）数据结构体">
<meta property="og:url" content="https://ty-chen.github.io/lua-data-struct/index.html">
<meta property="og:site_name" content="Ty-Chen&#39;s Home">
<meta property="og:description" content="一. 前言&amp;emsp;&amp;emsp;在第一讲里，我们提到了对于脚本语言来说，传值如何存储是很需要慎重考虑的事，本文就展开详细看看Lua的数值是如何存储的。">
<meta property="article:published_time" content="2023-01-18T17:36:31.000Z">
<meta property="article:modified_time" content="2023-02-07T12:01:19.418Z">
<meta property="article:author" content="Ty Chen">
<meta property="article:tag" content="Lua">
<meta property="article:tag" content="数据类型">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://ty-chen.github.io/lua-data-struct/"/>





  <title>Lua源码剖析（三）数据结构体 | Ty-Chen's Home</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ty-Chen's Home</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Collecting, sharing and creating knowledge</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ty-chen.github.io/lua-data-struct/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ty Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty-Chen's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Lua源码剖析（三）数据结构体</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-01-19T01:36:31+08:00">
                2023-01-19
              </time>
            

            

            
          </span>
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2023-02-07T20:01:19+08:00" content="2023-02-07">
                2023-02-07
              </time>
            </span>
          
          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Lua%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index">
                    <span itemprop="name">Lua学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/lua-data-struct/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/lua-data-struct/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv">访问次数：
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  16
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h2><p>&emsp;&emsp;在第一讲里，我们提到了对于脚本语言来说，传值如何存储是很需要慎重考虑的事，本文就展开详细看看Lua的数值是如何存储的。</p>
<a id="more"></a>

<h2 id="二-基础数据结构体"><a href="#二-基础数据结构体" class="headerlink" title="二. 基础数据结构体"></a>二. 基础数据结构体</h2><p>&emsp;&emsp;在第一讲有提到，如果我们希望传递多种不同的数值，那么脚本语言设计的时候，比较合理的一种方式就是让数值自带类型标记，然后再以联合的形式构建数据结构，类似于</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 随便列几个数据类型</span></span><br><span class="line">    <span class="keyword">bool</span>  bBool;</span><br><span class="line">    <span class="keyword">int</span>   nInt;</span><br><span class="line">    <span class="keyword">void</span>* pPointer;</span><br><span class="line">&#125; Value;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ScriptValue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>   nType;</span><br><span class="line">    Value value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;字节码为字面值时，先检查<code>nType</code>获取类型，再读取<code>Value</code>做对应类型数据的存储和处理。</p>
<p>&emsp;&emsp;再结合之前提及的，需要做内存回收的数据类型和不需要做数据回收的，可以再封装一个GC头部</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> GCObject</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 需要GC的数值类型  </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">    GCObject* pGCObject;</span><br><span class="line">    <span class="keyword">bool</span>      bBool;</span><br><span class="line">    <span class="keyword">int</span>       nInt;</span><br><span class="line">    <span class="keyword">void</span>*     pPointer;</span><br><span class="line">&#125; Value;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ScriptValue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nType;</span><br><span class="line">    Value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;而实际上，Lua的数值结构封装可以说是一模一样。</p>
<p>&emsp;&emsp;Lua的基础数据由宏定义可以看到</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lua.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_TNONE		(-1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_TNIL		0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_TBOOLEAN		1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_TLIGHTUSERDATA	2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_TNUMBER		3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_TSTRING		4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_TTABLE		5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_TFUNCTION		6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_TUSERDATA		7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_TTHREAD		8</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其中的<code>LUA_TLIGHTUSERDATA</code>和<code>LUA_TUSERDATA</code>一样，对应的都是<code>void*</code>指针，区别在于，<code>LUA_TLIGHTUSERDATA</code>的分配释放是由Lua外部的使用者如C/C++来完成，而<code>LUA_TUSERDATA</code>则是通过Lua内部来完成的。换言之，前者不需要Lua去关心它的生存期，由使用者自己去关注，后者则反之。</p>
<p>&emsp;&emsp;然后看看Lua的数据结构，就很好懂了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Union of all Lua values</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> &#123;</span><br><span class="line">  GCObject *gc;</span><br><span class="line">  <span class="keyword">void</span> *p;</span><br><span class="line">  lua_Number n;</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line">&#125; Value;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TValuefields	Value value; int tt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lua_TValue</span> &#123;</span></span><br><span class="line">  TValuefields;</span><br><span class="line">&#125; TValue;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其中<code>GCObject</code>为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tt，即该GC对象的具体类型</span></span><br><span class="line"><span class="comment">//next，指向GCObject的指针，用于GC算法内部实现链表</span></span><br><span class="line"><span class="comment">//marked，用于GC算法内部实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CommonHeader	GCObject *next; lu_byte tt; lu_byte marked</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GCheader</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">&#125; GCheader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Union of all collectable objects</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">union</span> GCObject &#123;</span><br><span class="line">    GCheader gch;</span><br><span class="line">    <span class="keyword">union</span> TString ts;</span><br><span class="line">    <span class="keyword">union</span> Udata u;</span><br><span class="line">    <span class="keyword">union</span> Closure cl;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> <span class="title">h</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Proto</span> <span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">UpVal</span> <span class="title">uv</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lua_State</span> <span class="title">th</span>;</span>  <span class="comment">/* thread */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其中有五个类型就是接下来要详细展开说明的：字符串<code>TString</code>、表<code>Table</code>以及上值<code>UpVal</code>与函数<code>Proto</code>（闭包<code>Closure</code>）。</p>
<h2 id="三-字符串"><a href="#三-字符串" class="headerlink" title="三. 字符串"></a>三. 字符串</h2><p>&emsp;&emsp;字符串，无非就是字符数组，是每种语言都需要考虑存储的数据类型，对于脚本语言来说也不例外，通常来说会有以下需要考虑的因素</p>
<ul>
<li>如何存储：常见的无非是长度+变长指针申请空间</li>
<li>如何使用：这里需要取舍的地方主要有<ul>
<li>是否允许对字符串进行截断/增长的操作：如果允许则可能带来内存碎片等问题，多个字符串的统一存取也会存在问题（redis中有类似处理）。如果不允许，那对字符串的操作就需要转化为新增字符串，内存的代价是否在接受范围内。</li>
<li>如何节约空间：对于相同的字符串是否可以仅存一份？这很容易让人想到哈希，哈希的算法以及哈希后的存储方式也需要考虑。</li>
</ul>
</li>
<li>如何销毁：对于设计了自动垃圾回收的，当然也是将字符串归为垃圾回收对象内，进行统一处理。</li>
</ul>
<p>&emsp;&emsp;对于Lua来说，其设计也在此樊笼之内。关键性的取舍就在于为了节约内存和加快查找速度，选用了哈希桶+字符串哈希存储，将总表放置在全局变量中方便查找，然后针对各种上述细节挨个处理即可。下面就看看Lua的实现吧。</p>
<p>&emsp;&emsp;先看看字符串的定义，其实就很常规，唯一比较有特色的地方时有一个<code>dummy</code>，注释也很详细了，其实就是做了一个字节对齐操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUAI_USER_ALIGNMENT_T	union &#123; double u; void *s; long l; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* type to ensure maximum alignment */</span></span><br><span class="line"><span class="keyword">typedef</span> LUAI_USER_ALIGNMENT_T L_Umaxalign;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> TString &#123;</span><br><span class="line">  L_Umaxalign dummy;  <span class="comment">/* ensures maximum alignment for strings */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    CommonHeader;</span><br><span class="line">    lu_byte reserved;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line">  &#125; tsv;</span><br><span class="line">&#125; TString;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在上一讲中，我们提到过Lua栈的全局变量里，保存了所有字符串的统一集合：<code>stringtable</code>，其定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">global_State</span> &#123;</span></span><br><span class="line">    stringtable strt;  <span class="comment">/* hash table for strings */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stringtable</span> &#123;</span></span><br><span class="line">    GCObject** hash; <span class="comment">// 存放一系列链表的数组</span></span><br><span class="line">    lu_int32 nuse;  <span class="comment">/* number of elements */</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">&#125; stringtable;</span><br></pre></td></tr></table></figure>

<h2 id="四-表"><a href="#四-表" class="headerlink" title="四. 表"></a>四. 表</h2><p>&emsp;&emsp;每种语言在设计的时候都需要考虑，是否需要增加容器，以及增加哪些容器。如C++广为使用的多种stl容器，就极大的丰富了语言的能力，提高了开发效率。那么设想，如果我们仅设计一种简介但是提供了诸多扩展的容器，是否也可以满足脚本编写者们的需要呢？</p>
<p>&emsp;&emsp;如果要这么做，那这个容器大概需要有以下特点</p>
<ul>
<li>基本的数据存储和查找能力：所有容器都是用来存东西的，只是存放的方法、查找的方法不同，所以最少需要提供一种以上的数据存储方式，便于存储且便于查找</li>
<li>扩展能力：仅有以上功能的话不能满足更高自由度的操作，如果我们可以给出方法接口让用户自己实现方法去做想做的事，那就可以极大的提高这种容器的易用性</li>
</ul>
<p>&emsp;&emsp;结合以上，我们可以简单的做一个容器，假设我们也称之为表，那可能可以写作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ExtendMethod</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 扩展函数指针结构体，这里随便列两个</span></span><br><span class="line">    <span class="keyword">void</span> (OperateValue*)(TValue value);</span><br><span class="line">    <span class="keyword">void</span> (OperateTable*)(Table* pTable1, Table* pTable2);</span><br><span class="line">    .......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Table</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CommonHeader;	         </span><br><span class="line">    GCObject*     gclist;    <span class="comment">// 表也属于GC对象，加上一个指针</span></span><br><span class="line">    ExtendMethod* pMethod;   <span class="comment">// 提供扩展点</span></span><br><span class="line">    <span class="keyword">int</span>           nArraySize;   </span><br><span class="line">    Tvalue*       pArray;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这样的表存在一个缺点：虽然值存储可以是任意<code>TValue</code>类型，但是索引只能是数字，如果想存储键值对而键非数字则会非常麻烦，当然也不是不能解决，只是还有更好的方法，就是再加入一个数组存储<code>k/v</code>型，将结构体改为如下所示。每个节点Node，均用<code>Tvalue</code>类型的<code>key</code>和<code>value</code>，从而做到任意的键值均可存储。插入<code>k/v</code>时，对<code>key</code>做哈希（假设为<code>i</code>)，然后存入对应的<code>Node</code>数组索引下标为<code>i</code>的地方。这种做法的好处不言而喻，但是同时也带来了个问题：<strong>插入和查询都需要去考虑在哪种数组，扩容和缩容亦然。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ExtendMethod</span>&#123;</span>.......&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TValue key;</span><br><span class="line">    TValue val;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Table</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CommonHeader;	         </span><br><span class="line">    GCObject*     gclist;    </span><br><span class="line">    ExtendMethod* pMethod;   </span><br><span class="line">    <span class="keyword">int</span>           nArraySize;   </span><br><span class="line">    Tvalue*       pArray;</span><br><span class="line">    <span class="keyword">int</span>           nNodeSize;</span><br><span class="line">    Node*         pNode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在此情况下，其实<code>ExtendMethod</code>已经没有特别去申请的必要了，因为函数指针也可以包含在TValue之中实现，因此可以做进一步简化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TValue key;</span><br><span class="line">    TValue val;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Table</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CommonHeader;	         </span><br><span class="line">    GCObject*     gclist;    </span><br><span class="line">    Table*        pMethod;   </span><br><span class="line">    <span class="keyword">int</span>           nArraySize;   </span><br><span class="line">    Tvalue*       pArray;</span><br><span class="line">    <span class="keyword">int</span>           nNodeSize;</span><br><span class="line">    Node*         pNode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在呢，我们拥有了一个能够存储任意类型的数据、关联数据的容器，然后再实现一些相应的操作，看起来就可以让一个普通的容器跑起来了。不过为了追求完美，我们还可以做一些优化。</p>
<p>&emsp;&emsp;首先第一个问题就是，哈希得到的结果会很分散，如果我们希望能存放在比较规整的数组中，我们可以用哈希对数组大小取余，余数即数组索引。为此我们对<code>key</code>单独创建一个结构体增加链表指针，即通过哈希找到该<code>key</code>所在数组位置后，再根据<code>key</code>的链表取找寻对应的<code>key</code>。（实际Lua会比这个更复杂一点，用一定的运算复杂度换取了空间的优化，在后文中会详细说明）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TKey</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TValue value;</span><br><span class="line">    Node*  pNext;</span><br><span class="line">&#125; TKey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TKey   key;</span><br><span class="line">    TValue val;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Table</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CommonHeader;	         </span><br><span class="line">    GCObject*     gclist;    </span><br><span class="line">    Table*        pMethod;   </span><br><span class="line">    <span class="keyword">int</span>           nArraySize;   </span><br><span class="line">    Tvalue*       pArray;</span><br><span class="line">    <span class="keyword">int</span>           nNodeSize;</span><br><span class="line">    Node*         pNode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;第二个问题，已经有了一个k/v型数组了，那纯数字索引的数组是否还有存在的必要呢？是否可以删掉呢？其实是可以不要的，但是哈希的速度一定是没有一个简单的判断+直接地址索引来得快的，所以适当的数字索引数组可以提高表的查询/插入速度，这就是一个速度、内存以及实现的复杂度上的考量。Lua的开发者判定存在合理，但是自己在设计和实现的时候，需要根据实际的需求、使用场景以及测试数据来判断是否需要保留。事实上早期的Lua版本仅保留了k/v，后面为了提高运行速率又加上了数组。</p>
<p>&emsp;&emsp;至此，我们已经设计了一个简洁高效且扩展性极强的容器数据结构，而实际上，Lua源码几乎就是这么做的。下面再看看源码一定有着一目了然的感觉。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lua 5.1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> TKey &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    TValuefields;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span>  <span class="comment">/* for chaining */</span></span><br><span class="line">  &#125; nk;</span><br><span class="line">  TValue tvk;</span><br><span class="line">&#125; TKey;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  TValue i_val;</span><br><span class="line">  TKey i_key;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  lu_byte flags;  <span class="comment">/* 1&lt;&lt;p means tagmethod(p) is not present */</span> </span><br><span class="line">  lu_byte lsizenode;  <span class="comment">/* log2 of size of `node' array */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> *<span class="title">metatable</span>;</span></span><br><span class="line">  TValue *<span class="built_in">array</span>;  <span class="comment">/* array part */</span></span><br><span class="line">  Node *node;</span><br><span class="line">  Node *lastfree;  <span class="comment">/* any free position is before this position */</span></span><br><span class="line">  GCObject *gclist;</span><br><span class="line">  <span class="keyword">int</span> sizearray;  <span class="comment">/* size of `array' array */</span></span><br><span class="line">&#125; Table;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;考虑到表的包容性以及复杂性，其各种操作函数如初始化、查询、扩容等，其实也存在着诸多考量。考虑到篇幅问题以及本文主旨，在此不做展开，后文中会单独拎出来详谈，有兴趣的可以自己先思考实现，再和Lua进行比对，就更有收获了。如果发现自己写的更优秀，那岂不是一个重大的创新。</p>
<h2 id="五-上值和函数（闭包）"><a href="#五-上值和函数（闭包）" class="headerlink" title="五. 上值和函数（闭包）"></a>五. 上值和函数（闭包）</h2><p>&emsp;&emsp;让我们看看如下的两个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">a</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">b</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    a(val);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;非常好理解，函数a()会打印传参，函数b()调用了a，传递了一个值进去实现打印。</p>
<p>&emsp;&emsp;这是一个简单的函数调用，如果我们希望脚本语言支持函数（这都不支持可能没人愿意用了吧），那我们就要想办法用数据结构来表示函数，并且该数据结构最好还能够方便的表达层级关系以及传值。所以至少需要几方面基本的元素：</p>
<ul>
<li>指令集的存储</li>
<li>局部变量</li>
<li>指针指向栈上的传参及上层函数、全局变量、静态变量等</li>
</ul>
<p>&emsp;&emsp;由此可以实现一个基本的雏形，如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TFunction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Instruction* pPC;		  <span class="comment">// 函数指令集</span></span><br><span class="line">    TValue*	     pLocalVal;    <span class="comment">// 函数内定义的变量</span></span><br><span class="line">    TValue*      pExternalVal; <span class="comment">// 外部变量</span></span><br><span class="line">&#125;TFunction;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当然实际实现的时候，还需要加上一些比如变量数量，指令数量等，如果想要加上调试信息，还得配上和指令对应的行号等信息，这里简单的称之为<code>Others</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TFunction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Instruction* pPC;		  <span class="comment">// 函数指令集</span></span><br><span class="line">    TValue*	     pLocalVal;    <span class="comment">// 函数内定义的变量</span></span><br><span class="line">    TValue*      pExternalVal; <span class="comment">// 外部变量</span></span><br><span class="line">    Other	     otherVal;     <span class="comment">// 辅助变量</span></span><br><span class="line">&#125;TFunction;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这样的函数结构，可以满足C/C++中的函数使用。但是如果我们希望函数能够更灵活，做到如同变量一样的生效，那么这还是不够的。在前面数值定义时，我们将函数也定义为了TValue，那么函数只要不是定义为局部变量，嵌套的函数应该也可不受外层约束。比如下面这个例子，<code>b()</code>在<code>a()</code>之外也可以调用，这样的灵活性可以提高脚本的丰富程度，同时也减少了约束。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> var1 = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> var2 = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span><span class="params">()</span></span></span><br><span class="line">        var1 = var1 + <span class="number">1</span></span><br><span class="line">        var2 = var2 + <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line">    b()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">a()</span><br><span class="line">b()</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;为此，我们需要对当前的外部变量做一些调整：当前的外部变量由指针指向栈，而如上例a()函数调用完成释放后，栈上已经没有了var2，那b()的调用就会出错。因此，我们对外部变量进行结构体封装：</p>
<ul>
<li>用一个指针<code>pStackVal</code>指向栈，如果栈上的变量回收，则改为指向自身的value结构体获取数值</li>
<li>封装value联合体，若值仍在栈上，则通过<code>pNext</code>进行链表连接后续的外部变量值；若不在栈上，则存储于<code>FixedVal</code>中。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ExternalVal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TValue* pStackVal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> </span><br><span class="line">    &#123;</span><br><span class="line">        Tvalue FixedVal;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ExternalVal* pNext;</span><br><span class="line">        &#125;<span class="built_in">list</span>;</span><br><span class="line">    &#125;value;</span><br><span class="line">&#125;ExternalVal;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;由此，我们再改写一下函数的定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TFunction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Instruction* pPC;		  <span class="comment">// 函数指令集</span></span><br><span class="line">    TValue*	     pLocalVal;    <span class="comment">// 函数内定义的变量</span></span><br><span class="line">    ExternalVal* pExternalVal; <span class="comment">// 外部变量</span></span><br><span class="line">    Other	     otherVal;     <span class="comment">// 辅助变量</span></span><br><span class="line">&#125;TFunction;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;接下来要考虑的，是脚本语言是要和静态语言进行交互的，因此难免会有例如C/C++的函数调用，而此类函数其实仅需要存储函数指针及传值，并不需要用到指令集之类，所以我们对刚刚做的<code>TFunction</code>进行调整，新建<code>CFunction</code>和<code>LFunction</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TFunction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Instruction* pPC;		  <span class="comment">// 函数指令集</span></span><br><span class="line">    TValue*	     pLocalVal;    <span class="comment">// 函数内定义的变量</span></span><br><span class="line">    Other	     otherVal;     <span class="comment">// 辅助变量</span></span><br><span class="line">&#125;TFunction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CFunction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CommonFunctionHeader;</span><br><span class="line">    <span class="keyword">void</span> (func*)(Lua_state* L);</span><br><span class="line">    ExternalVal* pVal;</span><br><span class="line">&#125;CFunction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LFunction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CommonFunctionHeader;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TFunction</span>* <span class="title">pFunction</span>;</span></span><br><span class="line">    ExternalVal*      pVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;考虑到C仅需要传参和返回值，其实用不上这么复杂的<code>ExternalVal</code>，可以直接换为普通的<code>TValue</code>结构体，所以最后可以改为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CFunction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CommonFunctionHeader;</span><br><span class="line">    <span class="keyword">void</span> (func*)(Lua_state* L);</span><br><span class="line">    TValue* pVal;</span><br><span class="line">&#125;CFunction;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;至此，一个灵活的函数结构体就实现完成了。对比Lua，函数原型<code>Proto</code>即为此处的函数通用结构体<code>TFunction</code>，上值<code>UpVal</code>即为外部变量<code>ExternalVal</code>，而上值和函数原型的组合，就称之为闭包Closure。</p>
<p>&emsp;&emsp;下面看看Lua的实现，相关的结构体有<code>Closure</code>及<code>Proto</code>。Lua的函数有三种类型： </p>
<ul>
<li>Lua 函数 (LUA_TLCL)：T Lua Closure</li>
<li>C 函数 (LUA_TCCL)：T  C Closure</li>
<li>轻量级 C 函数 (LUA_TLCF)：Light C Function（5.2之后才有）</li>
</ul>
<p>&emsp;&emsp;其中 LUA_TLCL 和 LUA_TCCL 属于 <code>GCUnion</code>，即需要被回收的类型，被称为 <a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)" target="_blank" rel="noopener">Closure</a>。当 LUA_TCCL 不包含 <code>upvalue</code> 时，直接用 C 函数指针即可，不必构造 Closure 对象, 也就是 LUA_TLCF。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Closures</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ClosureHeader  \</span></span><br><span class="line">    CommonHeader;      \</span><br><span class="line">    lu_byte nupvalues; \</span><br><span class="line">    GCObject *gclist</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CClosure</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ClosureHeader;</span><br><span class="line">    lua_CFunction f;</span><br><span class="line">    TValue upvalue[<span class="number">1</span>]; <span class="comment">/* list of upvalues */</span></span><br><span class="line">&#125; CClosure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LClosure</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ClosureHeader;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Proto</span> *<span class="title">p</span>;</span></span><br><span class="line">    UpVal *upvals[<span class="number">1</span>]; <span class="comment">/* list of upvalues */</span></span><br><span class="line">&#125; LClosure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> Closure</span><br><span class="line">&#123;</span><br><span class="line">    CClosure c;</span><br><span class="line">    LClosure l;</span><br><span class="line">&#125; Closure;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>Proto</code>结构体则是用于将函数解析后的opcode结果传递给后续执行所必备的桥梁，一个Lua文件有一个总的<code>Proto</code>结构体,如果它内部还有定义函数,那么每个函数也有一个对应的<code>Proto</code>结构体，其关键数据结构和我们自己构建的一样。</p>
<ul>
<li>TValue : 存放常量的数组.</li>
<li>Instruction : 存放指令的数组.</li>
<li>struct Proto  : 该Proto内定义的函数相关的Proto数据.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Function Prototypes</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Proto</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CommonHeader;</span><br><span class="line">    lu_byte numparams; <span class="comment">/* number of fixed parameters */</span></span><br><span class="line">    lu_byte is_vararg;</span><br><span class="line">    lu_byte maxstacksize; <span class="comment">/* number of registers needed by this function */</span></span><br><span class="line">    <span class="keyword">int</span> sizeupvalues;     <span class="comment">/* size of 'upvalues' */</span></span><br><span class="line">    <span class="keyword">int</span> sizek;            <span class="comment">/* size of 'k' */</span></span><br><span class="line">    <span class="keyword">int</span> sizecode;</span><br><span class="line">    <span class="keyword">int</span> sizelineinfo;</span><br><span class="line">    <span class="keyword">int</span> sizep; <span class="comment">/* size of 'p' */</span></span><br><span class="line">    <span class="keyword">int</span> sizelocvars;</span><br><span class="line">    <span class="keyword">int</span> linedefined;        <span class="comment">/* debug information  */</span></span><br><span class="line">    <span class="keyword">int</span> lastlinedefined;    <span class="comment">/* debug information  */</span></span><br><span class="line">    TValue *k;              <span class="comment">/* constants used by the function */</span></span><br><span class="line">    Instruction *code;      <span class="comment">/* opcodes */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Proto</span> **<span class="title">p</span>;</span>       <span class="comment">/* functions defined inside the function */</span></span><br><span class="line">    <span class="keyword">int</span> *lineinfo;          <span class="comment">/* map from opcodes to source lines (debug information) */</span></span><br><span class="line">    LocVar *locvars;        <span class="comment">/* information about local variables (debug information) */</span></span><br><span class="line">    Upvaldesc *upvalues;    <span class="comment">/* upvalue information */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LClosure</span> *<span class="title">cache</span>;</span> <span class="comment">/* last-created closure with this prototype */</span></span><br><span class="line">    TString *source;        <span class="comment">/* used for debug information */</span></span><br><span class="line">    GCObject *gclist;</span><br><span class="line">&#125; Proto;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上值<code>UpVal</code>对应的代码如下，这里的closed和open指的就是上文所说明的栈上是否还存在变量的情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">UpVal</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  TValue *v;  <span class="comment">/* points to stack or to its own value */</span></span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    TValue value;  <span class="comment">/* the value (when closed) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span>  <span class="comment">/* double linked list (when open) */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">UpVal</span> *<span class="title">prev</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">UpVal</span> *<span class="title">next</span>;</span></span><br><span class="line">    &#125; l;</span><br><span class="line">  &#125; u;</span><br><span class="line">&#125; UpVal;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这样一来，函数相关的结构体实现就一目了然了。</p>
<h2 id="六-总结"><a href="#六-总结" class="headerlink" title="六. 总结"></a>六. 总结</h2><p>&emsp;&emsp;本文内容涵盖了从零开始构建各种数值数据结构的思路和实现，并比对了Lua源码的实现，相信认真阅读的你一定有所收获，当然如果能边思考边写边自行对比，那一定获益更多了。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://github.com/lichuang/Lua-Source-Internal" target="_blank" rel="noopener">Lua-Source-Internal</a></li>
<li>《A Look at the Design of Lua》</li>
<li><a href="http://lua-users.org/wiki/LuaSource" target="_blank" rel="noopener">http://lua-users.org/wiki/LuaSource</a></li>
<li>《Lua 源码欣赏》</li>
<li>《The Implementation of Lua 5.0》</li>
</ol>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创，坚持分享，谢谢鼓励和支持</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="Ty Chen 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="Ty Chen 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Ty Chen
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://ty-chen.github.io/lua-data-struct/" title="Lua源码剖析（三）数据结构体">https://ty-chen.github.io/lua-data-struct/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Lua/" rel="tag"># Lua</a>
          
            <a href="/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" rel="tag"># 数据类型</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/lua-struct-md/" rel="next" title="Lua源码剖析（二）核心结构体">
                <i class="fa fa-chevron-left"></i> Lua源码剖析（二）核心结构体
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/lua-table-operation/" rel="prev" title="Lua源码剖析（四）数值结构体的操作">
                Lua源码剖析（四）数值结构体的操作 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        
  <div class="bdsharebuttonbox">
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
    <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
    <a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a>
    <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
    <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a class="bds_count" data-cmd="count"></a>
  </div>
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "2",
        "bdMiniList": false,
        "bdPic": ""
      },
      "share": {
        "bdSize": "16",
        "bdStyle": "0"
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/me.JPG"
                alt="Ty Chen" />
            
              <p class="site-author-name" itemprop="name">Ty Chen</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">53</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">86</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Ty-Chen" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:tianyuch@hotmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Friends
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://lishouxian.cn/" title="Stanleylsx" target="_blank">Stanleylsx</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一-前言"><span class="nav-text">一. 前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二-基础数据结构体"><span class="nav-text">二. 基础数据结构体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三-字符串"><span class="nav-text">三. 字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四-表"><span class="nav-text">四. 表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五-上值和函数（闭包）"><span class="nav-text">五. 上值和函数（闭包）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六-总结"><span class="nav-text">六. 总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文献"><span class="nav-text">参考文献</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2020 &mdash; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ty Chen</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">210.1k</span>
  
  <a href="http://www.beian.miit.gov.cn/" target="_blank" rel="noopener">粤ICP备20071543号</a> 
</div>









        
<div class="busuanzi-count">
	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>

  
    <span class="site-uv">
      你是来访的第
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      位同学
    </span>
  

  
    <span class="site-pv">
      访问次数：
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'aTqo2eFkO2Bn0AGX008uKDV7-gzGzoHsz',
        appKey: 'uJ6nxqW7RHWpAILCtttkJfJu',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
